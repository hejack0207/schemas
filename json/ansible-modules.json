{
  "oneOf": [
    {
      "a10_server": {
        "type": "object",
        "description": "Manage A10 Networks AX/SoftAX/Thunder/vThunder devices",
        "properties": {
          "host": {
            "description": "hostname or ip of your A10 Networks device",
            "type": "string"
          },
          "password": {
            "description": "admin password of your A10 Networks device",
            "type": "string"
          },
          "server_ip": {
            "description": "slb server IP address",
            "type": "string"
          },
          "server_name": {
            "description": "slb server name",
            "type": "string"
          },
          "server_ports": {
            "description": "A list of ports to create for the server. Each list item should be a dictionary which specifies the `port:' and `protocol:', but can also optionally specify the `status:'. See the examples below for details. This parameter is required when `state' is `present'.",
            "type": "string"
          },
          "server_status": {
            "description": "slb virtual server status",
            "type": "string"
          },
          "state": {
            "description": "create, update or remove slb server",
            "type": "string"
          },
          "username": {
            "description": "admin account of your A10 Networks device",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled devices using self-signed certificates.",
            "type": "string"
          },
          "write_config": {
            "description": "If `yes', any changes will cause a write of the running configuration to non-volatile memory. This will save `all' configuration changes, including those that may have been made manually or through other modules, so care should be taken when specifying `yes'.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "password",
          "server_name",
          "username"
        ]
      }
    },
    {
      "a10_service_group": {
        "type": "object",
        "description": "Manage A10 Networks devices' service groups",
        "properties": {
          "host": {
            "description": "hostname or ip of your A10 Networks device",
            "type": "string"
          },
          "password": {
            "description": "admin password of your A10 Networks device",
            "type": "string"
          },
          "servers": {
            "description": "A list of servers to add to the service group. Each list item should be a dictionary which specifies the `server:' and `port:', but can also optionally specify the `status:'. See the examples below for details.",
            "type": "string"
          },
          "service_group": {
            "description": "slb service-group name",
            "type": "string"
          },
          "service_group_method": {
            "description": "slb service-group loadbalancing method",
            "type": "string"
          },
          "service_group_protocol": {
            "description": "slb service-group protocol",
            "type": "string"
          },
          "username": {
            "description": "admin account of your A10 Networks device",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled devices using self-signed certificates.",
            "type": "string"
          },
          "write_config": {
            "description": "If `yes', any changes will cause a write of the running configuration to non-volatile memory. This will save `all' configuration changes, including those that may have been made manually or through other modules, so care should be taken when specifying `yes'.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "password",
          "service_group",
          "username"
        ]
      }
    },
    {
      "a10_virtual_server": {
        "type": "object",
        "description": "Manage A10 Networks devices' virtual servers",
        "properties": {
          "host": {
            "description": "hostname or ip of your A10 Networks device",
            "type": "string"
          },
          "password": {
            "description": "admin password of your A10 Networks device",
            "type": "string"
          },
          "username": {
            "description": "admin account of your A10 Networks device",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled devices using self-signed certificates.",
            "type": "string"
          },
          "virtual_server": {
            "description": "slb virtual server name",
            "type": "string"
          },
          "virtual_server_ip": {
            "description": "slb virtual server ip address",
            "type": "string"
          },
          "virtual_server_ports": {
            "description": "A list of ports to create for the virtual server. Each list item should be a dictionary which specifies the `port:' and `type:', but can also optionally specify the `service_group:' as well as the `status:'. See the examples below for details. This parameter is required when `state' is `present'.",
            "type": "string"
          },
          "virtual_server_status": {
            "description": "slb virtual server status",
            "type": "string"
          },
          "write_config": {
            "description": "If `yes', any changes will cause a write of the running configuration to non-volatile memory. This will save `all' configuration changes, including those that may have been made manually or through other modules, so care should be taken when specifying `yes'.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "password",
          "username",
          "virtual_server"
        ]
      }
    },
    {
      "acl": {
        "type": "object",
        "description": "Sets and retrieves file ACL information.",
        "properties": {
          "default": {
            "description": "if the target is a directory, setting this to yes will make it the default acl for entities created inside the directory. It causes an error if name is a file.",
            "type": "string"
          },
          "entity": {
            "description": "actual user or group that the ACL applies to when matching entity types user or group are selected.",
            "type": "string"
          },
          "entry": {
            "description": "DEPRECATED. The acl to set or remove.  This must always be quoted in the form of '< etype>:<qualifier >:<perms>'.  The qualifier may be empty for some types, but the type and perms are always required. '-' can be used as placeholder when you do not care about permissions. This is now superseded by entity, type and permissions fields.",
            "type": "string"
          },
          "etype": {
            "description": "the entity type of the ACL to apply, see setfacl documentation for more info.",
            "type": "string"
          },
          "follow": {
            "description": "whether to follow symlinks on the path if a symlink is encountered.",
            "type": "string"
          },
          "name": {
            "description": "The full path of the file or object.",
            "type": "string"
          },
          "permissions": {
            "description": "Permissions to apply/remove can be any combination of r, w and  x (read, write and execute respectively)",
            "type": "string"
          },
          "recursive": {
            "description": "Recursively sets the specified ACL (added in Ansible 2.0). Incompatible with `state=query'.",
            "type": "string"
          },
          "state": {
            "description": "defines whether the ACL should be present or not.  The `query' state gets the current acl without changing it, for use in 'register' operations.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "add_host": {
        "type": "object",
        "description": "add a host (and alternatively a group) to the ansible-playbook in-memory inventory",
        "properties": {
          "groups": {
            "description": "The groups to add the hostname to, comma separated.",
            "type": "string"
          },
          "name": {
            "description": "The hostname/ip of the host to add to the inventory, can include a colon and a port number.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "airbrake_deployment": {
        "type": "object",
        "description": "Notify airbrake about app deployments",
        "properties": {
          "environment": {
            "description": "The airbrake environment name, typically 'production', 'staging', etc.",
            "type": "string"
          },
          "repo": {
            "description": "URL of the project repository",
            "type": "string"
          },
          "revision": {
            "description": "A hash, number, tag, or other identifier showing what revision was deployed",
            "type": "string"
          },
          "token": {
            "description": "API token.",
            "type": "string"
          },
          "url": {
            "description": "Optional URL to submit the notification to. Use to send notifications to Airbrake- compliant tools like Errbit.",
            "type": "string"
          },
          "user": {
            "description": "The username of the person doing the deployment",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates for the target url will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": [
          "environment",
          "token"
        ]
      }
    },
    {
      "alternatives": {
        "type": "object",
        "description": "Manages alternative programs for common commands",
        "properties": {
          "link": {
            "description": "The path to the symbolic link that should point to the real executable. This option is required on RHEL- based distributions",
            "type": "string"
          },
          "name": {
            "description": "The generic name of the link.",
            "type": "string"
          },
          "path": {
            "description": "The path to the real executable that the link should point to.",
            "type": "string"
          },
          "priority": {
            "description": "The priority of the alternative",
            "type": "string"
          }
        },
        "required": [
          "name",
          "path"
        ]
      }
    },
    {
      "apache2_mod_proxy": {
        "type": "object",
        "description": "Set and/or get members' attributes of an Apache httpd 2.4 mod_proxy balancer pool",
        "properties": {
          "balancer_url_suffix": {
            "description": "Suffix of the balancer pool url required to access the balancer pool status page (e.g. balancer_vhost[:p ort]/balancer_url _suffix).",
            "type": "string"
          },
          "balancer_vhost": {
            "description": "(ipv4|ipv6|fqdn):port of the Apache httpd 2.4 mod_proxy balancer pool.",
            "type": "string"
          },
          "member_host": {
            "description": "(ipv4|ipv6|fqdn) of the balancer member to get or to set attributes to. Port number is autodetected and should not be specified here. If undefined, apache2_mod_proxy module will return a members list of dictionaries of all the current balancer pool members' attributes.",
            "type": "string"
          },
          "state": {
            "description": "Desired state of the member host. (absent|disabl ed),drained,hot_s tandby,ignore_err ors can be simultaneously invoked by separating them with a comma (e.g. state=drain ed,ignore_errors) .",
            "type": "string"
          },
          "tls": {
            "description": "Use https to access balancer management page.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Validate ssl/tls certificates.",
            "type": "string"
          }
        },
        "required": "balancer_vhost"
      }
    },
    {
      "apache2_module": {
        "type": "object",
        "description": "enables/disables a module of the Apache2 webserver",
        "properties": {
          "force": {
            "description": "force disabling of default modules and override Debian warnings",
            "type": "string"
          },
          "name": {
            "description": "name of the module to enable/disable",
            "type": "string"
          },
          "state": {
            "description": "indicate the desired state of the resource",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "apk": {
        "type": "object",
        "description": "Manages apk packages",
        "properties": {
          "name": {
            "description": "A package name, like `foo', or mutliple packages, like `foo, bar'.",
            "type": "string"
          },
          "state": {
            "description": "Indicates the desired package(s) state. `present' ensures the package(s) is/are present. `absent' ensures the package(s) is/are absent. `latest' ensures the package(s) is/are present and the latest version(s).",
            "type": "string"
          },
          "update_cache": {
            "description": "Update repository indexes. Can be run with other steps or on it's own.",
            "type": "string"
          },
          "upgrade": {
            "description": "Upgrade all installed packages to their latest version.",
            "type": "string"
          }
        }
      }
    },
    {
      "apt": {
        "type": "object",
        "description": "Manages apt-packages",
        "properties": {
          "allow_unauthenticated": {
            "description": "Ignore if packages cannot be authenticated. This is useful for bootstrapping environments that manage their own apt-key setup.",
            "type": "string"
          },
          "autoremove": {
            "description": "If `yes', remove unused dependency packages for all module states except `build- dep'.",
            "type": "string"
          },
          "cache_valid_time": {
            "description": "Update the apt cache if its older than the `cache_valid_time '. This option is set in seconds.",
            "type": "string"
          },
          "deb": {
            "description": "Path to a .deb package on the remote machine. If :// in the path, ansible will attempt to download deb before installing. (Version added 2.1)",
            "type": "string"
          },
          "default_release": {
            "description": "Corresponds to the `-t' option for `apt' and sets pin priorities",
            "type": "string"
          },
          "dpkg_options": {
            "description": "Add dpkg options to apt command. Defaults to '-o \"Dpkg::Options ::=--force- confdef\" -o \"Dpkg::Options ::=--force- confold\"' Options should be supplied as comma separated list",
            "type": "string"
          },
          "force": {
            "description": "If `yes', force installs/removes.",
            "type": "string"
          },
          "install_recommends": {
            "description": "Corresponds to the `--no-install-recommends' option for `apt'. `yes' installs recommended packages.  `no' does not install recommended packages. By default, Ansible will use the same defaults as the operating system. Suggested packages are never installed.",
            "type": "string"
          },
          "name": {
            "description": "A package name, like `foo', or package specifier with version, like `foo=1.0'. Name wildcards (fnmatch) like `apt*' and version wildcards like `foo=1.0*' are also supported.  Note that the apt-get commandline supports implicit regex matches here but we do not because it can let typos through easier (If you typo `foo' as `fo' apt-get would install packages that have \"fo\" in their name with a warning and a prompt for the user.  Since we don't have warnings and prompts before installing we disallow this. Use an explicit fnmatch pattern if you want wildcarding)",
            "type": "string"
          },
          "only_upgrade": {
            "description": "Only install/upgrade a package if it is already installed.",
            "type": "string"
          },
          "purge": {
            "description": "Will force purging of configuration files if the module state is set to `absent'.",
            "type": "string"
          },
          "state": {
            "description": "Indicates the desired package state. `latest' ensures that the latest version is installed. `build-dep' ensures the package build dependencies are installed.",
            "type": "string"
          },
          "update_cache": {
            "description": "Run the equivalent of `apt-get update' before the operation. Can be run as part of the package installation or as a separate step.",
            "type": "string"
          },
          "upgrade": {
            "description": "If yes or safe, performs an aptitude safe- upgrade. If full, performs an aptitude full- upgrade. If dist, performs an apt- get dist-upgrade. Note: This does not upgrade a specific package, use state=latest for that.",
            "type": "string"
          }
        }
      }
    },
    {
      "apt_key": {
        "type": "object",
        "description": "Add or remove an apt key",
        "properties": {
          "data": {
            "description": "keyfile contents to add to the keyring",
            "type": "string"
          },
          "file": {
            "description": "path to a keyfile to add to the keyring",
            "type": "string"
          },
          "id": {
            "description": "identifier of key. Including this allows check mode to correctly report the changed state. If specifying a subkey's id be aware that apt- key does not understand how to remove keys via a subkey id. Specify the primary key's id instead.",
            "type": "string"
          },
          "keyring": {
            "description": "path to specific keyring file in /etc/apt/trusted. gpg.d",
            "type": "string"
          },
          "keyserver": {
            "description": "keyserver to retrieve key from.",
            "type": "string"
          },
          "state": {
            "description": "used to specify if key is being added or revoked",
            "type": "string"
          },
          "url": {
            "description": "url to retrieve key from.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates for the target url will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        }
      }
    },
    {
      "apt_repository": {
        "type": "object",
        "description": "Add and remove APT repositories",
        "properties": {
          "filename": {
            "description": "Sets the name of the source list file in sources.list.d. Defaults to a file name based on the repository source url. The .list extension will be automatically added.",
            "type": "string"
          },
          "mode": {
            "description": "The octal mode for newly created files in sources.list.d",
            "type": "string"
          },
          "repo": {
            "description": "A source string for the repository.",
            "type": "string"
          },
          "state": {
            "description": "A source string state.",
            "type": "string"
          },
          "update_cache": {
            "description": "Run the equivalent of `apt-get update' when a change occurs. Cache updates are run after making changes.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates for the target repo will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": "repo"
      }
    },
    {
      "apt_rpm": {
        "type": "object",
        "description": "apt_rpm package manager",
        "properties": {
          "pkg": {
            "description": "name of package to install, upgrade or remove.",
            "type": "string"
          },
          "state": {
            "description": "Indicates the desired package state",
            "type": "string"
          },
          "update_cache": {
            "description": "update the package database first `apt-get update'.",
            "type": "string"
          }
        },
        "required": "pkg"
      }
    },
    {
      "asa_acl": {
        "type": "object",
        "description": "Manage access-lists on a Cisco ASA",
        "properties": {
          "after": {
            "description": "The ordered set of commands to append to the end of the command stack if a changed needs to be made.  Just like with `before' this allows the playbook designer to append a set of commands to be executed after the command set.",
            "type": "string"
          },
          "auth_pass": {
            "description": "Specifies the password to use if required to enter privileged mode on the remote device. If `authorize' is false, then this argument does nothing. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_AUTH_PASS' will be used instead.",
            "type": "string"
          },
          "authorize": {
            "description": "Instructs the module to enter privileged mode on the remote device before sending any commands.  If not specified, the device will attempt to execute all commands in non- privileged mode. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_AUTHORIZE' will be used instead.",
            "type": "string"
          },
          "before": {
            "description": "The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.",
            "type": "string"
          },
          "config": {
            "description": "The module, by default, will connect to the remote device and retrieve the current running- config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The `config' argument allows the implementer to pass in the configuruation to use as the base config for comparision.",
            "type": "string"
          },
          "context": {
            "description": "Specifies which context to target if you are running in the ASA in multiple context mode. Defaults to the current context you login to.",
            "type": "string"
          },
          "force": {
            "description": "The force argument instructs the module to not consider the current devices running-config. When set to true, this will cause the module to push the contents of `src' into the device without first checking if already configured.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "lines": {
            "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config. Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.",
            "type": "string"
          },
          "match": {
            "description": "Instructs the module on the way to perform the matching of the set of commands against the current device config.  If match is set to `line', commands are matched line by line.  If match is set to `strict', command lines are matched with respect to position. Finally if match is set to `exact', command lines must be an equal match.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.   The value of `password' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. The port value will default to the well known SSH port of 22",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `ios' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "replace": {
            "description": "Instructs the module on the way to perform the configuration on the device.  If the replace argument is set to `line' then the modified lines are pushed to the device in configuration mode.  If the replace argument is set to `block' then the entire command block is pushed to the device in configuration mode if any line is not correct.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. The value of `ssh_keyfile' is the path to the key used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "timeout": {
            "description": "Specifies idle timeout for the connection. Useful if the console freezes before continuing. For example when saving configurations.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "lines"
        ]
      }
    },
    {
      "asa_command": {
        "type": "object",
        "description": "Run arbitrary commands on Cisco ASA devices.",
        "properties": {
          "auth_pass": {
            "description": "Specifies the password to use if required to enter privileged mode on the remote device. If `authorize' is false, then this argument does nothing. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_AUTH_PASS' will be used instead.",
            "type": "string"
          },
          "authorize": {
            "description": "Instructs the module to enter privileged mode on the remote device before sending any commands.  If not specified, the device will attempt to execute all commands in non- privileged mode. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_AUTHORIZE' will be used instead.",
            "type": "string"
          },
          "commands": {
            "description": "List of commands to send to the remote device over the configured provider. The resulting output from the command is returned. If the `wait_for' argument is provided, the module is not returned until the condition is satisfied or the number of retires as expired.",
            "type": "string"
          },
          "context": {
            "description": "Specifies which context to target if you are running in the ASA in multiple context mode. Defaults to the current context you login to.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "interval": {
            "description": "Configures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.",
            "type": "string"
          },
          "match": {
            "description": "The `match' argument is used in conjunction with the `wait_for' argument to specify the match policy.  Valid values are `all' or `any'.  If the value is set to `all' then all conditionals in the wait_for must be satisfied.  If the value is set to `any' then only one of the values must be satisfied.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.   The value of `password' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. The port value will default to the well known SSH port of 22",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `ios' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "retries": {
            "description": "Specifies the number of retries a command should by tried before it is considered failed. The command is run on the target device every retry and evaluated against the `wait_for' conditions.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. The value of `ssh_keyfile' is the path to the key used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "timeout": {
            "description": "Specifies idle timeout for the connection. Useful if the console freezes before continuing. For example when saving configurations.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          },
          "wait_for": {
            "description": "List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.",
            "type": "string"
          }
        },
        "required": [
          "commands",
          "host"
        ]
      }
    },
    {
      "asa_config": {
        "type": "object",
        "description": "Manage Cisco ASA configuration sections",
        "properties": {
          "after": {
            "description": "The ordered set of commands to append to the end of the command stack if a change needs to be made. Just like with `before' this allows the playbook designer to append a set of commands to be executed after the command set.",
            "type": "string"
          },
          "auth_pass": {
            "description": "Specifies the password to use if required to enter privileged mode on the remote device. If `authorize' is false, then this argument does nothing. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_AUTH_PASS' will be used instead.",
            "type": "string"
          },
          "authorize": {
            "description": "Instructs the module to enter privileged mode on the remote device before sending any commands.  If not specified, the device will attempt to execute all commands in non- privileged mode. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_AUTHORIZE' will be used instead.",
            "type": "string"
          },
          "backup": {
            "description": "This argument will cause the module to create a full backup of the current `running-config' from the remote device before any changes are made. The backup file is written to the `backup' folder in the playbook root directory. If the directory does not exist, it is created.",
            "type": "string"
          },
          "before": {
            "description": "The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system",
            "type": "string"
          },
          "commit": {
            "description": "This argument specifies the update method to use when applying the configuration changes to the remote node.  If the value is set to `merge' the configuration updates are merged with the running- config. If the value is set to `check', no changes are made to the remote host.",
            "type": "string"
          },
          "config": {
            "description": "The `config' argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node.",
            "type": "string"
          },
          "context": {
            "description": "Specifies which context to target if you are running in the ASA in multiple context mode. Defaults to the current context you login to.",
            "type": "string"
          },
          "defaults": {
            "description": "This argument specifies whether or not to collect all defaults when getting the remote device running config. When enabled, the module will get the current config by issuing the command `show running-config all'.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "lines": {
            "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config. Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.",
            "type": "string"
          },
          "match": {
            "description": "Instructs the module on the way to perform the matching of the set of commands against the current device config.  If match is set to `line', commands are matched line by line.  If match is set to `strict', command lines are matched with respect to position.  If match is set to `exact', command lines must be an equal match. Finally, if match is set to `none', the module will not attempt to compare the source configuration with the running configuration on the remote device.",
            "type": "string"
          },
          "parents": {
            "description": "The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.   The value of `password' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "passwords": {
            "description": "This argument specifies to include passwords in the config when retrieving the running-config from the remote device.  This includes passwords related to VPN endpoints. This argument is mutually exclusive with `defaults'.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. The port value will default to the well known SSH port of 22",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `ios' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "replace": {
            "description": "Instructs the module on the way to perform the configuration on the device.  If the replace argument is set to `line' then the modified lines are pushed to the device in configuration mode.  If the replace argument is set to `block' then the entire command block is pushed to the device in configuration mode if any line is not correct",
            "type": "string"
          },
          "save": {
            "description": "The `save' argument instructs the module to save the running- config to the startup-config at the conclusion of the module running.  If check mode is specified, this argument is ignored.",
            "type": "string"
          },
          "src": {
            "description": "Specifies the source path to the file that contains the configuration or configuration template to load. The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with `lines'.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. The value of `ssh_keyfile' is the path to the key used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "timeout": {
            "description": "Specifies idle timeout for the connection. Useful if the console freezes before continuing. For example when saving configurations.",
            "type": "string"
          },
          "update": {
            "description": "The `update' argument controls how the configuration statements are processed on the remote device. Valid choices for the `update' argument are `merge' and `check'.  When the argument is set to `merge', the configuration changes are merged with the current device running configuration. When the argument is set to `check' the configuration updates are determined but not actually configured on the remote device.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": "host"
      }
    },
    {
      "assemble": {
        "type": "object",
        "description": "Assembles a configuration file from fragments",
        "properties": {
          "backup": {
            "description": "Create a backup file (if `yes'), including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.",
            "type": "string"
          },
          "delimiter": {
            "description": "A delimiter to separate the file contents.",
            "type": "string"
          },
          "dest": {
            "description": "A file to create using the concatenation of all of the source files.",
            "type": "string"
          },
          "group": {
            "description": "name of the group that should own the file/directory, as would be fed to `chown'",
            "type": "string"
          },
          "ignore_hidden": {
            "description": "A boolean that controls if files that start with a '.' will be included or not.",
            "type": "string"
          },
          "mode": {
            "description": "mode the file or directory should be. For those used to `/usr/bin/chmod' remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, `u+rwx' or `u=rw,g=r,o=r').",
            "type": "string"
          },
          "owner": {
            "description": "name of the user that should own the file/directory, as would be fed to `chown'",
            "type": "string"
          },
          "regexp": {
            "description": "Assemble files only if `regex' matches the filename. If not set, all files are assembled. All \"\\\" (backslash) must be escaped as \"\\\\\" to comply yaml syntax. Uses Python regular expressions; see  http://docs.pytho n.org/2/library/r e.html.",
            "type": "string"
          },
          "remote_src": {
            "description": "If False, it will search for src at originating/maste r machine, if True it will go to the remote/target machine for the src. Default is True.",
            "type": "string"
          },
          "selevel": {
            "description": "level part of the SELinux file context. This is the MLS/MCS attribute, sometimes known as the `range'. `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "serole": {
            "description": "role part of SELinux file context, `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "setype": {
            "description": "type part of SELinux file context, `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "seuser": {
            "description": "user part of SELinux file context. Will default to system policy, if applicable. If set to `_default', it will use the `user' portion of the policy if available",
            "type": "string"
          },
          "src": {
            "description": "An already existing directory full of source files.",
            "type": "string"
          },
          "unsafe_writes": {
            "description": "Normally this module uses atomic operations to prevent data corruption or inconsistent reads from the target files, sometimes systems are configured or just broken in ways that prevent this. One example are docker mounted files, they cannot be updated atomically and can only be done in an unsafe manner. This boolean option allows ansible to fall back to unsafe methods of updating files for those cases in which you do not have any other choice. Be aware that this is subject to race conditions and can lead to data corruption.",
            "type": "string"
          },
          "validate": {
            "description": "The validation command to run before copying into place.  The path to the file to validate is passed in via '%s' which must be present as in the sshd example below. The command is passed securely so shell features like expansion and pipes won't work.",
            "type": "string"
          }
        },
        "required": [
          "dest",
          "src"
        ]
      }
    },
    {
      "assert": {
        "type": "object",
        "description": "Asserts given expressions are true",
        "properties": {
          "msg": {
            "description": "The customized message used for a failing assertion",
            "type": "string"
          },
          "that": {
            "description": "A string expression of the same form that can be passed to the 'when' statement Alternatively, a list of string expressions",
            "type": "string"
          }
        },
        "required": "that"
      }
    },
    {
      "async_status": {
        "type": "object",
        "description": "Obtain status of asynchronous task",
        "properties": {
          "jid": {
            "description": "Job or task identifier",
            "type": "string"
          },
          "mode": {
            "description": "if `status', obtain the status; if `cleanup', clean up the async job cache located in `~/.an sible_async/' for the specified job `jid'.",
            "type": "string"
          }
        },
        "required": "jid"
      }
    },
    {
      "at": {
        "type": "object",
        "description": "Schedule the execution of a command or script file via the at command.",
        "properties": {
          "command": {
            "description": "A command to be executed in the future.",
            "type": "string"
          },
          "count": {
            "description": "The count of units in the future to execute the command or script file.",
            "type": "string"
          },
          "script_file": {
            "description": "An existing script file to be executed in the future.",
            "type": "string"
          },
          "state": {
            "description": "The state dictates if the command or script file should be evaluated as present(added) or absent(deleted).",
            "type": "string"
          },
          "unique": {
            "description": "If a matching job is present a new job will not be added.",
            "type": "string"
          },
          "units": {
            "description": "The type of units in the future to execute the command or script file.",
            "type": "string"
          }
        },
        "required": [
          "count",
          "units"
        ]
      }
    },
    {
      "atomic_host": {
        "type": "object",
        "description": "Manage the atomic host platform",
        "properties": {
          "revision": {
            "description": "The version number of the atomic host to be deployed. Providing ```latest``` will upgrade to the latest available version.",
            "type": "string"
          }
        }
      }
    },
    {
      "atomic_image": {
        "type": "object",
        "description": "Manage the container images on the atomic host platform",
        "properties": {
          "name": {
            "description": "Name of the container image",
            "type": "string"
          },
          "started": {
            "description": "Start or Stop the continer",
            "type": "string"
          },
          "state": {
            "description": "The state of the container image. The state ```latest``` will ensure container image is upgraded to the latest version and forcefully restart container, if running.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "authorized_key": {
        "type": "object",
        "description": "Adds or removes an SSH authorized key",
        "properties": {
          "exclusive": {
            "description": "Whether to remove all other non-specified keys from the authorized_keys file. Multiple keys can be specified in a single `key' string value by separating them by newlines. This option is not loop aware, so if you use `with_' , it will be exclusive per iteration of the loop, if you want multiple keys in the file you need to pass them all to `key' in a single batch as mentioned above.",
            "type": "string"
          },
          "key": {
            "description": "The SSH public key(s), as a string or (since 1.9) url (https:/ /github.com/usern ame.keys)",
            "type": "string"
          },
          "key_options": {
            "description": "A string of ssh key options to be prepended to the key in the authorized_keys file",
            "type": "string"
          },
          "manage_dir": {
            "description": "Whether this module should manage the directory of the authorized key file.  If set, the module will create the directory, as well as set the owner and permissions of an existing directory. Be sure to set `manage_dir=no' if you are using an alternate directory for authorized_keys, as set with `path', since you could lock yourself out of SSH access. See the example below.",
            "type": "string"
          },
          "path": {
            "description": "Alternate path to the authorized_keys file",
            "type": "string"
          },
          "state": {
            "description": "Whether the given key (with the given key_options) should or should not be in the file",
            "type": "string"
          },
          "user": {
            "description": "The username on the remote host whose authorized_keys file will be modified",
            "type": "string"
          },
          "validate_certs": {
            "description": "This only applies if using a https url as the source of the keys. If set to `no', the SSL certificates will not be validated. This should only set to `no' used on personally controlled sites using self-signed certificates as it avoids verifying the source site. Prior to 2.1 the code worked as if this was set to `yes'.",
            "type": "string"
          }
        },
        "required": [
          "key",
          "user"
        ]
      }
    },
    {
      "azure": {
        "type": "object",
        "description": "create or terminate a virtual machine in azure",
        "properties": {
          "auto_updates": {
            "description": "Enable Auto Updates on Windows Machines",
            "type": "string"
          },
          "enable_winrm": {
            "description": "Enable winrm on Windows Machines",
            "type": "string"
          },
          "endpoints": {
            "description": "a comma-separated list of TCP ports to expose on the virtual machine (e.g., \"22,80\")",
            "type": "string"
          },
          "hostname": {
            "description": "hostname to write /etc/hostname. Defaults to <name>.cloudapp.n et.",
            "type": "string"
          },
          "image": {
            "description": "system image for creating the virtual machine (e.g., b39f27a8b8 c64d52b05eac6a62e bad85__Ubuntu_DAI LY_BUILD-precise- 12_04_3-LTS-amd64 -server-20131205 -en-us-30GB)",
            "type": "string"
          },
          "location": {
            "description": "the azure location to use (e.g. 'East US')",
            "type": "string"
          },
          "management_cert_path": {
            "description": "path to an azure management certificate associated with the subscription id. Overrides the AZURE_CERT_PATH environment variable.",
            "type": "string"
          },
          "name": {
            "description": "name of the virtual machine and associated cloud service.",
            "type": "string"
          },
          "os_type": {
            "description": "The type of the os that is gettings provisioned",
            "type": "string"
          },
          "password": {
            "description": "the unix password for the new virtual machine.",
            "type": "string"
          },
          "role_size": {
            "description": "azure role size for the new virtual machine (e.g., Small, ExtraLarge, A6). You have to pay attention to the fact that instances of type G and DS are not available in all regions (locations). Make sure if you selected the size and type of instance available in your chosen location.",
            "type": "string"
          },
          "ssh_cert_path": {
            "description": "path to an X509 certificate containing the public ssh key to install in the virtual machine. See http://www.wi ndowsazure.com /en-us/manage/lin ux/tutorials /intro-to-linux/ for more details. if this option is specified, password-based ssh authentication will be disabled.",
            "type": "string"
          },
          "state": {
            "description": "create or terminate instances",
            "type": "string"
          },
          "storage_account": {
            "description": "the azure storage account in which to store the data disks.",
            "type": "string"
          },
          "subscription_id": {
            "description": "azure subscription id. Overrides the AZURE_SUBSCRIPTIO N_ID environment variable.",
            "type": "string"
          },
          "user": {
            "description": "the unix username for the new virtual machine.",
            "type": "string"
          },
          "virtual_network_name": {
            "description": "Name of virtual network.",
            "type": "string"
          },
          "wait": {
            "description": "wait for the instance to be in state 'running' before returning",
            "type": "string"
          },
          "wait_timeout": {
            "description": "how long before wait gives up, in seconds",
            "type": "string"
          },
          "wait_timeout_redirects": {
            "description": "how long before wait gives up for redirects, in seconds",
            "type": "string"
          }
        },
        "required": [
          "image",
          "location",
          "name",
          "storage_account"
        ]
      }
    },
    {
      "azure_rm_deployment": {
        "type": "object",
        "description": "Create or destroy Azure Resource Manager template deployments",
        "properties": {
          "ad_user": {
            "description": "Active Directory username. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "client_id": {
            "description": "Azure client ID. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "deployment_mode": {
            "description": "In incremental mode, resources are deployed without deleting existing resources that are not included in the template. In complete mode resources are deployed and existing resources in the resource group not included in the template are deleted.",
            "type": "string"
          },
          "deployment_name": {
            "description": "The name of the deployment to be tracked in the resource group deployment history. Re-using a deployment name will overwrite the previous value in the resource group's deployment history.",
            "type": "string"
          },
          "location": {
            "description": "The geo-locations in which the resource group will be located.",
            "type": "string"
          },
          "parameters": {
            "description": "A hash of all the required template variables for the deployment template. This parameter is mutually exclusive with 'p arameters_link'. Either one of them is required if \"state\" parameter is \"present\".",
            "type": "string"
          },
          "parameters_link": {
            "description": "Uri of file containing the parameters body. This parameter is mutually exclusive with 'parameters'. Either one of them is required if \"state\" parameter is \"present\".",
            "type": "string"
          },
          "password": {
            "description": "Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "profile": {
            "description": "Security profile found in ~/.azure/credentials file.",
            "type": "string"
          },
          "resource_group_name": {
            "description": "The resource group name to use or create to host the deployed template",
            "type": "string"
          },
          "secret": {
            "description": "Azure client secret. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "state": {
            "description": "If state is \"present\", template will be created. If state is \"present\" and if deployment exists, it will be updated. If state is \"absent\", stack will be removed.",
            "type": "string"
          },
          "subscription_id": {
            "description": "Your Azure subscription Id.",
            "type": "string"
          },
          "template": {
            "description": "A hash containing the templates inline. This parameter is mutually exclusive with 'template_link'. Either one of them is required if \"state\" parameter is \"present\".",
            "type": "string"
          },
          "template_link": {
            "description": "Uri of file containing the template body. This parameter is mutually exclusive with 'template'. Either one of them is required if \"state\" parameter is \"present\".",
            "type": "string"
          },
          "tenant": {
            "description": "Azure tenant ID. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "wait_for_deployment_completion": {
            "description": "Whether or not to block until the deployment has completed.",
            "type": "string"
          },
          "wait_for_deployment_polling_period": {
            "description": "Time (in seconds) to wait between polls when waiting for deployment completion.",
            "type": "string"
          }
        },
        "required": "resource_group_name"
      }
    },
    {
      "azure_rm_networkinterface": {
        "type": "object",
        "description": "Manage Azure network interfaces.",
        "properties": {
          "ad_user": {
            "description": "Active Directory username. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "append_tags": {
            "description": "Use to control if tags field is canonical or just appends to existing tags. When canonical, any tags not found in the tags parameter will be removed from the object's metadata.",
            "type": "string"
          },
          "client_id": {
            "description": "Azure client ID. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "location": {
            "description": "Valid azure location. Defaults to location of the resource group.",
            "type": "string"
          },
          "name": {
            "description": "Name of the network interface.",
            "type": "string"
          },
          "open_ports": {
            "description": "When a default security group is created for a Linux host a rule will be added allowing inbound TCP connections to the default SSH port 22, and for a Windows host rules will be added allowing inbound access to RDP ports 3389 and 5986. Override the default ports by providing a list of open ports.",
            "type": "string"
          },
          "os_type": {
            "description": "Determines any rules to be added to a default security group. When creating a network interface, if no security group name is provided, a default security group will be created. If the os_type is 'Windows', a rule will be added allowing RDP access. If the os_type is 'Linux', a rule allowing SSH access will be added.",
            "type": "string"
          },
          "password": {
            "description": "Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "private_ip_address": {
            "description": "Valid IPv4 address that falls within the specified subnet.",
            "type": "string"
          },
          "private_ip_allocation_method": {
            "description": "Specify whether or not the assigned IP address is permanent. NOTE: when creating a network interface specifying a value of 'Static' requires that a p rivate_ip_address value be provided. You can update the allocation method to 'Static' after a dynamic private ip address has been assigned.",
            "type": "string"
          },
          "profile": {
            "description": "Security profile found in ~/.azure/credentials file.",
            "type": "string"
          },
          "public_ip": {
            "description": "When creating a network interface, if no public IP address name is provided a default public IP address will be created. Set to false, if you do not want a public IP address automatically created.",
            "type": "string"
          },
          "public_ip_address_name": {
            "description": "Name of an existing public IP address object to associate with the security group.",
            "type": "string"
          },
          "public_ip_allocation_method": {
            "description": "If a public_ip_address_name is not provided, a default public IP address will be created. The allocation method determines whether or not the public IP address assigned to the network interface is permanent.",
            "type": "string"
          },
          "resource_group": {
            "description": "Name of a resource group where the network interface exists or will be created.",
            "type": "string"
          },
          "secret": {
            "description": "Azure client secret. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "security_group_name": {
            "description": "Name of an existing security group with which to associate the network interface. If not provided, a default security group will be created.",
            "type": "string"
          },
          "state": {
            "description": "Assert the state of the network interface. Use 'present' to create or update an interface and 'absent' to delete an interface.",
            "type": "string"
          },
          "subnet_name": {
            "description": "Name of an existing subnet within the specified virtual network. Required when creating a network interface",
            "type": "string"
          },
          "subscription_id": {
            "description": "Your Azure subscription Id.",
            "type": "string"
          },
          "tags": {
            "description": "Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.",
            "type": "string"
          },
          "tenant": {
            "description": "Azure tenant ID. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "virtual_network_name": {
            "description": "Name of an existing virtual network with which the network interface will be associated. Required when creating a network interface.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "resource_group"
        ]
      }
    },
    {
      "azure_rm_networkinterface_facts": {
        "type": "object",
        "description": "Get network interface facts.",
        "properties": {
          "ad_user": {
            "description": "Active Directory username. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "client_id": {
            "description": "Azure client ID. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "name": {
            "description": "Only show results for a specific network interface.",
            "type": "string"
          },
          "password": {
            "description": "Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "profile": {
            "description": "Security profile found in ~/.azure/credentials file.",
            "type": "string"
          },
          "resource_group": {
            "description": "Name of the resource group containing the network interface(s). Required when searching by name.",
            "type": "string"
          },
          "secret": {
            "description": "Azure client secret. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "subscription_id": {
            "description": "Your Azure subscription Id.",
            "type": "string"
          },
          "tags": {
            "description": "Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.",
            "type": "string"
          },
          "tenant": {
            "description": "Azure tenant ID. Use when authenticating with a Service Principal.",
            "type": "string"
          }
        }
      }
    },
    {
      "azure_rm_publicipaddress": {
        "type": "object",
        "description": "Manage Azure Public IP Addresses.",
        "properties": {
          "ad_user": {
            "description": "Active Directory username. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "allocation_method": {
            "description": "Control whether the assigned Public IP remains permanently assigned to the object. If not set to 'Static', the IP address my changed anytime an associated virtual machine is power cycled.",
            "type": "string"
          },
          "append_tags": {
            "description": "Use to control if tags field is canonical or just appends to existing tags. When canonical, any tags not found in the tags parameter will be removed from the object's metadata.",
            "type": "string"
          },
          "client_id": {
            "description": "Azure client ID. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "domain_name_label": {
            "description": "The customizable portion of the FQDN assigned to public IP address. This is an explicit setting. If no value is provided, any existing value will be removed on an existing public IP.",
            "type": "string"
          },
          "location": {
            "description": "Valid azure location. Defaults to location of the resource group.",
            "type": "string"
          },
          "name": {
            "description": "Name of the Public IP.",
            "type": "string"
          },
          "password": {
            "description": "Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "profile": {
            "description": "Security profile found in ~/.azure/credentials file.",
            "type": "string"
          },
          "resource_group": {
            "description": "Name of resource group with which the Public IP is associated.",
            "type": "string"
          },
          "secret": {
            "description": "Azure client secret. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "state": {
            "description": "Assert the state of the Public IP. Use 'present' to create or update a and 'absent' to delete.",
            "type": "string"
          },
          "subscription_id": {
            "description": "Your Azure subscription Id.",
            "type": "string"
          },
          "tags": {
            "description": "Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.",
            "type": "string"
          },
          "tenant": {
            "description": "Azure tenant ID. Use when authenticating with a Service Principal.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "resource_group"
        ]
      }
    },
    {
      "azure_rm_publicip_facts": {
        "type": "object",
        "description": "Get public IP facts.",
        "properties": {
          "ad_user": {
            "description": "Active Directory username. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "client_id": {
            "description": "Azure client ID. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "name": {
            "description": "Only show results for a specific Public IP.",
            "type": "string"
          },
          "password": {
            "description": "Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "profile": {
            "description": "Security profile found in ~/.azure/credentials file.",
            "type": "string"
          },
          "resource_group": {
            "description": "Limit results by resource group. Required when using name parameter.",
            "type": "string"
          },
          "secret": {
            "description": "Azure client secret. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "subscription_id": {
            "description": "Your Azure subscription Id.",
            "type": "string"
          },
          "tags": {
            "description": "Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.",
            "type": "string"
          },
          "tenant": {
            "description": "Azure tenant ID. Use when authenticating with a Service Principal.",
            "type": "string"
          }
        }
      }
    },
    {
      "azure_rm_resourcegroup": {
        "type": "object",
        "description": "Manage Azure resource groups.",
        "properties": {
          "ad_user": {
            "description": "Active Directory username. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "append_tags": {
            "description": "Use to control if tags field is canonical or just appends to existing tags. When canonical, any tags not found in the tags parameter will be removed from the object's metadata.",
            "type": "string"
          },
          "client_id": {
            "description": "Azure client ID. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "force": {
            "description": "Remove a resource group and all associated resources. Use with state 'absent' to delete a resource group that contains resources.",
            "type": "string"
          },
          "location": {
            "description": "Azure location for the resource group. Required when creating a new resource group. Cannot be changed once resource group is created.",
            "type": "string"
          },
          "name": {
            "description": "Name of the resource group.",
            "type": "string"
          },
          "password": {
            "description": "Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "profile": {
            "description": "Security profile found in ~/.azure/credentials file.",
            "type": "string"
          },
          "secret": {
            "description": "Azure client secret. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "state": {
            "description": "Assert the state of the resource group. Use 'present' to create or update and 'absent' to delete. When 'absent' a resource group containing resources will not be removed unless the force option is used.",
            "type": "string"
          },
          "subscription_id": {
            "description": "Your Azure subscription Id.",
            "type": "string"
          },
          "tags": {
            "description": "Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.",
            "type": "string"
          },
          "tenant": {
            "description": "Azure tenant ID. Use when authenticating with a Service Principal.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "azure_rm_resouregroup_facts": {
        "type": "object",
        "description": "Get resource group facts.",
        "properties": {
          "ad_user": {
            "description": "Active Directory username. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "client_id": {
            "description": "Azure client ID. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "name": {
            "description": "Limit results to a specific resource group.",
            "type": "string"
          },
          "password": {
            "description": "Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "profile": {
            "description": "Security profile found in ~/.azure/credentials file.",
            "type": "string"
          },
          "secret": {
            "description": "Azure client secret. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "subscription_id": {
            "description": "Your Azure subscription Id.",
            "type": "string"
          },
          "tags": {
            "description": "Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.",
            "type": "string"
          },
          "tenant": {
            "description": "Azure tenant ID. Use when authenticating with a Service Principal.",
            "type": "string"
          }
        }
      }
    },
    {
      "azure_rm_securitygroup": {
        "type": "object",
        "description": "Manage Azure network security groups.",
        "properties": {
          "ad_user": {
            "description": "Active Directory username. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "append_tags": {
            "description": "Use to control if tags field is canonical or just appends to existing tags. When canonical, any tags not found in the tags parameter will be removed from the object's metadata.",
            "type": "string"
          },
          "client_id": {
            "description": "Azure client ID. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "default_rules": {
            "description": "The set of default rules automatically added to a security group at creation. In general default rules will not be modified. Modify rules to shape the flow of traffic to or from a subnet or NIC. See rules below for the makeup of a rule dict.",
            "type": "string"
          },
          "location": {
            "description": "Valid azure location. Defaults to location of the resource group.",
            "type": "string"
          },
          "name": {
            "description": "Name of the security group to operate on.",
            "type": "string"
          },
          "password": {
            "description": "Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "profile": {
            "description": "Security profile found in ~/.azure/credentials file.",
            "type": "string"
          },
          "purge_default_rules": {
            "description": "Remove any existing rules not matching those defined in the default_rules parameter.",
            "type": "string"
          },
          "purge_rules": {
            "description": "Remove any existing rules not matching those defined in the rules parameters.",
            "type": "string"
          },
          "resource_group": {
            "description": "Name of the resource group the security group belongs to.",
            "type": "string"
          },
          "rules": {
            "description": "Set of rules shaping traffic flow to or from a subnet or NIC. Each rule is a dictionary.",
            "type": "string"
          },
          "secret": {
            "description": "Azure client secret. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "state": {
            "description": "Assert the state of the security group. Set to 'present' to create or update a security group. Set to 'absent' to remove a security group.",
            "type": "string"
          },
          "subscription_id": {
            "description": "Your Azure subscription Id.",
            "type": "string"
          },
          "tags": {
            "description": "Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.",
            "type": "string"
          },
          "tenant": {
            "description": "Azure tenant ID. Use when authenticating with a Service Principal.",
            "type": "string"
          }
        },
        "required": "resource_group"
      }
    },
    {
      "azure_rm_securitygroup_facts": {
        "type": "object",
        "description": "Get security group facts.",
        "properties": {
          "ad_user": {
            "description": "Active Directory username. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "client_id": {
            "description": "Azure client ID. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "name": {
            "description": "Only show results for a specific security group.",
            "type": "string"
          },
          "password": {
            "description": "Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "profile": {
            "description": "Security profile found in ~/.azure/credentials file.",
            "type": "string"
          },
          "resource_group": {
            "description": "Name of the resource group to use.",
            "type": "string"
          },
          "secret": {
            "description": "Azure client secret. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "subscription_id": {
            "description": "Your Azure subscription Id.",
            "type": "string"
          },
          "tags": {
            "description": "Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.",
            "type": "string"
          },
          "tenant": {
            "description": "Azure tenant ID. Use when authenticating with a Service Principal.",
            "type": "string"
          }
        },
        "required": "resource_group"
      }
    },
    {
      "azure_rm_storageaccount": {
        "type": "object",
        "description": "Manage Azure storage accounts.",
        "properties": {
          "account_type": {
            "description": "Type of storage account. Required when creating a storage account. NOTE: Standard_ZRS and Premium_LRS accounts cannot be changed to other account types, and other account types cannot be changed to Standard_ZRS or Premium_LRS.",
            "type": "string"
          },
          "ad_user": {
            "description": "Active Directory username. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "append_tags": {
            "description": "Use to control if tags field is canonical or just appends to existing tags. When canonical, any tags not found in the tags parameter will be removed from the object's metadata.",
            "type": "string"
          },
          "client_id": {
            "description": "Azure client ID. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "custom_domain": {
            "description": "User domain assigned to the storage account. Must be a dictionary with 'name' and 'use_sub_domain' keys where 'name' is the CNAME source. Only one custom domain is supported per storage account at this time. To clear the existing custom domain, use an empty string for the custom domain name property. Can be added to an existing storage account. Will be ignored during storage account creation.",
            "type": "string"
          },
          "kind": {
            "description": "The 'kind' of storage.",
            "type": "string"
          },
          "location": {
            "description": "Valid azure location. Defaults to location of the resource group.",
            "type": "string"
          },
          "name": {
            "description": "Name of the storage account to update or create.",
            "type": "string"
          },
          "password": {
            "description": "Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "profile": {
            "description": "Security profile found in ~/.azure/credentials file.",
            "type": "string"
          },
          "resource_group": {
            "description": "Name of the resource group to use.",
            "type": "string"
          },
          "secret": {
            "description": "Azure client secret. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "state": {
            "description": "Assert the state of the storage account. Use 'present' to create or update a storage account and 'absent' to delete an account.",
            "type": "string"
          },
          "subscription_id": {
            "description": "Your Azure subscription Id.",
            "type": "string"
          },
          "tags": {
            "description": "Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.",
            "type": "string"
          },
          "tenant": {
            "description": "Azure tenant ID. Use when authenticating with a Service Principal.",
            "type": "string"
          }
        },
        "required": "resource_group"
      }
    },
    {
      "azure_rm_storageaccount_facts": {
        "type": "object",
        "description": "Get storage account facts.",
        "properties": {
          "ad_user": {
            "description": "Active Directory username. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "client_id": {
            "description": "Azure client ID. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "name": {
            "description": "Only show results for a specific account.",
            "type": "string"
          },
          "password": {
            "description": "Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "profile": {
            "description": "Security profile found in ~/.azure/credentials file.",
            "type": "string"
          },
          "resource_group": {
            "description": "Limit results to a resource group. Required when filtering by name.",
            "type": "string"
          },
          "secret": {
            "description": "Azure client secret. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "subscription_id": {
            "description": "Your Azure subscription Id.",
            "type": "string"
          },
          "tags": {
            "description": "Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.",
            "type": "string"
          },
          "tenant": {
            "description": "Azure tenant ID. Use when authenticating with a Service Principal.",
            "type": "string"
          }
        }
      }
    },
    {
      "azure_rm_storageblob": {
        "type": "object",
        "description": "Manage blob containers and blob objects.",
        "properties": {
          "ad_user": {
            "description": "Active Directory username. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "append_tags": {
            "description": "Use to control if tags field is canonical or just appends to existing tags. When canonical, any tags not found in the tags parameter will be removed from the object's metadata.",
            "type": "string"
          },
          "blob": {
            "description": "Name of a blob object within the container.",
            "type": "string"
          },
          "cache_control": {
            "description": "Set the blob cache-control header.",
            "type": "string"
          },
          "client_id": {
            "description": "Azure client ID. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "container": {
            "description": "Name of a blob container within the storage account.",
            "type": "string"
          },
          "content_disposition": {
            "description": "Set the blob content-disposition header.",
            "type": "string"
          },
          "content_encoding": {
            "description": "Set the blob encoding header.",
            "type": "string"
          },
          "content_language": {
            "description": "Set the blob content-language header.",
            "type": "string"
          },
          "content_md5": {
            "description": "Set the blob md5 hash value.",
            "type": "string"
          },
          "content_type": {
            "description": "Set the blob content-type header. For example, 'image/png'.",
            "type": "string"
          },
          "dest": {
            "description": "Destination file path. Use with state 'present' to download a blob.",
            "type": "string"
          },
          "force": {
            "description": "Overwrite existing blob or file when uploading or downloading. Force deletion of a container that contains blobs.",
            "type": "string"
          },
          "password": {
            "description": "Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "profile": {
            "description": "Security profile found in ~/.azure/credentials file.",
            "type": "string"
          },
          "public_access": {
            "description": "Determine a container's level of public access. By default containers are private. Can only be set at time of container creation.",
            "type": "string"
          },
          "resource_group": {
            "description": "Name of the resource group to use.",
            "type": "string"
          },
          "secret": {
            "description": "Azure client secret. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "src": {
            "description": "Source file path. Use with state 'present' to upload a blob.",
            "type": "string"
          },
          "state": {
            "description": "Assert the state of a container or blob. Use state 'absent' with a container value only to delete a container. Include a blob value to remove a specific blob. A container will not be deleted, if it contains blobs. Use the force option to override, deleting the container and all associated blobs. Use state 'present' to create or update a container and upload or download a blob. If the container does not exist, it will be created. If it exists, it will be updated with configuration options. Provide a blob name and either src or dest to upload or download. Provide a src path to upload and a dest path to download. If a blob (uploading) or a file (downloading) already exists, it will not be overwritten unless the force parameter is true.",
            "type": "string"
          },
          "storage_account_name": {
            "description": "Name of the storage account to use.",
            "type": "string"
          },
          "subscription_id": {
            "description": "Your Azure subscription Id.",
            "type": "string"
          },
          "tags": {
            "description": "Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.",
            "type": "string"
          },
          "tenant": {
            "description": "Azure tenant ID. Use when authenticating with a Service Principal.",
            "type": "string"
          }
        },
        "required": [
          "container",
          "resource_group",
          "storage_account_name"
        ]
      }
    },
    {
      "azure_rm_subnet": {
        "type": "object",
        "description": "Manage Azure subnets.",
        "properties": {
          "ad_user": {
            "description": "Active Directory username. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "address_prefix_cidr": {
            "description": "CIDR defining the IPv4 address space of the subnet. Must be valid within the context of the virtual network.",
            "type": "string"
          },
          "client_id": {
            "description": "Azure client ID. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "name": {
            "description": "Name of the subnet.",
            "type": "string"
          },
          "password": {
            "description": "Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "profile": {
            "description": "Security profile found in ~/.azure/credentials file.",
            "type": "string"
          },
          "resource_group": {
            "description": "Name of resource group.",
            "type": "string"
          },
          "secret": {
            "description": "Azure client secret. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "security_group_name": {
            "description": "Name of an existing security group with which to associate the subnet.",
            "type": "string"
          },
          "state": {
            "description": "Assert the state of the subnet. Use 'present' to create or update a subnet and 'absent' to delete a subnet.",
            "type": "string"
          },
          "subscription_id": {
            "description": "Your Azure subscription Id.",
            "type": "string"
          },
          "tenant": {
            "description": "Azure tenant ID. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "virtual_network_name": {
            "description": "Name of an existing virtual network with which the subnet is or will be associated.",
            "type": "string"
          }
        },
        "required": [
          "address_prefix_cidr",
          "name",
          "resource_group",
          "state",
          "virtual_network_name"
        ]
      }
    },
    {
      "azure_rm_virtualmachine": {
        "type": "object",
        "description": "Manage Azure virtual machines.",
        "properties": {
          "ad_user": {
            "description": "Active Directory username. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "admin_password": {
            "description": "Password for the admin username. Not required if the os_type is Linux and SSH password authentication is disabled by setting ssh_passw ord_enabled to false.",
            "type": "string"
          },
          "admin_username": {
            "description": "Admin username used to access the host after it is created. Required when creating a VM.",
            "type": "string"
          },
          "allocated": {
            "description": "Toggle that controls if the machine is allocated/dealloc ated, only useful with state='present'.",
            "type": "string"
          },
          "append_tags": {
            "description": "Use to control if tags field is canonical or just appends to existing tags. When canonical, any tags not found in the tags parameter will be removed from the object's metadata.",
            "type": "string"
          },
          "client_id": {
            "description": "Azure client ID. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "image": {
            "description": "A dictionary describing the Marketplace image used to build the VM. Will contain keys: publisher, offer, sku and version. NOTE: set image.version to 'latest' to get the most recent version of a given image.",
            "type": "string"
          },
          "location": {
            "description": "Valid Azure location. Defaults to location of the resource group.",
            "type": "string"
          },
          "name": {
            "description": "Name of the virtual machine.",
            "type": "string"
          },
          "network_interface_names": {
            "description": "List of existing network interface names to add to the VM. If a network interface name is not provided when the VM is created, a default network interface will be created. In order for the module to create a network interface, at least one Virtual Network with one Subnet must exist.",
            "type": "string"
          },
          "open_ports": {
            "description": "If a network interface is created when creating the VM, a security group will be created as well. For Linux hosts a rule will be added to the security group allowing inbound TCP connections to the default SSH port 22, and for Windows hosts ports 3389 and 5986 will be opened. Override the default open ports by providing a list of ports.",
            "type": "string"
          },
          "os_disk_caching": {
            "description": "Type of OS disk caching.",
            "type": "string"
          },
          "os_type": {
            "description": "Base type of operating system.",
            "type": "string"
          },
          "password": {
            "description": "Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "profile": {
            "description": "Security profile found in ~/.azure/credentials file.",
            "type": "string"
          },
          "public_ip_allocation_method": {
            "description": "If a public IP address is created when creating the VM (because a Network Interface was not provided), determines if the public IP address remains permanently associated with the Network Interface. If set to 'Dynamic' the public IP address may change any time the VM is rebooted or power cycled.",
            "type": "string"
          },
          "remove_on_absent": {
            "description": "When removing a VM using state 'absent', also remove associated resources It can be 'all' or a list with any of the following: [' network_interface s', 'virtual_stor age', 'public_ips'] Any other input will be ignored",
            "type": "string"
          },
          "resource_group": {
            "description": "Name of the resource group containing the virtual machine.",
            "type": "string"
          },
          "restarted": {
            "description": "Use with state 'present' to restart a running VM.",
            "type": "string"
          },
          "secret": {
            "description": "Azure client secret. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "short_hostname": {
            "description": "Name assigned internally to the host. On a linux VM this is the name returned by the `hostname` command. When creating a virtual machine, short_hostname defaults to name.",
            "type": "string"
          },
          "ssh_password_enabled": {
            "description": "When the os_type is Linux, setting ssh_password_enab led to false will disable SSH password authentication and require use of SSH keys.",
            "type": "string"
          },
          "ssh_public_keys": {
            "description": "For os_type Linux provide a list of SSH keys. Each item in the list should be a dictionary where the dictionary contains two keys: path and key_data. Set the path to the default location of the authorized_keys files. On an Enterprise Linux host, for example, the path will be /home/<admin user name>/.ssh/author ized_keys. Set key_data to the actual value of the public key.",
            "type": "string"
          },
          "started": {
            "description": "Use with state 'present' to start the machine. Set to false to have the machine be 'stopped'.",
            "type": "string"
          },
          "state": {
            "description": "Assert the state of the virtual machine. State 'present' will check that the machine exists with the requested configuration. If the configuration of the existing machine does not match, the machine will be updated. Use options started, allocated and restarted to change the machine's power state. State 'absent' will remove the virtual machine.",
            "type": "string"
          },
          "storage_account_name": {
            "description": "Name of an existing storage account that supports creation of VHD blobs. If not specified for a new VM, a new storage account named <vm name>01 will be created using storage type 'Standard_LRS'.",
            "type": "string"
          },
          "storage_blob_name": {
            "description": "Name fo the storage blob used to hold the VM's OS disk image. If no name is provided, defaults to the VM name + '.vhd'. If you provide a name, it must end with '.vhd'",
            "type": "string"
          },
          "storage_container_name": {
            "description": "Name of the container to use within the storage account to store VHD blobs. If no name is specified a default container will created.",
            "type": "string"
          },
          "subnet_name": {
            "description": "When creating a virtual machine, if a network interface name is not provided, one will be created. The new network interface will be assigned to the first subnet found in the virtual network. Use this parameter to provide a specific subnet instead.",
            "type": "string"
          },
          "subscription_id": {
            "description": "Your Azure subscription Id.",
            "type": "string"
          },
          "tags": {
            "description": "Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.",
            "type": "string"
          },
          "tenant": {
            "description": "Azure tenant ID. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "virtual_network_name": {
            "description": "When creating a virtual machine, if a network interface name is not provided, one will be created. The new network interface will be assigned to the first virtual network found in the resource group. Use this parameter to provide a specific virtual network instead.",
            "type": "string"
          },
          "vm_size": {
            "description": "A valid Azure VM size value. For example, 'Standard_D4'. The list of choices varies depending on the subscription and location. Check your subscription for available choices.",
            "type": "string"
          }
        },
        "required": [
          "image",
          "name",
          "resource_group"
        ]
      }
    },
    {
      "azure_rm_virtualmachineimage_facts": {
        "type": "object",
        "description": "Get virtual machine image facts.",
        "properties": {
          "ad_user": {
            "description": "Active Directory username. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "client_id": {
            "description": "Azure client ID. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "location": {
            "description": "Azure location value (ie. westus, eastus, eastus2, northcentralus, etc.). Supplying only a location value will yield a list of available publishers for the location.",
            "type": "string"
          },
          "name": {
            "description": "Only show results for a specific security group.",
            "type": "string"
          },
          "offer": {
            "description": "Name of an image offering. Combine with sku to see a list of available image versions.",
            "type": "string"
          },
          "password": {
            "description": "Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "profile": {
            "description": "Security profile found in ~/.azure/credentials file.",
            "type": "string"
          },
          "publisher": {
            "description": "Name of an image publisher. List image offerings associated with a particular publisher.",
            "type": "string"
          },
          "secret": {
            "description": "Azure client secret. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "sku": {
            "description": "Image offering SKU. Combine with offer to see a list of available versions.",
            "type": "string"
          },
          "subscription_id": {
            "description": "Your Azure subscription Id.",
            "type": "string"
          },
          "tenant": {
            "description": "Azure tenant ID. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "version": {
            "description": "Specific version number of an image.",
            "type": "string"
          }
        },
        "required": "location"
      }
    },
    {
      "azure_rm_virtualnetwork": {
        "type": "object",
        "description": "Manage Azure virtual networks.",
        "properties": {
          "ad_user": {
            "description": "Active Directory username. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "address_prefixes_cidr": {
            "description": "List of IPv4 address ranges where each is formatted using CIDR notation. Required when creating a new virtual network or using purge_ad dress_prefixes.",
            "type": "string"
          },
          "append_tags": {
            "description": "Use to control if tags field is canonical or just appends to existing tags. When canonical, any tags not found in the tags parameter will be removed from the object's metadata.",
            "type": "string"
          },
          "client_id": {
            "description": "Azure client ID. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "dns_servers": {
            "description": "Custom list of DNS servers. Maximum length of two. The first server in the list will be treated as the Primary server. This is an explicit list. Existing DNS servers will be replaced with the specified list. Use the purge_dns_servers option to remove all custom DNS servers and revert to default Azure servers.",
            "type": "string"
          },
          "location": {
            "description": "Valid azure location. Defaults to location of the resource group.",
            "type": "string"
          },
          "name": {
            "description": "name of the virtual network.",
            "type": "string"
          },
          "password": {
            "description": "Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "profile": {
            "description": "Security profile found in ~/.azure/credentials file.",
            "type": "string"
          },
          "purge_address_prefixes": {
            "description": "Use with state present to remove any existing address_prefixes.",
            "type": "string"
          },
          "purge_dns_servers": {
            "description": "Use with state present to remove existing DNS servers, reverting to default Azure servers. Mutually exclusive with dns_servers.",
            "type": "string"
          },
          "resource_group": {
            "description": "name of resource group.",
            "type": "string"
          },
          "secret": {
            "description": "Azure client secret. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "state": {
            "description": "Assert the state of the virtual network. Use 'present' to create or update and 'absent' to delete.",
            "type": "string"
          },
          "subscription_id": {
            "description": "Your Azure subscription Id.",
            "type": "string"
          },
          "tags": {
            "description": "Dictionary of string:string pairs to assign as metadata to the object. Metadata tags on the object will be updated with any provided values. To remove tags set append_tags option to false.",
            "type": "string"
          },
          "tenant": {
            "description": "Azure tenant ID. Use when authenticating with a Service Principal.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "resource_group"
        ]
      }
    },
    {
      "azure_rm_virtualnetwork_facts": {
        "type": "object",
        "description": "Get virtual network facts.",
        "properties": {
          "ad_user": {
            "description": "Active Directory username. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "client_id": {
            "description": "Azure client ID. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "name": {
            "description": "Only show results for a specific security group.",
            "type": "string"
          },
          "password": {
            "description": "Active Directory user password. Use when authenticating with an Active Directory user rather than service principal.",
            "type": "string"
          },
          "profile": {
            "description": "Security profile found in ~/.azure/credentials file.",
            "type": "string"
          },
          "resource_group": {
            "description": "Limit results by resource group. Required when filtering by name.",
            "type": "string"
          },
          "secret": {
            "description": "Azure client secret. Use when authenticating with a Service Principal.",
            "type": "string"
          },
          "subscription_id": {
            "description": "Your Azure subscription Id.",
            "type": "string"
          },
          "tags": {
            "description": "Limit results by providing a list of tags. Format tags as 'key' or 'key:value'.",
            "type": "string"
          },
          "tenant": {
            "description": "Azure tenant ID. Use when authenticating with a Service Principal.",
            "type": "string"
          }
        }
      }
    },
    {
      "bigip_device_dns": {
        "type": "object",
        "description": "Manage BIG-IP device DNS settings",
        "properties": {
          "cache": {
            "description": "Specifies whether the system caches DNS lookups or performs the operation each time a lookup is needed. Please note that this applies only to Access Policy Manager features, such as ACLs, web application rewrites, and authentication.",
            "type": "string"
          },
          "forwarders": {
            "description": "A list of BIND servers that the system can use to perform DNS lookups",
            "type": "string"
          },
          "ip_version": {
            "description": "Specifies whether the DNS specifies IP addresses using IPv4 or IPv6.",
            "type": "string"
          },
          "name_servers": {
            "description": "A list of name serverz that the system uses to validate DNS lookups",
            "type": "string"
          },
          "password": {
            "description": "The password for the user account used to connect to the BIG-IP.",
            "type": "string"
          },
          "search": {
            "description": "A list of domains that the system searches for local domain lookups, to resolve local host names.",
            "type": "string"
          },
          "server": {
            "description": "The BIG-IP host.",
            "type": "string"
          },
          "server_port": {
            "description": "The BIG-IP server port.",
            "type": "string"
          },
          "state": {
            "description": "The state of the variable on the system. When `present', guarantees that an existing variable is set to `value'.",
            "type": "string"
          },
          "user": {
            "description": "The username to connect to the BIG-IP with. This user must have administrative privileges on the device.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": [
          "password",
          "server",
          "user"
        ]
      }
    },
    {
      "bigip_device_ntp": {
        "type": "object",
        "description": "Manage NTP servers on a BIG-IP",
        "properties": {
          "ntp_servers": {
            "description": "A list of NTP servers to set on the device. At least one of `ntp_servers' or `timezone' is required.",
            "type": "string"
          },
          "password": {
            "description": "The password for the user account used to connect to the BIG-IP.",
            "type": "string"
          },
          "server": {
            "description": "The BIG-IP host.",
            "type": "string"
          },
          "server_port": {
            "description": "The BIG-IP server port.",
            "type": "string"
          },
          "state": {
            "description": "The state of the NTP servers on the system. When `present', guarantees that the NTP servers are set on the system. When `absent', removes the specified NTP servers from the device configuration.",
            "type": "string"
          },
          "timezone": {
            "description": "The timezone to set for NTP lookups. At least one of `ntp_servers' or `timezone' is required.",
            "type": "string"
          },
          "user": {
            "description": "The username to connect to the BIG-IP with. This user must have administrative privileges on the device.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": [
          "password",
          "server",
          "user"
        ]
      }
    },
    {
      "bigip_device_sshd": {
        "type": "object",
        "description": "Manage the SSHD settings of a BIG-IP",
        "properties": {
          "allow": {
            "description": "Specifies, if you have enabled SSH access, the IP address or address range for other systems that can use SSH to communicate with this system.",
            "type": "string"
          },
          "banner": {
            "description": "Whether to enable the banner or not.",
            "type": "string"
          },
          "banner_text": {
            "description": "Specifies the text to include on the pre-login banner that displays when a user attempts to login to the system using SSH.",
            "type": "string"
          },
          "inactivity_timeout": {
            "description": "Specifies the number of seconds before inactivity causes an SSH session to log out.",
            "type": "string"
          },
          "log_level": {
            "description": "Specifies the minimum SSHD message level to include in the system log.",
            "type": "string"
          },
          "login": {
            "description": "Specifies, when checked `enabled', that the system accepts SSH communications.",
            "type": "string"
          },
          "password": {
            "description": "The password for the user account used to connect to the BIG-IP.",
            "type": "string"
          },
          "port": {
            "description": "Port that you want the SSH daemon to run on.",
            "type": "string"
          },
          "server": {
            "description": "The BIG-IP host.",
            "type": "string"
          },
          "server_port": {
            "description": "The BIG-IP server port.",
            "type": "string"
          },
          "user": {
            "description": "The username to connect to the BIG-IP with. This user must have administrative privileges on the device.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": [
          "password",
          "server",
          "user"
        ]
      }
    },
    {
      "bigip_facts": {
        "type": "object",
        "description": "Collect facts from F5 BIG-IP devices",
        "properties": {
          "filter": {
            "description": "Shell-style glob matching string used to filter fact keys. Not applicable for software, provision, and system_info fact categories.",
            "type": "string"
          },
          "include": {
            "description": "Fact category or list of categories to collect",
            "type": "string"
          },
          "password": {
            "description": "The password for the user account used to connect to the BIG-IP.",
            "type": "string"
          },
          "server": {
            "description": "The BIG-IP host.",
            "type": "string"
          },
          "server_port": {
            "description": "The BIG-IP server port.",
            "type": "string"
          },
          "session": {
            "description": "BIG-IP session support; may be useful to avoid concurrency issues in certain circumstances.",
            "type": "string"
          },
          "user": {
            "description": "The username to connect to the BIG-IP with. This user must have administrative privileges on the device.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": [
          "include",
          "password",
          "server",
          "user"
        ]
      }
    },
    {
      "bigip_gtm_datacenter": {
        "type": "object",
        "description": "Manage Datacenter configuration in BIG-IP",
        "properties": {
          "contact": {
            "description": "The name of the contact for the data center.",
            "type": "string"
          },
          "description": {
            "description": "The description of the data center.",
            "type": "string"
          },
          "enabled": {
            "description": "Whether the data center should be enabled. At least one of `state' and `enabled' are required.",
            "type": "string"
          },
          "location": {
            "description": "The location of the data center.",
            "type": "string"
          },
          "name": {
            "description": "The name of the data center.",
            "type": "string"
          },
          "password": {
            "description": "The password for the user account used to connect to the BIG-IP.",
            "type": "string"
          },
          "server": {
            "description": "The BIG-IP host.",
            "type": "string"
          },
          "server_port": {
            "description": "The BIG-IP server port.",
            "type": "string"
          },
          "state": {
            "description": "The state of the datacenter on the BIG-IP. When `present', guarantees that the data center exists. When `absent' removes the data center from the BIG-IP. `enabled' will enable the data center and `disabled' will ensure the data center is disabled. At least one of state and enabled are required.",
            "type": "string"
          },
          "user": {
            "description": "The username to connect to the BIG-IP with. This user must have administrative privileges on the device.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "password",
          "server",
          "user"
        ]
      }
    },
    {
      "bigip_gtm_virtual_server": {
        "type": "object",
        "description": "Manages F5 BIG-IP GTM virtual servers",
        "properties": {
          "host": {
            "description": "Virtual server host",
            "type": "string"
          },
          "password": {
            "description": "The password for the user account used to connect to the BIG-IP.",
            "type": "string"
          },
          "port": {
            "description": "Virtual server port",
            "type": "string"
          },
          "server": {
            "description": "The BIG-IP host.",
            "type": "string"
          },
          "server_port": {
            "description": "The BIG-IP server port.",
            "type": "string"
          },
          "state": {
            "description": "Virtual server state",
            "type": "string"
          },
          "user": {
            "description": "The username to connect to the BIG-IP with. This user must have administrative privileges on the device.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          },
          "virtual_server_name": {
            "description": "Virtual server name",
            "type": "string"
          },
          "virtual_server_server": {
            "description": "Virtual server server",
            "type": "string"
          }
        },
        "required": [
          "password",
          "server",
          "user",
          "virtual_server_name",
          "virtual_server_server"
        ]
      }
    },
    {
      "bigip_gtm_wide_ip": {
        "type": "object",
        "description": "Manages F5 BIG-IP GTM wide ip",
        "properties": {
          "lb_method": {
            "description": "LB method of wide ip",
            "type": "string"
          },
          "password": {
            "description": "The password for the user account used to connect to the BIG-IP.",
            "type": "string"
          },
          "server": {
            "description": "The BIG-IP host.",
            "type": "string"
          },
          "server_port": {
            "description": "The BIG-IP server port.",
            "type": "string"
          },
          "user": {
            "description": "The username to connect to the BIG-IP with. This user must have administrative privileges on the device.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          },
          "wide_ip": {
            "description": "Wide IP name",
            "type": "string"
          }
        },
        "required": [
          "lb_method",
          "password",
          "server",
          "user",
          "wide_ip"
        ]
      }
    },
    {
      "bigip_irule": {
        "type": "object",
        "description": "Manage iRules across different modules on a BIG-IP.",
        "properties": {
          "content": {
            "description": "When used instead of 'src', sets the contents of an iRule directly to the specified value. This is for simple values, but can be used with lookup plugins for anything complex or with formatting. Either one of `src' or `content' must be provided.",
            "type": "string"
          },
          "module": {
            "description": "The BIG-IP module to add the iRule to.",
            "type": "string"
          },
          "name": {
            "description": "The name of the iRule.",
            "type": "string"
          },
          "partition": {
            "description": "The partition to create the iRule on.",
            "type": "string"
          },
          "password": {
            "description": "The password for the user account used to connect to the BIG-IP.",
            "type": "string"
          },
          "server": {
            "description": "The BIG-IP host.",
            "type": "string"
          },
          "server_port": {
            "description": "The BIG-IP server port.",
            "type": "string"
          },
          "src": {
            "description": "The iRule file to interpret and upload to the BIG-IP. Either one of `src' or `content' must be provided.",
            "type": "string"
          },
          "state": {
            "description": "Whether the iRule should exist or not.",
            "type": "string"
          },
          "user": {
            "description": "The username to connect to the BIG-IP with. This user must have administrative privileges on the device.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": [
          "module",
          "name",
          "password",
          "server",
          "src",
          "user"
        ]
      }
    },
    {
      "bigip_monitor_http": {
        "type": "object",
        "description": "Manages F5 BIG-IP LTM http monitors",
        "properties": {
          "interval": {
            "description": "The interval specifying how frequently the monitor instance of this template will run. By default, this interval is used for up and down states. The default API setting is 5.",
            "type": "string"
          },
          "ip": {
            "description": "IP address part of the ipport definition. The default API setting is \"0.0.0.0\".",
            "type": "string"
          },
          "name": {
            "description": "Monitor name",
            "type": "string"
          },
          "parent": {
            "description": "The parent template of this monitor template",
            "type": "string"
          },
          "parent_partition": {
            "description": "Partition for the parent monitor",
            "type": "string"
          },
          "partition": {
            "description": "Partition for the monitor",
            "type": "string"
          },
          "password": {
            "description": "The password for the user account used to connect to the BIG-IP.",
            "type": "string"
          },
          "port": {
            "description": "Port address part of the ip/port definition. The default API setting is 0.",
            "type": "string"
          },
          "receive": {
            "description": "The receive string for the monitor call",
            "type": "string"
          },
          "receive_disable": {
            "description": "The receive disable string for the monitor call",
            "type": "string"
          },
          "send": {
            "description": "The send string for the monitor call",
            "type": "string"
          },
          "server": {
            "description": "The BIG-IP host.",
            "type": "string"
          },
          "server_port": {
            "description": "The BIG-IP server port.",
            "type": "string"
          },
          "state": {
            "description": "Monitor state",
            "type": "string"
          },
          "time_until_up": {
            "description": "Specifies the amount of time in seconds after the first successful response before a node will be marked up. A value of 0 will cause a node to be marked up immediately after a valid response is received from the node. The default API setting is 0.",
            "type": "string"
          },
          "timeout": {
            "description": "The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second. The default API setting is 16.",
            "type": "string"
          },
          "user": {
            "description": "The username to connect to the BIG-IP with. This user must have administrative privileges on the device.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "password",
          "receive",
          "receive_disable",
          "send",
          "server",
          "user"
        ]
      }
    },
    {
      "bigip_monitor_tcp": {
        "type": "object",
        "description": "Manages F5 BIG-IP LTM tcp monitors",
        "properties": {
          "interval": {
            "description": "The interval specifying how frequently the monitor instance of this template will run. By default, this interval is used for up and down states. The default API setting is 5.",
            "type": "string"
          },
          "ip": {
            "description": "IP address part of the ipport definition. The default API setting is \"0.0.0.0\".",
            "type": "string"
          },
          "name": {
            "description": "Monitor name",
            "type": "string"
          },
          "parent": {
            "description": "The parent template of this monitor template",
            "type": "string"
          },
          "parent_partition": {
            "description": "Partition for the parent monitor",
            "type": "string"
          },
          "partition": {
            "description": "Partition for the monitor",
            "type": "string"
          },
          "password": {
            "description": "The password for the user account used to connect to the BIG-IP.",
            "type": "string"
          },
          "port": {
            "description": "Port address part op the ipport definition. The default API setting is 0.",
            "type": "string"
          },
          "receive": {
            "description": "The receive string for the monitor call",
            "type": "string"
          },
          "send": {
            "description": "The send string for the monitor call",
            "type": "string"
          },
          "server": {
            "description": "The BIG-IP host.",
            "type": "string"
          },
          "server_port": {
            "description": "The BIG-IP server port.",
            "type": "string"
          },
          "state": {
            "description": "Monitor state",
            "type": "string"
          },
          "time_until_up": {
            "description": "Specifies the amount of time in seconds after the first successful response before a node will be marked up. A value of 0 will cause a node to be marked up immediately after a valid response is received from the node. The default API setting is 0.",
            "type": "string"
          },
          "timeout": {
            "description": "The number of seconds in which the node or service must respond to the monitor request. If the target responds within the set time period, it is considered up. If the target does not respond within the set time period, it is considered down. You can change this number to any number you want, however, it should be 3 times the interval number of seconds plus 1 second. The default API setting is 16.",
            "type": "string"
          },
          "type": {
            "description": "The template type of this monitor template",
            "type": "string"
          },
          "user": {
            "description": "The username to connect to the BIG-IP with. This user must have administrative privileges on the device.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "password",
          "receive",
          "send",
          "server",
          "user"
        ]
      }
    },
    {
      "bigip_node": {
        "type": "object",
        "description": "Manages F5 BIG-IP LTM nodes",
        "properties": {
          "description": {
            "description": "Node description.",
            "type": "string"
          },
          "host": {
            "description": "Node IP. Required when state=present and node does not exist. Error when state=absent.",
            "type": "string"
          },
          "monitor_state": {
            "description": "Set monitor availability status for node",
            "type": "string"
          },
          "monitor_type": {
            "description": "Monitor rule type when monitors > 1",
            "type": "string"
          },
          "monitors": {
            "description": "Monitor template name list. Always use the full path to the monitor.",
            "type": "string"
          },
          "name": {
            "description": "Node name",
            "type": "string"
          },
          "partition": {
            "description": "Partition",
            "type": "string"
          },
          "password": {
            "description": "The password for the user account used to connect to the BIG-IP.",
            "type": "string"
          },
          "quorum": {
            "description": "Monitor quorum value when monitor_type is m_of_n",
            "type": "string"
          },
          "server": {
            "description": "The BIG-IP host.",
            "type": "string"
          },
          "server_port": {
            "description": "The BIG-IP server port.",
            "type": "string"
          },
          "session_state": {
            "description": "Set new session availability status for node",
            "type": "string"
          },
          "state": {
            "description": "Pool member state",
            "type": "string"
          },
          "user": {
            "description": "The username to connect to the BIG-IP with. This user must have administrative privileges on the device.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "password",
          "server",
          "state",
          "user"
        ]
      }
    },
    {
      "bigip_pool": {
        "type": "object",
        "description": "Manages F5 BIG-IP LTM pools",
        "properties": {
          "host": {
            "description": "Pool member IP",
            "type": "string"
          },
          "lb_method": {
            "description": "Load balancing method",
            "type": "string"
          },
          "monitor_type": {
            "description": "Monitor rule type when monitors > 1",
            "type": "string"
          },
          "monitors": {
            "description": "Monitor template name list. Always use the full path to the monitor.",
            "type": "string"
          },
          "name": {
            "description": "Pool name",
            "type": "string"
          },
          "partition": {
            "description": "Partition of pool/pool member",
            "type": "string"
          },
          "password": {
            "description": "The password for the user account used to connect to the BIG-IP.",
            "type": "string"
          },
          "port": {
            "description": "Pool member port",
            "type": "string"
          },
          "quorum": {
            "description": "Monitor quorum value when monitor_type is m_of_n",
            "type": "string"
          },
          "reselect_tries": {
            "description": "Sets the number of times the system tries to contact a pool member after a passive failure",
            "type": "string"
          },
          "server": {
            "description": "The BIG-IP host.",
            "type": "string"
          },
          "server_port": {
            "description": "The BIG-IP server port.",
            "type": "string"
          },
          "service_down_action": {
            "description": "Sets the action to take when node goes down in pool",
            "type": "string"
          },
          "slow_ramp_time": {
            "description": "Sets the ramp-up time (in seconds) to gradually ramp up the load on newly added or freshly detected up pool members",
            "type": "string"
          },
          "state": {
            "description": "Pool/pool member state",
            "type": "string"
          },
          "user": {
            "description": "The username to connect to the BIG-IP with. This user must have administrative privileges on the device.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "password",
          "server",
          "user"
        ]
      }
    },
    {
      "bigip_pool_member": {
        "type": "object",
        "description": "Manages F5 BIG-IP LTM pool members",
        "properties": {
          "connection_limit": {
            "description": "Pool member connection limit. Setting this to 0 disables the limit.",
            "type": "string"
          },
          "description": {
            "description": "Pool member description",
            "type": "string"
          },
          "host": {
            "description": "Pool member IP",
            "type": "string"
          },
          "monitor_state": {
            "description": "Set monitor availability status for pool member",
            "type": "string"
          },
          "partition": {
            "description": "Partition",
            "type": "string"
          },
          "password": {
            "description": "The password for the user account used to connect to the BIG-IP.",
            "type": "string"
          },
          "pool": {
            "description": "Pool name. This pool must exist.",
            "type": "string"
          },
          "port": {
            "description": "Pool member port",
            "type": "string"
          },
          "preserve_node": {
            "description": "When state is absent and the pool member is no longer referenced in other pools, the default behavior removes the unused node o bject. Setting this to 'yes' disables this behavior.",
            "type": "string"
          },
          "rate_limit": {
            "description": "Pool member rate limit (connections-per-second). Setting this to 0 disables the limit.",
            "type": "string"
          },
          "ratio": {
            "description": "Pool member ratio weight. Valid values range from 1 through 100. New pool members -- unless overriden with this value -- default to 1.",
            "type": "string"
          },
          "server": {
            "description": "The BIG-IP host.",
            "type": "string"
          },
          "server_port": {
            "description": "The BIG-IP server port.",
            "type": "string"
          },
          "session_state": {
            "description": "Set new session availability status for pool member",
            "type": "string"
          },
          "state": {
            "description": "Pool member state",
            "type": "string"
          },
          "user": {
            "description": "The username to connect to the BIG-IP with. This user must have administrative privileges on the device.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "password",
          "pool",
          "port",
          "server",
          "state",
          "user"
        ]
      }
    },
    {
      "bigip_routedomain": {
        "type": "object",
        "description": "Manage route domains on a BIG-IP",
        "properties": {
          "bwc_policy": {
            "description": "The bandwidth controller for the route domain.",
            "type": "string"
          },
          "connection_limit": {
            "description": "The maximum number of concurrent connections allowed for the route domain. Setting this to `0' turns off connection limits.",
            "type": "string"
          },
          "description": {
            "description": "Specifies descriptive text that identifies the route domain.",
            "type": "string"
          },
          "flow_eviction_policy": {
            "description": "The eviction policy to use with this route domain. Apply an eviction policy to provide customized responses to flow overflows and slow flows on the route domain.",
            "type": "string"
          },
          "id": {
            "description": "The unique identifying integer representing the route domain.",
            "type": "string"
          },
          "parent": {
            "description": "S p e c i f i e s   t h e   r o u t e   d o m a i n   t h e   s y s t e m   s e a r c h e s   w h e n i t   c a n n o t f i n d   a   r o u t e   i n   t h e   c o n f i g u r e d   d o m a i n .",
            "type": "string"
          },
          "password": {
            "description": "The password for the user account used to connect to the BIG-IP.",
            "type": "string"
          },
          "routing_protocol": {
            "description": "Dynamic routing protocols for the system to use in the route domain.",
            "type": "string"
          },
          "server": {
            "description": "The BIG-IP host.",
            "type": "string"
          },
          "server_port": {
            "description": "The BIG-IP server port.",
            "type": "string"
          },
          "service_policy": {
            "description": "Service policy to associate with the route domain.",
            "type": "string"
          },
          "state": {
            "description": "Whether the route domain should exist or not.",
            "type": "string"
          },
          "strict": {
            "description": "Specifies whether the system enforces cross- routing restrictions or not.",
            "type": "string"
          },
          "user": {
            "description": "The username to connect to the BIG-IP with. This user must have administrative privileges on the device.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          },
          "vlans": {
            "description": "VLANs for the system to use in the route domain",
            "type": "string"
          }
        },
        "required": [
          "id",
          "password",
          "server",
          "user"
        ]
      }
    },
    {
      "bigip_selfip": {
        "type": "object",
        "description": "Manage Self-IPs on a BIG-IP system",
        "properties": {
          "address": {
            "description": "The IP addresses for the new self IP. This value is ignored upon update as addresses themselves cannot be changed after they are created.",
            "type": "string"
          },
          "allow_service": {
            "description": "Configure port lockdown for the Self IP. By default, the Self IP has a \"default deny\" policy. This can be changed to allow TCP and UDP ports as well as specific protocols. This list should contain `protocol':`port' values.",
            "type": "string"
          },
          "name": {
            "description": "The self IP to create.",
            "type": "string"
          },
          "netmask": {
            "description": "The netmasks for the self IP.",
            "type": "string"
          },
          "password": {
            "description": "The password for the user account used to connect to the BIG-IP.",
            "type": "string"
          },
          "server": {
            "description": "The BIG-IP host.",
            "type": "string"
          },
          "server_port": {
            "description": "The BIG-IP server port.",
            "type": "string"
          },
          "state": {
            "description": "The state of the variable on the system. When `present', guarantees that the Self-IP exists with the provided attributes. When `absent', removes the Self-IP from the system.",
            "type": "string"
          },
          "traffic_group": {
            "description": "The traffic group for the self IP addresses in an active-active, redundant load balancer configuration.",
            "type": "string"
          },
          "user": {
            "description": "The username to connect to the BIG-IP with. This user must have administrative privileges on the device.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          },
          "vlan": {
            "description": "The VLAN that the new self IPs will be on.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "netmask",
          "password",
          "server",
          "user",
          "vlan"
        ]
      }
    },
    {
      "bigip_ssl_certificate": {
        "type": "object",
        "description": "Import/Delete certificates from BIG-IP",
        "properties": {
          "cert_content": {
            "description": "When used instead of 'cert_src', sets the contents of a certificate directly to the specified value. This is used with lookup plugins or for anything with formatting or templating. Either one of `key_src', `key_content', `cert_src' or `cert_content' must be provided when `state' is `present'.",
            "type": "string"
          },
          "cert_src": {
            "description": "This is the local filename of the certificate. Either one of `key_src', `key_content', `cert_src' or `cert_content' must be provided when `state' is `present'.",
            "type": "string"
          },
          "key_content": {
            "description": "When used instead of 'key_src', sets the contents of a certificate key directly to the specified value. This is used with lookup plugins or for anything with formatting or templating. Either one of `key_src', `key_content', `cert_src' or `cert_content' must be provided when `state' is `present'.",
            "type": "string"
          },
          "key_src": {
            "description": "This is the local filename of the private key. Either one of `key_src', `key_content', `cert_src' or `cert_content' must be provided when `state' is `present'.",
            "type": "string"
          },
          "name": {
            "description": "SSL Certificate Name.  This is the cert/key pair name used when importing a certificate/key into the F5. It also determines the filenames of the objects on the LTM (:Partiti on:name.cer_11111 _1 and :Partition _name.key_11111_1 ).",
            "type": "string"
          },
          "partition": {
            "description": "BIG-IP partition to use when adding/deleting certificate.",
            "type": "string"
          },
          "passphrase": {
            "description": "Passphrase on certificate private key",
            "type": "string"
          },
          "password": {
            "description": "The password for the user account used to connect to the BIG-IP.",
            "type": "string"
          },
          "server": {
            "description": "The BIG-IP host.",
            "type": "string"
          },
          "server_port": {
            "description": "The BIG-IP server port.",
            "type": "string"
          },
          "state": {
            "description": "Certificate and key state. This determines if the provided certificate and key is to be made `present' on the device or `absent'.",
            "type": "string"
          },
          "user": {
            "description": "The username to connect to the BIG-IP with. This user must have administrative privileges on the device.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "password",
          "server",
          "state",
          "user"
        ]
      }
    },
    {
      "bigip_sys_db": {
        "type": "object",
        "description": "Manage BIG-IP system database variables",
        "properties": {
          "key": {
            "description": "The database variable to manipulate.",
            "type": "string"
          },
          "password": {
            "description": "The password for the user account used to connect to the BIG-IP.",
            "type": "string"
          },
          "server": {
            "description": "The BIG-IP host.",
            "type": "string"
          },
          "server_port": {
            "description": "The BIG-IP server port.",
            "type": "string"
          },
          "state": {
            "description": "The state of the variable on the system. When `present', guarantees that an existing variable is set to `value'. When `reset' sets the variable back to the default value. At least one of value and state `reset' are required.",
            "type": "string"
          },
          "user": {
            "description": "The username to connect to the BIG-IP with. This user must have administrative privileges on the device.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          },
          "value": {
            "description": "The value to set the key to. At least one of value and state `reset' are required.",
            "type": "string"
          }
        },
        "required": [
          "key",
          "password",
          "server",
          "user"
        ]
      }
    },
    {
      "bigip_virtual_server": {
        "type": "object",
        "description": "Manages F5 BIG-IP LTM virtual servers",
        "properties": {
          "all_profiles": {
            "description": "List of all Profiles (HTTP,ClientSSL,S erverSSL,etc) that must be used by the virtual server",
            "type": "string"
          },
          "all_rules": {
            "description": "List of rules to be applied in priority order",
            "type": "string"
          },
          "default_persistence_profile": {
            "description": "Default Profile which manages the session persistence",
            "type": "string"
          },
          "description": {
            "description": "Virtual server description",
            "type": "string"
          },
          "destination": {
            "description": "Destination IP of the virtual server (only host is currently supported). Required when state=present and vs does not exist.",
            "type": "string"
          },
          "enabled_vlans": {
            "description": "List of vlans to be enabled. When a VLAN named `ALL' is used, all VLANs will be allowed.",
            "type": "string"
          },
          "name": {
            "description": "Virtual server name",
            "type": "string"
          },
          "partition": {
            "description": "Partition",
            "type": "string"
          },
          "password": {
            "description": "The password for the user account used to connect to the BIG-IP.",
            "type": "string"
          },
          "pool": {
            "description": "Default pool for the virtual server",
            "type": "string"
          },
          "port": {
            "description": "Port of the virtual server . Required when state=present and vs does not exist",
            "type": "string"
          },
          "server": {
            "description": "The BIG-IP host.",
            "type": "string"
          },
          "server_port": {
            "description": "The BIG-IP server port.",
            "type": "string"
          },
          "snat": {
            "description": "Source network address policy",
            "type": "string"
          },
          "state": {
            "description": "Virtual Server state Absent, delete the VS if present `present' (and its synonym enabled), create if needed the VS and set state to enabled `disabled', create if needed the VS and set state to disabled",
            "type": "string"
          },
          "user": {
            "description": "The username to connect to the BIG-IP with. This user must have administrative privileges on the device.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": [
          "destination",
          "name",
          "password",
          "server",
          "user"
        ]
      }
    },
    {
      "bigip_vlan": {
        "type": "object",
        "description": "Manage VLANs on a BIG-IP system",
        "properties": {
          "description": {
            "description": "The description to give to the VLAN.",
            "type": "string"
          },
          "name": {
            "description": "The VLAN to manage. If the special VLAN `ALL' is specified with the `state' value of `absent' then all VLANs will be removed.",
            "type": "string"
          },
          "password": {
            "description": "The password for the user account used to connect to the BIG-IP.",
            "type": "string"
          },
          "server": {
            "description": "The BIG-IP host.",
            "type": "string"
          },
          "server_port": {
            "description": "The BIG-IP server port.",
            "type": "string"
          },
          "state": {
            "description": "The state of the VLAN on the system. When `present', guarantees that the VLAN exists with the provided attributes. When `absent', removes the VLAN from the system.",
            "type": "string"
          },
          "tag": {
            "description": "Tag number for the VLAN. The tag number can be any integer between 1 and 4094. The system automatically assigns a tag number if you do not specify a value.",
            "type": "string"
          },
          "tagged_interfaces": {
            "description": "Specifies a list of tagged interfaces and trunks that you want to configure for the VLAN. Use tagged interfaces or trunks when you want to assign a single interface or trunk to multiple VLANs.",
            "type": "string"
          },
          "untagged_interfaces": {
            "description": "Specifies a list of untagged interfaces and trunks that you want to configure for the VLAN.",
            "type": "string"
          },
          "user": {
            "description": "The username to connect to the BIG-IP with. This user must have administrative privileges on the device.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "password",
          "server",
          "user"
        ]
      }
    },
    {
      "bigpanda": {
        "type": "object",
        "description": "Notify BigPanda about deployments",
        "properties": {
          "component": {
            "description": "The name of the component being deployed. Ex: billing",
            "type": "string"
          },
          "description": {
            "description": "Free text description of the deployment.",
            "type": "string"
          },
          "env": {
            "description": "The environment name, typically 'production', 'staging', etc.",
            "type": "string"
          },
          "hosts": {
            "description": "Name of affected host name. Can be a list.",
            "type": "string"
          },
          "owner": {
            "description": "The person responsible for the deployment.",
            "type": "string"
          },
          "state": {
            "description": "State of the deployment.",
            "type": "string"
          },
          "token": {
            "description": "API token.",
            "type": "string"
          },
          "url": {
            "description": "Base URL of the API server.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates for the target url will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          },
          "version": {
            "description": "The deployment version.",
            "type": "string"
          }
        },
        "required": [
          "component",
          "state",
          "token",
          "version"
        ]
      }
    },
    {
      "blockinfile": {
        "type": "object",
        "description": "Insert/update/remove a text block surrounded by marker lines.",
        "properties": {
          "backup": {
            "description": "Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.",
            "type": "string"
          },
          "block": {
            "description": "The text to insert inside the marker lines. If it's missing or an empty string, the block will be removed as if `state' were specified to `absent'.",
            "type": "string"
          },
          "create": {
            "description": "Create a new file if it doesn't exist.",
            "type": "string"
          },
          "dest": {
            "description": "The file to modify.",
            "type": "string"
          },
          "follow": {
            "description": "This flag indicates that filesystem links, if they exist, should be followed.",
            "type": "string"
          },
          "group": {
            "description": "name of the group that should own the file/directory, as would be fed to `chown'",
            "type": "string"
          },
          "insertafter": {
            "description": "If specified, the block will be inserted after the last match of specified regular expression. A special value is available; `EOF' for inserting the block at the end of the file.  If specified regular expresion has no matches, `EOF' will be used instead.",
            "type": "string"
          },
          "insertbefore": {
            "description": "If specified, the block will be inserted before the last match of specified regular expression. A special value is available; `BOF' for inserting the block at the beginning of the file.  If specified regular expresion has no matches, the block will be inserted at the end of the file.",
            "type": "string"
          },
          "marker": {
            "description": "The marker line template. \"{mark}\" will be replaced with \"BEGIN\" or \"END\".",
            "type": "string"
          },
          "mode": {
            "description": "mode the file or directory should be. For those used to `/usr/bin/chmod' remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, `u+rwx' or `u=rw,g=r,o=r').",
            "type": "string"
          },
          "owner": {
            "description": "name of the user that should own the file/directory, as would be fed to `chown'",
            "type": "string"
          },
          "selevel": {
            "description": "level part of the SELinux file context. This is the MLS/MCS attribute, sometimes known as the `range'. `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "serole": {
            "description": "role part of SELinux file context, `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "setype": {
            "description": "type part of SELinux file context, `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "seuser": {
            "description": "user part of SELinux file context. Will default to system policy, if applicable. If set to `_default', it will use the `user' portion of the policy if available",
            "type": "string"
          },
          "state": {
            "description": "Whether the block should be there or not.",
            "type": "string"
          },
          "unsafe_writes": {
            "description": "Normally this module uses atomic operations to prevent data corruption or inconsistent reads from the target files, sometimes systems are configured or just broken in ways that prevent this. One example are docker mounted files, they cannot be updated atomically and can only be done in an unsafe manner. This boolean option allows ansible to fall back to unsafe methods of updating files for those cases in which you do not have any other choice. Be aware that this is subject to race conditions and can lead to data corruption.",
            "type": "string"
          },
          "validate": {
            "description": "The validation command to run before copying into place. The path to the file to validate is passed in via '%s' which must be present as in the example below. The command is passed securely so shell features like expansion and pipes won't work.",
            "type": "string"
          }
        },
        "required": "dest"
      }
    },
    {
      "boundary_meter": {
        "type": "object",
        "description": "Manage boundary meters",
        "properties": {
          "apiid": {
            "description": "Organizations boundary API ID",
            "type": "string"
          },
          "apikey": {
            "description": "Organizations boundary API KEY",
            "type": "string"
          },
          "name": {
            "description": "meter name",
            "type": "string"
          },
          "state": {
            "description": "Whether to create or remove the client from boundary",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": [
          "apiid",
          "apikey",
          "name"
        ]
      }
    },
    {
      "bower": {
        "type": "object",
        "description": "Manage bower packages with bower",
        "properties": {
          "name": {
            "description": "The name of a bower package to install",
            "type": "string"
          },
          "offline": {
            "description": "Install packages from local cache, if the packages were installed before",
            "type": "string"
          },
          "path": {
            "description": "The base path where to install the bower packages",
            "type": "string"
          },
          "production": {
            "description": "Install with --production flag",
            "type": "string"
          },
          "relative_execpath": {
            "description": "Relative path to bower executable from install path",
            "type": "string"
          },
          "state": {
            "description": "The state of the bower package",
            "type": "string"
          },
          "version": {
            "description": "The version to be installed",
            "type": "string"
          }
        },
        "required": "path"
      }
    },
    {
      "bundler": {
        "type": "object",
        "description": "Manage Ruby Gem dependencies with Bundler",
        "properties": {
          "binstub_directory": {
            "description": "Only applies if state is `present'. Specifies the directory to install any gem bins files to. When executed the bin files will run within the context of the Gemfile and fail if any required gem dependencies are not installed. If `chdir' is set then this path is relative to `chdir'",
            "type": "string"
          },
          "chdir": {
            "description": "The directory to execute the bundler commands from. This directoy needs to contain a valid Gemfile or .bundle/ directory",
            "type": "string"
          },
          "clean": {
            "description": "Only applies if state is `present'. If set removes any gems on the target host that are not in the gemfile",
            "type": "string"
          },
          "deployment_mode": {
            "description": "Only applies if state is `present'. If set it will only install gems that are in the default or production groups. Requires a Gemfile.lock file to have been created prior",
            "type": "string"
          },
          "exclude_groups": {
            "description": "A list of Gemfile groups to exclude during operations. This only applies when state is `present'. Bundler considers this a 'remembered' property for the Gemfile and will automatically exclude groups in future operations even if `exclude_groups' is not set",
            "type": "string"
          },
          "executable": {
            "description": "The path to the bundler executable",
            "type": "string"
          },
          "extra_args": {
            "description": "A space separated string of additional commands that can be applied to the Bundler command. Refer to the Bundler documentation for more information",
            "type": "string"
          },
          "gem_path": {
            "description": "Only applies if state is `present'. Specifies the directory to install the gems into. If `chdir' is set then this path is relative to `chdir'",
            "type": "string"
          },
          "gemfile": {
            "description": "Only applies if state is `present'. The path to the gemfile to use to install gems.",
            "type": "string"
          },
          "local": {
            "description": "If set only installs gems from the cache on the target host",
            "type": "string"
          },
          "state": {
            "description": "The desired state of the Gem bundle. `latest' updates gems to the most recent, acceptable version",
            "type": "string"
          },
          "user_install": {
            "description": "Only applies if state is `present'. Installs gems in the local user's cache or for all users",
            "type": "string"
          }
        }
      }
    },
    {
      "bzr": {
        "type": "object",
        "description": "Deploy software (or files) from bzr branches",
        "properties": {
          "dest": {
            "description": "Absolute path of where the branch should be cloned to.",
            "type": "string"
          },
          "executable": {
            "description": "Path to bzr executable to use. If not supplied, the normal mechanism for resolving binary paths will be used.",
            "type": "string"
          },
          "force": {
            "description": "If `yes', any modified files in the working tree will be discarded. Before 1.9 the default value was \"yes\".",
            "type": "string"
          },
          "name": {
            "description": "SSH or HTTP protocol address of the parent branch.",
            "type": "string"
          },
          "version": {
            "description": "What version of the branch to clone.  This can be the bzr revno or revid.",
            "type": "string"
          }
        },
        "required": [
          "dest",
          "name"
        ]
      }
    },
    {
      "campfire": {
        "type": "object",
        "description": "Send a message to Campfire",
        "properties": {
          "msg": {
            "description": "The message body.",
            "type": "string"
          },
          "notify": {
            "description": "Send a notification sound before the message.",
            "type": "string"
          },
          "room": {
            "description": "Room number to which the message should be sent.",
            "type": "string"
          },
          "subscription": {
            "description": "The subscription name to use.",
            "type": "string"
          },
          "token": {
            "description": "API token.",
            "type": "string"
          }
        },
        "required": [
          "msg",
          "room",
          "subscription",
          "token"
        ]
      }
    },
    {
      "capabilities": {
        "type": "object",
        "description": "Manage Linux capabilities",
        "properties": {
          "capability": {
            "description": "Desired capability to set (with operator and flags, if state is `present') or remove (if state is `absent')",
            "type": "string"
          },
          "path": {
            "description": "Specifies the path to the file to be managed.",
            "type": "string"
          },
          "state": {
            "description": "Whether the entry should be present or absent in the file's capabilities.",
            "type": "string"
          }
        },
        "required": [
          "capability",
          "path"
        ]
      }
    },
    {
      "circonus_annotation": {
        "type": "object",
        "description": "create an annotation in circonus",
        "properties": {
          "api_key": {
            "description": "Circonus API key",
            "type": "string"
          },
          "category": {
            "description": "Annotation Category",
            "type": "string"
          },
          "description": {
            "description": "Description of annotation",
            "type": "string"
          },
          "duration": {
            "description": "Duration in seconds of annotation, defaults to 0",
            "type": "string"
          },
          "start": {
            "description": "Unix timestamp of event start, defaults to now",
            "type": "string"
          },
          "stop": {
            "description": "Unix timestamp of event end, defaults to now + duration",
            "type": "string"
          },
          "title": {
            "description": "Title of annotation",
            "type": "string"
          }
        },
        "required": [
          "api_key",
          "category",
          "description",
          "title"
        ]
      }
    },
    {
      "cl_bond": {
        "type": "object",
        "description": "Configures a bond port on Cumulus Linux",
        "properties": {
          "addr_method": {
            "description": "Configures the port to use DHCP. To enable this feature use the option `dhcp'.",
            "type": "string"
          },
          "alias_name": {
            "description": "Description of the port.",
            "type": "string"
          },
          "clag_id": {
            "description": "Specify a unique clag_id for every dual connected bond on each peer switch. The value must be between 1 and 65535 and must be the same on both peer switches in order for the bond to be considered dual- connected.",
            "type": "string"
          },
          "ipv4": {
            "description": "List of IPv4 addresses to configure on the interface. In the form `X.X.X.X/YY'.",
            "type": "string"
          },
          "ipv6": {
            "description": "List of IPv6 addresses to configure on the interface. In the form `X:X:X::X/YYY'.",
            "type": "string"
          },
          "lacp_bypass_all_active": {
            "description": "Activate all interfaces for bypass. It is recommended to configure all_active instead of using bypass_priority.",
            "type": "string"
          },
          "lacp_bypass_allow": {
            "description": "Enable LACP bypass.",
            "type": "string"
          },
          "lacp_bypass_period": {
            "description": "Period for enabling LACP bypass. Max value is 900.",
            "type": "string"
          },
          "lacp_bypass_priority": {
            "description": "List of ports and priorities. Example `\"swp1=10, swp2=20\"'.",
            "type": "string"
          },
          "lacp_rate": {
            "description": "The lacp rate.",
            "type": "string"
          },
          "location": {
            "description": "Interface directory location.",
            "type": "string"
          },
          "miimon": {
            "description": "The mii link monitoring interval.",
            "type": "string"
          },
          "min_links": {
            "description": "Minimum number of links.",
            "type": "string"
          },
          "mode": {
            "description": "The bond mode, as of Cumulus Linux 2.5 only LACP bond mode is supported.",
            "type": "string"
          },
          "mstpctl_bpduguard": {
            "description": "Enables BPDU Guard on a port in vlan-aware mode.",
            "type": "string"
          },
          "mstpctl_portadminedge": {
            "description": "Enables admin edge port.",
            "type": "string"
          },
          "mstpctl_portnetwork": {
            "description": "Enables bridge assurance in vlan-aware mode.",
            "type": "string"
          },
          "mtu": {
            "description": "Set MTU. Configure Jumbo Frame by setting MTU to `9000'.",
            "type": "string"
          },
          "name": {
            "description": "Name of the interface.",
            "type": "string"
          },
          "pvid": {
            "description": "In vlan-aware mode, defines vlan that is the untagged vlan.",
            "type": "string"
          },
          "slaves": {
            "description": "Bond members.",
            "type": "string"
          },
          "vids": {
            "description": "In vlan-aware mode, lists VLANs defined under the interface.",
            "type": "string"
          },
          "virtual_ip": {
            "description": "Define IPv4 virtual IP used by the Cumulus Linux VRR feature.",
            "type": "string"
          },
          "virtual_mac": {
            "description": "Define Ethernet mac associated with Cumulus Linux VRR feature.",
            "type": "string"
          },
          "xmit_hash_policy": {
            "description": "Transmit load balancing algorithm. As of Cumulus Linux 2.5 only `layer3+4' policy is supported.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "slaves"
        ]
      }
    },
    {
      "cl_bridge": {
        "type": "object",
        "description": "Configures a bridge port on Cumulus Linux",
        "properties": {
          "addr_method": {
            "description": "Configures the port to use DHCP. To enable this feature use the option `dhcp'.",
            "type": "string"
          },
          "alias_name": {
            "description": "Description of the port.",
            "type": "string"
          },
          "ipv4": {
            "description": "List of IPv4 addresses to configure on the interface. In the form `X.X.X.X/YY'.",
            "type": "string"
          },
          "ipv6": {
            "description": "List of IPv6 addresses to configure on the interface. In the form `X:X:X::X/YYY'.",
            "type": "string"
          },
          "location": {
            "description": "Interface directory location.",
            "type": "string"
          },
          "mstpctl_treeprio": {
            "description": "Set spanning tree root priority. Must be a multiple of 4096.",
            "type": "string"
          },
          "mtu": {
            "description": "Set MTU. Configure Jumbo Frame by setting MTU to `9000'.",
            "type": "string"
          },
          "name": {
            "description": "Name of the interface.",
            "type": "string"
          },
          "ports": {
            "description": "List of bridge members.",
            "type": "string"
          },
          "pvid": {
            "description": "In vlan-aware mode, defines vlan that is the untagged vlan.",
            "type": "string"
          },
          "stp": {
            "description": "Enables spanning tree Protocol. As of Cumulus Linux 2.5 the default bridging mode, only per vlan RSTP or 802.1d is supported. For the vlan aware mode, only common instance STP is supported",
            "type": "string"
          },
          "vids": {
            "description": "In vlan-aware mode, lists VLANs defined under the interface.",
            "type": "string"
          },
          "virtual_ip": {
            "description": "Define IPv4 virtual IP used by the Cumulus Linux VRR feature.",
            "type": "string"
          },
          "virtual_mac": {
            "description": "Define Ethernet mac associated with Cumulus Linux VRR feature.",
            "type": "string"
          },
          "vlan_aware": {
            "description": "Enables vlan-aware mode.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "ports"
        ]
      }
    },
    {
      "cl_img_install": {
        "type": "object",
        "description": "Install a different Cumulus Linux version.",
        "properties": {
          "src": {
            "description": "The full path to the Cumulus Linux binary image. Can be a local path, http or https URL. If the code version is in the name of the file, the module will assume this is the version of code you wish to install.",
            "type": "string"
          },
          "switch_slot": {
            "description": "Switch slots after installing the image. To run the installed code, reboot the switch.",
            "type": "string"
          },
          "version": {
            "description": "Inform the module of the exact version one is installing. This overrides the automatic check of version in the file name. For example, if the binary file name is called Cumulus Linux-2.2.3.bin, and version is set to '2.5.0', then the module will assume it is installing '2.5.0' not '2.2.3'. If version is not included, then the module will assume '2.2.3' is the version to install.",
            "type": "string"
          }
        },
        "required": "src"
      }
    },
    {
      "cl_interface": {
        "type": "object",
        "description": "Configures a front panel port, loopback or management port on Cumulus Linux.",
        "properties": {
          "addr_method": {
            "description": "Address method.",
            "type": "string"
          },
          "alias_name": {
            "description": "Description of the port.",
            "type": "string"
          },
          "clagd_enable": {
            "description": "Enables the clagd daemon. This command should only be applied to the clag peerlink interface.",
            "type": "string"
          },
          "clagd_peer_ip": {
            "description": "IP address of the directly connected peer switch interface.",
            "type": "string"
          },
          "clagd_priority": {
            "description": "Integer that changes the role the switch has in the clag domain. The lower priority switch will assume the primary role. The number can be between 0 and 65535.",
            "type": "string"
          },
          "clagd_sys_mac": {
            "description": "Clagd system mac address. Recommended to use the range starting with 44:38:39:ff. Needs to be the same between 2 Clag switches.",
            "type": "string"
          },
          "ipv4": {
            "description": "List of IPv4 addresses to configure on the interface. In the form `X.X.X.X/YY'.",
            "type": "string"
          },
          "ipv6": {
            "description": "List of IPv6 addresses to configure on the interface. In the form `X:X:X::X/YYY'.",
            "type": "string"
          },
          "location": {
            "description": "Interface directory location",
            "type": "string"
          },
          "mstpctl_bpduguard": {
            "description": "Enables BPDU Guard on a port in vlan-aware mode.",
            "type": "string"
          },
          "mstpctl_portadminedge": {
            "description": "Enables admin edge port.",
            "type": "string"
          },
          "mstpctl_portnetwork": {
            "description": "Enables bridge assurance in vlan-aware mode.",
            "type": "string"
          },
          "mtu": {
            "description": "Set MTU. Configure Jumbo Frame by setting MTU to `9000'.",
            "type": "string"
          },
          "name": {
            "description": "Name of the interface.",
            "type": "string"
          },
          "pvid": {
            "description": "In vlan-aware mode, defines vlan that is the untagged vlan.",
            "type": "string"
          },
          "speed": {
            "description": "Set speed of the swp(front panel) or management(eth0) interface. speed is in MB.",
            "type": "string"
          },
          "vids": {
            "description": "In vlan-aware mode, lists VLANs defined under the interface.",
            "type": "string"
          },
          "virtual_ip": {
            "description": "Define IPv4 virtual IP used by the Cumulus Linux VRR feature.",
            "type": "string"
          },
          "virtual_mac": {
            "description": "Define Ethernet mac associated with Cumulus Linux VRR feature.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "cl_interface_policy": {
        "type": "object",
        "description": "Configure interface enforcement policy on Cumulus Linux",
        "properties": {
          "allowed": {
            "description": "List of ports to run initial run at 10G.",
            "type": "string"
          },
          "location": {
            "description": "Directory to store interface files.",
            "type": "string"
          }
        },
        "required": "allowed"
      }
    },
    {
      "cl_license": {
        "type": "object",
        "description": "Install Cumulus Linux license",
        "properties": {
          "force": {
            "description": "Force installation of a license. Typically not needed. It is recommended to manually run this command via the ansible command. A reload of switchd is not required. Running the force option in a playbook will break the idempotent state machine of the module and cause the switchd notification to kick in all the time, causing a disruption.",
            "type": "string"
          },
          "src": {
            "description": "The full path to the license. Can be local path or HTTP URL.",
            "type": "string"
          }
        },
        "required": "src"
      }
    },
    {
      "cl_ports": {
        "type": "object",
        "description": "Configure Cumulus Switch port attributes (ports.conf)",
        "properties": {
          "speed_10g": {
            "description": "List of ports to run initial run at 10G.",
            "type": "string"
          },
          "speed_40g": {
            "description": "List of ports to run initial run at 40G.",
            "type": "string"
          },
          "speed_40g_div_4": {
            "description": "List of 10G ports that will be ganged to form a 40G port.",
            "type": "string"
          },
          "speed_4_by_10g": {
            "description": "List of 40G ports that will be unganged to run as 4 10G ports.",
            "type": "string"
          }
        }
      }
    },
    {
      "clc_aa_policy": {
        "type": "object",
        "description": "Create or Delete Anti Affinity Policies at CenturyLink Cloud.",
        "properties": {
          "location": {
            "description": "Datacenter in which the policy lives/should live.",
            "type": "string"
          },
          "name": {
            "description": "The name of the Anti Affinity Policy.",
            "type": "string"
          },
          "state": {
            "description": "Whether to create or delete the policy.",
            "type": "string"
          },
          "wait": {
            "description": "Whether to wait for the tasks to finish before returning.",
            "type": "string"
          }
        },
        "required": [
          "location",
          "name"
        ]
      }
    },
    {
      "clc_alert_policy": {
        "type": "object",
        "description": "Create or Delete Alert Policies at CenturyLink Cloud.",
        "properties": {
          "alert_recipients": {
            "description": "A list of recipient email ids to notify the alert. This is required for state 'present'",
            "type": "string"
          },
          "alias": {
            "description": "The alias of your CLC Account",
            "type": "string"
          },
          "duration": {
            "description": "The length of time in minutes that the condition must exceed the threshold. This is required for state 'present'",
            "type": "string"
          },
          "id": {
            "description": "The alert policy id. This is mutually exclusive with name",
            "type": "string"
          },
          "metric": {
            "description": "The metric on which to measure the condition that will trigger the alert. This is required for state 'present'",
            "type": "string"
          },
          "name": {
            "description": "The name of the alert policy. This is mutually exclusive with id",
            "type": "string"
          },
          "state": {
            "description": "Whether to create or delete the policy.",
            "type": "string"
          },
          "threshold": {
            "description": "The threshold that will trigger the alert when the metric equals or exceeds it. This is required for state 'present' This number represents a percentage and must be a value between 5.0 - 95.0 that is a multiple of 5.0",
            "type": "string"
          }
        },
        "required": "alias"
      }
    },
    {
      "clc_blueprint_package": {
        "type": "object",
        "description": "deploys a blue print package on a set of servers in CenturyLink Cloud.",
        "properties": {
          "package_id": {
            "description": "The package id of the blue print.",
            "type": "string"
          },
          "package_params": {
            "description": "The dictionary of arguments required to deploy the blue print.",
            "type": "string"
          },
          "server_ids": {
            "description": "A list of server Ids to deploy the blue print package.",
            "type": "string"
          },
          "state": {
            "description": "Whether to install or un-install the package. Currently it supports only \"present\" for install action.",
            "type": "string"
          },
          "wait": {
            "description": "Whether to wait for the tasks to finish before returning.",
            "type": "string"
          }
        },
        "required": [
          "package_id",
          "server_ids"
        ]
      }
    },
    {
      "clc_firewall_policy": {
        "type": "object",
        "description": "Create/delete/update firewall policies",
        "properties": {
          "destination": {
            "description": "The list of destination addresses for traffic on the terminating firewall. This is required when state is 'present'",
            "type": "string"
          },
          "destination_account_alias": {
            "description": "CLC alias for the destination account",
            "type": "string"
          },
          "enabled": {
            "description": "Whether the firewall policy is enabled or disabled",
            "type": "string"
          },
          "firewall_policy_id": {
            "description": "Id of the firewall policy. This is required to update or delete an existing firewall policy",
            "type": "string"
          },
          "location": {
            "description": "Target datacenter for the firewall policy",
            "type": "string"
          },
          "ports": {
            "description": "The list of ports associated with the policy. TCP and UDP can take in single ports or port ranges.",
            "type": "string"
          },
          "source": {
            "description": "The list  of source addresses for traffic on the originating firewall. This is required when state is 'present\"",
            "type": "string"
          },
          "source_account_alias": {
            "description": "CLC alias for the source account",
            "type": "string"
          },
          "state": {
            "description": "Whether to create or delete the firewall policy",
            "type": "string"
          },
          "wait": {
            "description": "Whether to wait for the provisioning tasks to finish before returning.",
            "type": "string"
          }
        },
        "required": [
          "location",
          "source_account_alias"
        ]
      }
    },
    {
      "clc_group": {
        "type": "object",
        "description": "Create/delete Server Groups at Centurylink Cloud",
        "properties": {
          "description": {
            "description": "A description of the Server Group",
            "type": "string"
          },
          "location": {
            "description": "Datacenter to create the group in. If location is not provided, the group gets created in the default datacenter associated with the account",
            "type": "string"
          },
          "name": {
            "description": "The name of the Server Group",
            "type": "string"
          },
          "parent": {
            "description": "The parent group of the server group. If parent is not provided, it creates the group at top level.",
            "type": "string"
          },
          "state": {
            "description": "Whether to create or delete the group",
            "type": "string"
          },
          "wait": {
            "description": "Whether to wait for the tasks to finish before returning.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "clc_loadbalancer": {
        "type": "object",
        "description": "Create, Delete shared loadbalancers in CenturyLink Cloud.",
        "properties": {
          "alias": {
            "description": "The alias of your CLC Account",
            "type": "string"
          },
          "description": {
            "description": "A description for the loadbalancer",
            "type": "string"
          },
          "location": {
            "description": "The location of the datacenter where the load balancer resides in",
            "type": "string"
          },
          "method": {
            "description": "- T h e   b a l a n c i n g   m e t h o d   f o r   t h e   l o a d   b a l a n c e r   p o o l",
            "type": "string"
          },
          "name": {
            "description": "The name of the loadbalancer",
            "type": "string"
          },
          "nodes": {
            "description": "A list of nodes that needs to be added to the load balancer pool",
            "type": "string"
          },
          "persistence": {
            "description": "The persistence method for the load balancer",
            "type": "string"
          },
          "port": {
            "description": "Port to configure on the public-facing side of the load balancer pool",
            "type": "string"
          },
          "state": {
            "description": "Whether to create or delete the load balancer pool",
            "type": "string"
          },
          "status": {
            "description": "The status of the loadbalancer",
            "type": "string"
          }
        },
        "required": [
          "alias",
          "location",
          "name"
        ]
      }
    },
    {
      "clc_modify_server": {
        "type": "object",
        "description": "modify servers in CenturyLink Cloud.",
        "properties": {
          "alert_policy_id": {
            "description": "The alert policy id to be associated to the server. This is mutually exclusive with 'a lert_policy_name'",
            "type": "string"
          },
          "alert_policy_name": {
            "description": "The alert policy name to be associated to the server. This is mutually exclusive with 'alert_policy_id'",
            "type": "string"
          },
          "anti_affinity_policy_id": {
            "description": "The anti affinity policy id to be set for a hyper scale server. This is mutually exclusive with 'a nti_affinity_poli cy_name'",
            "type": "string"
          },
          "anti_affinity_policy_name": {
            "description": "The anti affinity policy name to be set for a hyper scale server. This is mutually exclusive with 'a nti_affinity_poli cy_id'",
            "type": "string"
          },
          "cpu": {
            "description": "How many CPUs to update on the server",
            "type": "string"
          },
          "memory": {
            "description": "Memory (in GB) to set to the server.",
            "type": "string"
          },
          "server_ids": {
            "description": "A list of server Ids to modify.",
            "type": "string"
          },
          "state": {
            "description": "The state to insure that the provided resources are in.",
            "type": "string"
          },
          "wait": {
            "description": "Whether to wait for the provisioning tasks to finish before returning.",
            "type": "string"
          }
        },
        "required": "server_ids"
      }
    },
    {
      "clc_publicip": {
        "type": "object",
        "description": "Add and Delete public ips on servers in CenturyLink Cloud.",
        "properties": {
          "ports": {
            "description": "A list of ports to expose. This is required when state is 'present'",
            "type": "string"
          },
          "protocol": {
            "description": "The protocol that the public IP will listen for.",
            "type": "string"
          },
          "server_ids": {
            "description": "A list of servers to create public ips on.",
            "type": "string"
          },
          "state": {
            "description": "Determine whether to create or delete public IPs. If present module will not create a second public ip if one already exists.",
            "type": "string"
          },
          "wait": {
            "description": "Whether to wait for the tasks to finish before returning.",
            "type": "string"
          }
        },
        "required": "server_ids"
      }
    },
    {
      "clc_server": {
        "type": "object",
        "description": "Create, Delete, Start and Stop servers in CenturyLink Cloud.",
        "properties": {
          "add_public_ip": {
            "description": "Whether to add a public ip to the server",
            "type": "string"
          },
          "additional_disks": {
            "description": "The list of additional disks for the server",
            "type": "string"
          },
          "alert_policy_id": {
            "description": "The alert policy to assign to the server. This is mutually exclusive with 'a lert_policy_name' .",
            "type": "string"
          },
          "alert_policy_name": {
            "description": "The alert policy to assign to the server. This is mutually exclusive with 'a lert_policy_id'.",
            "type": "string"
          },
          "alias": {
            "description": "The account alias to provision the servers under.",
            "type": "string"
          },
          "anti_affinity_policy_id": {
            "description": "The anti-affinity policy to assign to the server. This is mutually exclusive with 'a nti_affinity_poli cy_name'.",
            "type": "string"
          },
          "anti_affinity_policy_name": {
            "description": "The anti-affinity policy to assign to the server. This is mutually exclusive with 'a nti_affinity_poli cy_id'.",
            "type": "string"
          },
          "configuration_id": {
            "description": "Only required for bare metal servers. Specifies the identifier for the specific configuration type of bare metal server to deploy.",
            "type": "string"
          },
          "count": {
            "description": "The number of servers to build (mutually exclusive with exact_count)",
            "type": "string"
          },
          "count_group": {
            "description": "Required when exact_count is specified.  The Server Group use to determine how many severs to deploy.",
            "type": "string"
          },
          "cpu": {
            "description": "How many CPUs to provision on the server",
            "type": "string"
          },
          "cpu_autoscale_policy_id": {
            "description": "The autoscale policy to assign to the server.",
            "type": "string"
          },
          "custom_fields": {
            "description": "The list of custom fields to set on the server.",
            "type": "string"
          },
          "description": {
            "description": "The description to set for the server.",
            "type": "string"
          },
          "exact_count": {
            "description": "Run in idempotent mode.  Will insure that this exact number of servers are running in the provided group, creating and deleting them to reach that count. Requires count_group to be set.",
            "type": "string"
          },
          "group": {
            "description": "The Server Group to create servers under.",
            "type": "string"
          },
          "ip_address": {
            "description": "The IP Address for the server. One is assigned if not provided.",
            "type": "string"
          },
          "location": {
            "description": "The Datacenter to create servers in.",
            "type": "string"
          },
          "managed_os": {
            "description": "Whether to create the server as 'Managed' or not.",
            "type": "string"
          },
          "memory": {
            "description": "Memory in GB.",
            "type": "string"
          },
          "name": {
            "description": "A 1 to 6 character identifier to use for the server. This is required when state is 'present'",
            "type": "string"
          },
          "network_id": {
            "description": "The network UUID on which to create servers.",
            "type": "string"
          },
          "os_type": {
            "description": "Only required for bare metal servers. Specifies the OS to provision with the bare metal server.",
            "type": "string"
          },
          "packages": {
            "description": "The list of blue print packages to run on the server after its created.",
            "type": "string"
          },
          "password": {
            "description": "Password for the administrator / root user",
            "type": "string"
          },
          "primary_dns": {
            "description": "Primary DNS used by the server.",
            "type": "string"
          },
          "public_ip_ports": {
            "description": "A list of ports to allow on the firewall to the servers public ip, if add_public_ip is set to True.",
            "type": "string"
          },
          "public_ip_protocol": {
            "description": "The protocol to use for the public ip if add_public_ip is set to True.",
            "type": "string"
          },
          "secondary_dns": {
            "description": "Secondary DNS used by the server.",
            "type": "string"
          },
          "server_ids": {
            "description": "Required for started, stopped, and absent states. A list of server Ids to insure are started, stopped, or absent.",
            "type": "string"
          },
          "source_server_password": {
            "description": "The password for the source server if a clone is specified.",
            "type": "string"
          },
          "state": {
            "description": "The state to insure that the provided resources are in.",
            "type": "string"
          },
          "storage_type": {
            "description": "The type of storage to attach to the server.",
            "type": "string"
          },
          "template": {
            "description": "The template to use for server creation.  Will search for a template if a partial string is provided. This is required when state is 'present'",
            "type": "string"
          },
          "ttl": {
            "description": "The time to live for the server in seconds.  The server will be deleted when this time expires.",
            "type": "string"
          },
          "type": {
            "description": "The type of server to create.",
            "type": "string"
          },
          "wait": {
            "description": "Whether to wait for the provisioning tasks to finish before returning.",
            "type": "string"
          }
        }
      }
    },
    {
      "clc_server_snapshot": {
        "type": "object",
        "description": "Create, Delete and Restore server snapshots in CenturyLink Cloud.",
        "properties": {
          "expiration_days": {
            "description": "The number of days to keep the server snapshot before it expires.",
            "type": "string"
          },
          "server_ids": {
            "description": "The list of CLC server Ids.",
            "type": "string"
          },
          "state": {
            "description": "The state to insure that the provided resources are in.",
            "type": "string"
          },
          "wait": {
            "description": "Whether to wait for the provisioning tasks to finish before returning.",
            "type": "string"
          }
        },
        "required": "server_ids"
      }
    },
    {
      "cloudflare_dns": {
        "type": "object",
        "description": "manage Cloudflare DNS records",
        "properties": {
          "account_api_token": {
            "description": "Account API token. You can obtain your API key from the bottom of the Cloudflare 'My Account' page, found here: https://www.cloud flare.com/a/accou nt",
            "type": "string"
          },
          "account_email": {
            "description": "Account email.",
            "type": "string"
          },
          "port": {
            "description": "S e r v i c e   p o r t .   R e q u i r e d   f o r   C ( t y p e = S R V )",
            "type": "string"
          },
          "priority": {
            "description": "R e c o r d   p r i o r i t y .   R e q u i r e d   f o r   C ( t y p e = M X )   a n d   C ( t y p e = S R V )",
            "type": "string"
          },
          "proto": {
            "description": "S e r v i c e   p r o t o c o l .   R e q u i r e d   f o r   C ( t y p e = S R V )",
            "type": "string"
          },
          "record": {
            "description": "Record to add. Required if `state=present'. Default is `@' (e.g. the zone name)",
            "type": "string"
          },
          "service": {
            "description": "R e c o r d   s e r v i c e .   R e q u i r e d f o r   C ( t y p e = S R V )",
            "type": "string"
          },
          "solo": {
            "description": "Whether the record should be the only one for that record type and record name. Only use with `state=present' This will delete all other records with the same record name and type.",
            "type": "string"
          },
          "state": {
            "description": "Whether the record(s) should exist or not",
            "type": "string"
          },
          "timeout": {
            "description": "Timeout for Cloudflare API calls",
            "type": "string"
          },
          "ttl": {
            "description": "The TTL to give the new record. Must be between 120 and 2,147,483,647 seconds, or 1 for automatic.",
            "type": "string"
          },
          "type": {
            "description": "The type of DNS record to create. Required if `state=present'",
            "type": "string"
          },
          "value": {
            "description": "The record value. Required for `state=present'",
            "type": "string"
          },
          "weight": {
            "description": "S e r v i c e   w e i g h t .   R e q u i r e d f o r   C ( t y p e = S R V )",
            "type": "string"
          },
          "zone": {
            "description": "The name of the Zone to work with (e.g. \"example.com\"). The Zone must already exist.",
            "type": "string"
          }
        },
        "required": [
          "account_api_token",
          "account_email",
          "zone"
        ]
      }
    },
    {
      "cloudformation": {
        "type": "object",
        "description": "Create or delete an AWS CloudFormation stack",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "disable_rollback": {
            "description": "If a stacks fails to form, rollback will remove the stack",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "notification_arns": {
            "description": "The Simple Notification Service (SNS) topic ARNs to publish stack related events.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used.",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "stack_name": {
            "description": "name of the cloudformation stack",
            "type": "string"
          },
          "stack_policy": {
            "description": "the path of the cloudformation stack policy",
            "type": "string"
          },
          "state": {
            "description": "If state is \"present\", stack will be created. If state is \"present\" and if stack exists and template has changed, it will be updated. If state is \"absent\", stack will be removed.",
            "type": "string"
          },
          "tags": {
            "description": "Dictionary of tags to associate with stack and it's resources during stack creation. Cannot be updated later. Requires at least Boto version 2.6.0.",
            "type": "string"
          },
          "template": {
            "description": "The local path of the cloudformation template. This parameter is mutually exclusive with 'template_url'. Either one of them is required if \"state\" parameter is \"present\" Must give full path to the file, relative to the working directory. If using roles this may look like \"ro les/cloudformatio n/files /cloudformation- example.json\"",
            "type": "string"
          },
          "template_format": {
            "description": "(deprecated) For local templates, allows specification of json or yaml format. Templates are now passed raw to CloudFormation regardless of format. This parameter is ignored since Ansible 2.2.",
            "type": "string"
          },
          "template_parameters": {
            "description": "a list of hashes of all the template variables for the stack",
            "type": "string"
          },
          "template_url": {
            "description": "Location of file containing the template body. The URL must point to a template (max size 307,200 bytes) located in an S3 bucket in the same region as the stack. This parameter is mutually exclusive with 'template'. Either one of them is required if \"state\" parameter is \"present\"",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        },
        "required": [
          "region",
          "stack_name",
          "state"
        ]
      }
    },
    {
      "cloudformation_facts": {
        "type": "object",
        "description": "Obtain facts about an AWS CloudFormation stack",
        "properties": {
          "all_facts": {
            "description": "Get all stack information for the stack",
            "type": "string"
          },
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "stack_events": {
            "description": "Get stack events for the stack",
            "type": "string"
          },
          "stack_name": {
            "description": "The name or id of the CloudFormation stack",
            "type": "string"
          },
          "stack_policy": {
            "description": "Get stack policy for the stack",
            "type": "string"
          },
          "stack_resources": {
            "description": "Get stack resources for the stack",
            "type": "string"
          },
          "stack_template": {
            "description": "Get stack template body for the stack",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        },
        "required": "stack_name"
      }
    },
    {
      "cloudtrail": {
        "type": "object",
        "description": "manage CloudTrail creation and deletion",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "include_global_events": {
            "description": "record API calls from global services such as IAM and STS?",
            "type": "string"
          },
          "name": {
            "description": "name for given CloudTrail configuration. This is a primary key and is used to identify the configuration.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the EC2_REGION environment variable, if any, is used.",
            "type": "string"
          },
          "s3_bucket_prefix": {
            "description": "bucket to place CloudTrail in. this bucket should exist and have the proper policy. See http: //docs.aws.amazon .com/awscloudtrai l/latest/userguid e/aggregating_log s_regions_bucket_ policy.html required when state=enabled.",
            "type": "string"
          },
          "s3_key_prefix": {
            "description": "prefix to keys in bucket. A trailing slash is not necessary and will be removed.",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "add or remove CloudTrail configuration.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        },
        "required": "state"
      }
    },
    {
      "cloudwatchevent_rule": {
        "type": "object",
        "description": "Manage CloudWatch Event rules and targets",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "description": {
            "description": "A description of the rule",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "event_pattern": {
            "description": "A string pattern (in valid JSON format) that is used to match against incoming events to determine if the rule should be triggered",
            "type": "string"
          },
          "name": {
            "description": "The name of the rule you are creating, updating or deleting. No spaces or special characters allowed (i.e. must match `[\\.\\-_A- Za-z0-9]+')",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "role_arn": {
            "description": "The Amazon Resource Name (ARN) of the IAM role associated with the rule",
            "type": "string"
          },
          "schedule_expression": {
            "description": "A cron or rate expression that defines the schedule the rule will trigger on. For example, `cron(0 20 * * ? *'), `rate(5 minutes')",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "Whether the rule is present (and enabled), disabled, or absent",
            "type": "string"
          },
          "targets": {
            "description": "A dictionary array of targets to add to or update for the rule, in the form `{ id: [string], arn: [string], input: [valid JSON string], input_path: [valid JSONPath string] }'. `id' [required] is the unique target assignment ID. `arn' (required) is the Amazon Resource Name associated with the target. `input' (optional) is a JSON object that will override the event data when passed to the target. `input_path' (optional) is a JSONPath string (e.g. `$.detail') that specifies the part of the event data to be passed to the target. If neither `input' nor `input_path' is specified, then the entire event is passed to the target in JSON form.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "command": {
        "type": "object",
        "description": "Executes a command on a remote node",
        "properties": {
          "chdir": {
            "description": "cd into this directory before running the command",
            "type": "string"
          },
          "creates": {
            "description": "a filename or (since 2.0) glob pattern, when it already exists, this step will *not* be run.",
            "type": "string"
          },
          "executable": {
            "description": "change the shell used to execute the command. Should be an absolute path to the executable.",
            "type": "string"
          },
          "free_form": {
            "description": "the command module takes a free form command to run.  There is no parameter actually named 'free form'. See the examples!",
            "type": "string"
          },
          "removes": {
            "description": "a filename or (since 2.0) glob pattern, when it does not exist, this step will *not* be run.",
            "type": "string"
          },
          "warn": {
            "description": "if command warnings are on in ansible.cfg, do not warn about this particular line if set to no/false.",
            "type": "string"
          }
        },
        "required": "free_form"
      }
    },
    {
      "composer": {
        "type": "object",
        "description": "Dependency Manager for PHP",
        "properties": {
          "arguments": {
            "description": "Composer arguments like required package, version and so on",
            "type": "string"
          },
          "command": {
            "description": "Composer command like \"install\", \"update\" and so on",
            "type": "string"
          },
          "ignore_platform_reqs": {
            "description": "Ignore php, hhvm, lib-* and ext-* requirements and force the installation even if the local machine does not fulfill these.",
            "type": "string"
          },
          "no_dev": {
            "description": "Disables installation of require-dev packages ( see --no-dev )",
            "type": "string"
          },
          "no_plugins": {
            "description": "Disables all plugins ( see --no-plugins )",
            "type": "string"
          },
          "no_scripts": {
            "description": "Skips the execution of all scripts defined in composer.json ( see --no-scripts )",
            "type": "string"
          },
          "optimize_autoloader": {
            "description": "Optimize autoloader during autoloader dump ( see --optimize- autoloader ). Convert PSR-0/4 autoloading to classmap to get a faster autoloader. This is recommended especially for production, but can take a bit of time to run so it is currently not done by default.",
            "type": "string"
          },
          "prefer_dist": {
            "description": "Forces installation from package dist even for dev versions ( see --prefer-dist )",
            "type": "string"
          },
          "prefer_source": {
            "description": "Forces installation from package sources when possible ( see --prefer-source )",
            "type": "string"
          },
          "working_dir": {
            "description": "Directory of your project ( see --working-dir )",
            "type": "string"
          }
        },
        "required": "working_dir"
      }
    },
    {
      "consul": {
        "type": "object",
        "description": "Add, modify & delete services within a consul cluster.",
        "properties": {
          "check_id": {
            "description": "an ID for the service check, defaults to the check name, ignored if part of a service definition.",
            "type": "string"
          },
          "check_name": {
            "description": "a name for the service check, defaults to the check id. required if standalone, ignored if part of service definition.",
            "type": "string"
          },
          "host": {
            "description": "host of the consul agent defaults to localhost",
            "type": "string"
          },
          "http": {
            "description": "checks can be registered with an http endpoint. This means that consul will check that the http endpoint returns a successful http status. Interval must also be provided with this option.",
            "type": "string"
          },
          "interval": {
            "description": "the interval at which the service check will be run. This is a number with a s or m suffix to signify the units of seconds or minutes e.g 15s or 1m. If no suffix is supplied, m will be used by default e.g. 1 will be 1m. Required if the script param is specified.",
            "type": "string"
          },
          "notes": {
            "description": "Notes to attach to check when registering it.",
            "type": "string"
          },
          "port": {
            "description": "the port on which the consul agent is running",
            "type": "string"
          },
          "scheme": {
            "description": "the protocol scheme on which the consul agent is running",
            "type": "string"
          },
          "script": {
            "description": "the script/command that will be run periodically to check the health of the service. Scripts require an interval and vise versa",
            "type": "string"
          },
          "service_address": {
            "description": "the address to advertise that the service will be listening on. This value will be passed as the `Address' parameter to Consul's /v1/agen t/service/registe r API method, so refer to the Consul API documentation for further details.",
            "type": "string"
          },
          "service_id": {
            "description": "the ID for the service, must be unique per node, defaults to the service name if the service name is supplied",
            "type": "string"
          },
          "service_name": {
            "description": "Unique name for the service on a node, must be unique per node, required if registering a service. May be ommitted if registering a node level check",
            "type": "string"
          },
          "service_port": {
            "description": "the port on which the service is listening required for registration of a service, i.e. if service_name or service_id is set",
            "type": "string"
          },
          "state": {
            "description": "register or deregister the consul service, defaults to present",
            "type": "string"
          },
          "tags": {
            "description": "a list of tags that will be attached to the service registration.",
            "type": "string"
          },
          "timeout": {
            "description": "A custom HTTP check timeout. The consul default is 10 seconds. Similar to the interval this is a number with a s or m suffix to signify the units of seconds or minutes, e.g. 15s or 1m.",
            "type": "string"
          },
          "token": {
            "description": "the token key indentifying an ACL rule set. May be required to register services.",
            "type": "string"
          },
          "ttl": {
            "description": "checks can be registered with a ttl instead of a script and interval this means that the service will check in with the agent before the ttl expires. If it doesn't the check will be considered failed. Required if registering a check and the script an interval are missing Similar to the interval this is a number with a s or m suffix to signify the units of seconds or minutes e.g 15s or 1m. If no suffix is supplied, m will be used by default e.g. 1 will be 1m",
            "type": "string"
          },
          "validate_certs": {
            "description": "whether to verify the tls certificate of the consul agent",
            "type": "string"
          }
        },
        "required": "state"
      }
    },
    {
      "consul_acl": {
        "type": "object",
        "description": "manipulate consul acl keys and rules",
        "properties": {
          "host": {
            "description": "host of the consul agent defaults to localhost",
            "type": "string"
          },
          "mgmt_token": {
            "description": "a management token is required to manipulate the acl lists",
            "type": "string"
          },
          "name": {
            "description": "the name that should be associated with the acl key, this is opaque to Consul",
            "type": "string"
          },
          "port": {
            "description": "the port on which the consul agent is running",
            "type": "string"
          },
          "rules": {
            "description": "an list of the rules that should be associated with a given token.",
            "type": "string"
          },
          "scheme": {
            "description": "the protocol scheme on which the consul agent is running",
            "type": "string"
          },
          "state": {
            "description": "whether the ACL pair should be present or absent",
            "type": "string"
          },
          "token": {
            "description": "the token key indentifying an ACL rule set. If generated by consul this will be a UUID.",
            "type": "string"
          },
          "token_type": {
            "description": "the type of token that should be created, either management or client",
            "type": "string"
          },
          "validate_certs": {
            "description": "whether to verify the tls certificate of the consul agent",
            "type": "string"
          }
        }
      }
    },
    {
      "consul_kv": {
        "type": "object",
        "description": "Manipulate entries in the key/value store of a consul cluster.",
        "properties": {
          "cas": {
            "description": "used when acquiring a lock with a session. If the cas is 0, then Consul will only put the key if it does not already exist. If the cas value is non-zero, then the key is only set if the index matches the ModifyIndex of that key.",
            "type": "string"
          },
          "flags": {
            "description": "opaque integer value that can be passed when setting a value.",
            "type": "string"
          },
          "host": {
            "description": "host of the consul agent defaults to localhost",
            "type": "string"
          },
          "key": {
            "description": "the key at which the value should be stored.",
            "type": "string"
          },
          "port": {
            "description": "the port on which the consul agent is running",
            "type": "string"
          },
          "recurse": {
            "description": "if the key represents a prefix, each entry with the prefix can be retrieved by setting this to true.",
            "type": "string"
          },
          "scheme": {
            "description": "the protocol scheme on which the consul agent is running",
            "type": "string"
          },
          "session": {
            "description": "the session that should be used to acquire or release a lock associated with a key/value pair",
            "type": "string"
          },
          "state": {
            "description": "the action to take with the supplied key and value. If the state is 'present', the key contents will be set to the value supplied, 'changed' will be set to true only if the value was different to the current contents. The state 'absent' will remove the key/value pair, again 'changed' will be set to true only if the key actually existed prior to the removal. An attempt can be made to obtain or free the lock associated with a key/value pair with the states 'acquire' or 'release' respectively. a valid session must be supplied to make the attempt changed will be true if the attempt is successful, false otherwise.",
            "type": "string"
          },
          "token": {
            "description": "the token key indentifying an ACL rule set that controls access to the key value pair",
            "type": "string"
          },
          "validate_certs": {
            "description": "whether to verify the tls certificate of the consul agent",
            "type": "string"
          },
          "value": {
            "description": "the value should be associated with the given key, required if state is present",
            "type": "string"
          }
        },
        "required": [
          "key",
          "value"
        ]
      }
    },
    {
      "consul_session": {
        "type": "object",
        "description": "manipulate consul sessions",
        "properties": {
          "behavior": {
            "description": "the optional behavior that can be attached to the session when it is created. This can be set to either release or delete. This controls the behavior when a session is invalidated.",
            "type": "string"
          },
          "checks": {
            "description": "a list of checks that will be used to verify the session health. If all the checks fail, the session will be invalidated and any locks associated with the session will be release and can be acquired once the associated lock delay has expired.",
            "type": "string"
          },
          "datacenter": {
            "description": "name of the datacenter in which the session exists or should be created.",
            "type": "string"
          },
          "delay": {
            "description": "the optional lock delay that can be attached to the session when it is created. Locks for invalidated sessions ar blocked from being acquired until this delay has expired. Durations are in seconds",
            "type": "string"
          },
          "host": {
            "description": "host of the consul agent defaults to localhost",
            "type": "string"
          },
          "name": {
            "description": "the name that should be associated with the session. This is opaque to Consul and not required.",
            "type": "string"
          },
          "node": {
            "description": "the name of the node that with which the session will be associated. by default this is the name of the agent.",
            "type": "string"
          },
          "port": {
            "description": "the port on which the consul agent is running",
            "type": "string"
          },
          "scheme": {
            "description": "the protocol scheme on which the consul agent is running",
            "type": "string"
          },
          "state": {
            "description": "whether the session should be present i.e. created if it doesn't exist, or absent, removed if present. If created, the ID for the session is returned in the output. If absent, the name or ID is required to remove the session. Info for a single session, all the sessions for a node or all available sessions can be retrieved by specifying info, node or list for the state; for node or info, the node name or session id is required as parameter.",
            "type": "string"
          },
          "validate_certs": {
            "description": "whether to verify the tls certificate of the consul agent",
            "type": "string"
          }
        }
      }
    },
    {
      "copy": {
        "type": "object",
        "description": "Copies files to remote locations.",
        "properties": {
          "backup": {
            "description": "Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.",
            "type": "string"
          },
          "content": {
            "description": "When used instead of 'src', sets the contents of a file directly to the specified value. This is for simple values, for anything complex or with formatting please switch to the template module.",
            "type": "string"
          },
          "dest": {
            "description": "Remote absolute path where the file should be copied to. If src is a directory, this must be a directory too.",
            "type": "string"
          },
          "directory_mode": {
            "description": "When doing a recursive copy set the mode for the directories. If this is not set we will use the system defaults. The mode is only set on directories which are newly created, and will not affect those that already existed.",
            "type": "string"
          },
          "follow": {
            "description": "This flag indicates that filesystem links, if they exist, should be followed.",
            "type": "string"
          },
          "force": {
            "description": "the default is `yes', which will replace the remote file when contents are different than the source. If `no', the file will only be transferred if the destination does not exist.",
            "type": "string"
          },
          "group": {
            "description": "name of the group that should own the file/directory, as would be fed to `chown'",
            "type": "string"
          },
          "mode": {
            "description": "mode the file or directory should be. For those used to `/usr/bin/chmod' remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, `u+rwx' or `u=rw,g=r,o=r').",
            "type": "string"
          },
          "owner": {
            "description": "name of the user that should own the file/directory, as would be fed to `chown'",
            "type": "string"
          },
          "remote_src": {
            "description": "If False, it will search for src at originating/maste r machine, if True it will go to the remote/target machine for the src. Default is False. Currently remote_src does not support recursive copying.",
            "type": "string"
          },
          "selevel": {
            "description": "level part of the SELinux file context. This is the MLS/MCS attribute, sometimes known as the `range'. `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "serole": {
            "description": "role part of SELinux file context, `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "setype": {
            "description": "type part of SELinux file context, `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "seuser": {
            "description": "user part of SELinux file context. Will default to system policy, if applicable. If set to `_default', it will use the `user' portion of the policy if available",
            "type": "string"
          },
          "src": {
            "description": "Local path to a file to copy to the remote server; can be absolute or relative. If path is a directory, it is copied recursively. In this case, if path ends with \"/\", only inside contents of that directory are copied to destination. Otherwise, if it does not end with \"/\", the directory itself with all contents is copied. This behavior is similar to Rsync.",
            "type": "string"
          },
          "unsafe_writes": {
            "description": "Normally this module uses atomic operations to prevent data corruption or inconsistent reads from the target files, sometimes systems are configured or just broken in ways that prevent this. One example are docker mounted files, they cannot be updated atomically and can only be done in an unsafe manner. This boolean option allows ansible to fall back to unsafe methods of updating files for those cases in which you do not have any other choice. Be aware that this is subject to race conditions and can lead to data corruption.",
            "type": "string"
          },
          "validate": {
            "description": "The validation command to run before copying into place. The path to the file to validate is passed in via '%s' which must be present as in the example below. The command is passed securely so shell features like expansion and pipes won't work.",
            "type": "string"
          }
        },
        "required": "dest"
      }
    },
    {
      "cpanm": {
        "type": "object",
        "description": "Manages Perl library dependencies.",
        "properties": {
          "executable": {
            "description": "Override the path to the cpanm executable",
            "type": "string"
          },
          "from_path": {
            "description": "The local directory from where to install",
            "type": "string"
          },
          "installdeps": {
            "description": "Only install dependencies",
            "type": "string"
          },
          "locallib": {
            "description": "Specify the install base to install modules",
            "type": "string"
          },
          "mirror": {
            "description": "Specifies the base URL for the CPAN mirror to use",
            "type": "string"
          },
          "mirror_only": {
            "description": "Use the mirror's index file instead of the CPAN Meta DB",
            "type": "string"
          },
          "name": {
            "description": "The name of the Perl library to install. You may use the \"full distribution path\", e.g.  MIYA GAWA/Plack-0.99_0 5.tar.gz",
            "type": "string"
          },
          "notest": {
            "description": "Do not run unit tests",
            "type": "string"
          },
          "system_lib": {
            "description": "Use this if you want to install modules to the system perl include path. You must be root or have \"passwordless\" sudo for this to work. This uses the cpanm commandline option '--sudo', which has nothing to do with ansible privilege escalation.",
            "type": "string"
          },
          "version": {
            "description": "minimum version of perl module to consider acceptable",
            "type": "string"
          }
        }
      }
    },
    {
      "cron": {
        "type": "object",
        "description": "Manage cron.d and crontab entries.",
        "properties": {
          "backup": {
            "description": "If set, create a backup of the crontab before it is modified. The location of the backup is returned in the `backup_file' variable by this module.",
            "type": "string"
          },
          "cron_file": {
            "description": "If specified, uses this file instead of an individual user's crontab. If this is a relative path, it is interpreted with respect to /etc/cron.d. (If it is absolute, it will typically be /etc/crontab). To use the `cron_file' parameter you must specify the `user' as well.",
            "type": "string"
          },
          "day": {
            "description": "Day of the month the job should run ( 1-31, *, */2, etc )",
            "type": "string"
          },
          "disabled": {
            "description": "If the job should be disabled (commented out) in the crontab. Only has effect if state=present",
            "type": "string"
          },
          "env": {
            "description": "If set, manages a crontab's environment variable. New variables are added on top of crontab. \"name\" and \"value\" parameters are the name and the value of environment variable.",
            "type": "string"
          },
          "hour": {
            "description": "Hour when the job should run ( 0-23, *, */2, etc )",
            "type": "string"
          },
          "insertafter": {
            "description": "Used with `state=present' and `env'. If specified, the environment variable will be inserted after the declaration of specified environment variable.",
            "type": "string"
          },
          "insertbefore": {
            "description": "Used with `state=present' and `env'. If specified, the environment variable will be inserted before the declaration of specified environment variable.",
            "type": "string"
          },
          "job": {
            "description": "The command to execute or, if env is set, the value of environment variable. Required if state=present.",
            "type": "string"
          },
          "minute": {
            "description": "Minute when the job should run ( 0-59, *, */2, etc )",
            "type": "string"
          },
          "month": {
            "description": "Month of the year the job should run ( 1-12, *, */2, etc )",
            "type": "string"
          },
          "name": {
            "description": "Description of a crontab entry or, if env is set, the name of environment variable. Required if state=absent. Note that if name is not set and state=present, then a new crontab entry will always be created, regardless of existing ones.",
            "type": "string"
          },
          "reboot": {
            "description": "If the job should be run at reboot. This option is deprecated. Users should use special_time.",
            "type": "string"
          },
          "special_time": {
            "description": "Special time specification nickname.",
            "type": "string"
          },
          "state": {
            "description": "Whether to ensure the job or environment variable is present or absent.",
            "type": "string"
          },
          "user": {
            "description": "The specific user whose crontab should be modified.",
            "type": "string"
          },
          "weekday": {
            "description": "Day of the week that the job should run ( 0-6 for Sunday- Saturday, *, etc )",
            "type": "string"
          }
        }
      }
    },
    {
      "cronvar": {
        "type": "object",
        "description": "Manage variables in crontabs",
        "properties": {
          "backup": {
            "description": "If set, create a backup of the crontab before it is modified. The location of the backup is returned in the `backup' variable by this module.",
            "type": "string"
          },
          "cron_file": {
            "description": "If specified, uses this file instead of an individual user's crontab. Without a leading /, this is assumed to be in /etc/cron.d. With a leading /, this is taken as absolute.",
            "type": "string"
          },
          "insertafter": {
            "description": "Used with `state=present'. If specified, the variable will be inserted after the variable specified.",
            "type": "string"
          },
          "insertbefore": {
            "description": "Used with `state=present'. If specified, the variable will be inserted just before the variable specified.",
            "type": "string"
          },
          "name": {
            "description": "Name of the crontab variable.",
            "type": "string"
          },
          "state": {
            "description": "Whether to ensure that the variable is present or absent.",
            "type": "string"
          },
          "user": {
            "description": "The specific user whose crontab should be modified.",
            "type": "string"
          },
          "value": {
            "description": "The value to set this variable to.  Required if state=present.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "crypttab": {
        "type": "object",
        "description": "Encrypted Linux block devices",
        "properties": {
          "backing_device": {
            "description": "Path to the underlying block device or file, or the UUID of a block-device prefixed with `UUID='",
            "type": "string"
          },
          "name": {
            "description": "Name of the encrypted block device as it appears in the `/etc/crypttab' file, or optionaly prefixed with `/dev/mapper/', as it appears in the filesystem. `/dev/mapper/' will be stripped from `name'.",
            "type": "string"
          },
          "opts": {
            "description": "A comma-delimited list of options. See `crypttab(5' ) for details.",
            "type": "string"
          },
          "password": {
            "description": "Encryption password, the path to a file containing the pasword, or 'none' or '-' if the password should be entered at boot.",
            "type": "string"
          },
          "path": {
            "description": "Path to file to use instead of `/etc/crypttab'. This might be useful in a chroot environment.",
            "type": "string"
          },
          "state": {
            "description": "Use `present' to add a line to `/etc/crypttab' or update it's definition if already present. Use `absent' to remove a line with matching `name'. Use `opts_present' to add options to those already present; options with different values will be updated. Use `opts_absent' to remove options from the existing set.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "state"
        ]
      }
    },
    {
      "cs_account": {
        "type": "object",
        "description": "Manages accounts on Apache CloudStack based clouds.",
        "properties": {
          "account_type": {
            "description": "Type of the account.",
            "type": "string"
          },
          "api_http_method": {
            "description": "HTTP method used.",
            "type": "string"
          },
          "api_key": {
            "description": "API key of the CloudStack API.",
            "type": "string"
          },
          "api_region": {
            "description": "Name of the ini section in the `cloustack.ini' file.",
            "type": "string"
          },
          "api_secret": {
            "description": "Secret key of the CloudStack API.",
            "type": "string"
          },
          "api_timeout": {
            "description": "HTTP timeout.",
            "type": "string"
          },
          "api_url": {
            "description": "URL of the CloudStack API e.g. https://cloud.exa mple.com/client/a pi.",
            "type": "string"
          },
          "domain": {
            "description": "Domain the account is related to.",
            "type": "string"
          },
          "email": {
            "description": "Email of the user to be created if account did not exist. Required on `state=present'.",
            "type": "string"
          },
          "first_name": {
            "description": "First name of the user to be created if account did not exist. Required on `state=present'.",
            "type": "string"
          },
          "last_name": {
            "description": "Last name of the user to be created if account did not exist. Required on `state=present'.",
            "type": "string"
          },
          "name": {
            "description": "Name of account.",
            "type": "string"
          },
          "network_domain": {
            "description": "Network domain of the account.",
            "type": "string"
          },
          "password": {
            "description": "Password of the user to be created if account did not exist. Required on `state=present'.",
            "type": "string"
          },
          "poll_async": {
            "description": "Poll async jobs until job has finished.",
            "type": "string"
          },
          "state": {
            "description": "State of the account. `unlocked' is an alias for `enabled'.",
            "type": "string"
          },
          "timezone": {
            "description": "Timezone of the user to be created if account did not exist.",
            "type": "string"
          },
          "username": {
            "description": "Username of the user to be created if account did not exist. Required on `state=present'.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "cs_affinitygroup": {
        "type": "object",
        "description": "Manages affinity groups on Apache CloudStack based clouds.",
        "properties": {
          "account": {
            "description": "Account the affinity group is related to.",
            "type": "string"
          },
          "affinty_type": {
            "description": "Type of the affinity group. If not specified, first found affinity type is used.",
            "type": "string"
          },
          "api_http_method": {
            "description": "HTTP method used.",
            "type": "string"
          },
          "api_key": {
            "description": "API key of the CloudStack API.",
            "type": "string"
          },
          "api_region": {
            "description": "Name of the ini section in the `cloustack.ini' file.",
            "type": "string"
          },
          "api_secret": {
            "description": "Secret key of the CloudStack API.",
            "type": "string"
          },
          "api_timeout": {
            "description": "HTTP timeout.",
            "type": "string"
          },
          "api_url": {
            "description": "URL of the CloudStack API e.g. https://cloud.exa mple.com/client/a pi.",
            "type": "string"
          },
          "description": {
            "description": "Description of the affinity group.",
            "type": "string"
          },
          "domain": {
            "description": "Domain the affinity group is related to.",
            "type": "string"
          },
          "name": {
            "description": "Name of the affinity group.",
            "type": "string"
          },
          "poll_async": {
            "description": "Poll async jobs until job has finished.",
            "type": "string"
          },
          "project": {
            "description": "Name of the project the affinity group is related to.",
            "type": "string"
          },
          "state": {
            "description": "State of the affinity group.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "cs_cluster": {
        "type": "object",
        "description": "Manages host clusters on Apache CloudStack based clouds.",
        "properties": {
          "api_http_method": {
            "description": "HTTP method used.",
            "type": "string"
          },
          "api_key": {
            "description": "API key of the CloudStack API.",
            "type": "string"
          },
          "api_region": {
            "description": "Name of the ini section in the `cloustack.ini' file.",
            "type": "string"
          },
          "api_secret": {
            "description": "Secret key of the CloudStack API.",
            "type": "string"
          },
          "api_timeout": {
            "description": "HTTP timeout.",
            "type": "string"
          },
          "api_url": {
            "description": "URL of the CloudStack API e.g. https://cloud.exa mple.com/client/a pi.",
            "type": "string"
          },
          "cluster_type": {
            "description": "Type of the cluster. Required if `state=present'",
            "type": "string"
          },
          "guest_vswitch_name": {
            "description": "Name of virtual switch used for guest traffic in the cluster. This would override zone wide traffic label setting.",
            "type": "string"
          },
          "guest_vswitch_type": {
            "description": "Type of virtual switch used for guest traffic in the cluster. Allowed values are, vmwaresvs (for VMware standard vSwitch) and vmwaredvs (for VMware distributed vSwitch)",
            "type": "string"
          },
          "hypervisor": {
            "description": "Name the hypervisor to be used. Required if `state=present'.",
            "type": "string"
          },
          "name": {
            "description": "name of the cluster.",
            "type": "string"
          },
          "ovm3_cluster": {
            "description": "Ovm3 native OCFS2 clustering enabled for cluster.",
            "type": "string"
          },
          "ovm3_pool": {
            "description": "Ovm3 native pooling enabled for cluster.",
            "type": "string"
          },
          "ovm3_vip": {
            "description": "Ovm3 vip to use for pool (and cluster).",
            "type": "string"
          },
          "password": {
            "description": "Password for the cluster.",
            "type": "string"
          },
          "pod": {
            "description": "Name of the pod in which the cluster belongs to.",
            "type": "string"
          },
          "public_vswitch_name": {
            "description": "Name of virtual switch used for public traffic in the cluster. This would override zone wide traffic label setting.",
            "type": "string"
          },
          "public_vswitch_type": {
            "description": "Type of virtual switch used for public traffic in the cluster. Allowed values are, vmwaresvs (for VMware standard vSwitch) and vmwaredvs (for VMware distributed vSwitch)",
            "type": "string"
          },
          "state": {
            "description": "State of the cluster.",
            "type": "string"
          },
          "url": {
            "description": "URL for the cluster",
            "type": "string"
          },
          "username": {
            "description": "Username for the cluster.",
            "type": "string"
          },
          "vms_ip_address": {
            "description": "IP address of the VSM associated with this cluster.",
            "type": "string"
          },
          "vms_password": {
            "description": "Password for the VSM associated with this cluster.",
            "type": "string"
          },
          "vms_username": {
            "description": "Username for the VSM associated with this cluster.",
            "type": "string"
          },
          "zone": {
            "description": "Name of the zone in which the cluster belongs to. If not set, default zone is used.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "cs_configuration": {
        "type": "object",
        "description": "Manages configuration on Apache CloudStack based clouds.",
        "properties": {
          "account": {
            "description": "Ensure the value for corresponding account.",
            "type": "string"
          },
          "api_http_method": {
            "description": "HTTP method used.",
            "type": "string"
          },
          "api_key": {
            "description": "API key of the CloudStack API.",
            "type": "string"
          },
          "api_region": {
            "description": "Name of the ini section in the `cloustack.ini' file.",
            "type": "string"
          },
          "api_secret": {
            "description": "Secret key of the CloudStack API.",
            "type": "string"
          },
          "api_timeout": {
            "description": "HTTP timeout.",
            "type": "string"
          },
          "api_url": {
            "description": "URL of the CloudStack API e.g. https://cloud.exa mple.com/client/a pi.",
            "type": "string"
          },
          "cluster": {
            "description": "Ensure the value for corresponding cluster.",
            "type": "string"
          },
          "domain": {
            "description": "Domain the account is related to. Only considered if `account' is used.",
            "type": "string"
          },
          "name": {
            "description": "Name of the configuration.",
            "type": "string"
          },
          "storage": {
            "description": "Ensure the value for corresponding storage pool.",
            "type": "string"
          },
          "value": {
            "description": "Value of the configuration.",
            "type": "string"
          },
          "zone": {
            "description": "Ensure the value for corresponding zone.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "value"
        ]
      }
    },
    {
      "cs_domain": {
        "type": "object",
        "description": "Manages domains on Apache CloudStack based clouds.",
        "properties": {
          "api_http_method": {
            "description": "HTTP method used.",
            "type": "string"
          },
          "api_key": {
            "description": "API key of the CloudStack API.",
            "type": "string"
          },
          "api_region": {
            "description": "Name of the ini section in the `cloustack.ini' file.",
            "type": "string"
          },
          "api_secret": {
            "description": "Secret key of the CloudStack API.",
            "type": "string"
          },
          "api_timeout": {
            "description": "HTTP timeout.",
            "type": "string"
          },
          "api_url": {
            "description": "URL of the CloudStack API e.g. https://cloud.exa mple.com/client/a pi.",
            "type": "string"
          },
          "clean_up": {
            "description": "Clean up all domain resources like child domains and accounts. Considered on `state=absent'.",
            "type": "string"
          },
          "network_domain": {
            "description": "Network domain for networks in the domain.",
            "type": "string"
          },
          "path": {
            "description": "Path of the domain. Prefix `ROOT/' or `/ROOT/' in path is optional.",
            "type": "string"
          },
          "poll_async": {
            "description": "Poll async jobs until job has finished.",
            "type": "string"
          },
          "state": {
            "description": "State of the domain.",
            "type": "string"
          }
        },
        "required": "path"
      }
    },
    {
      "cs_facts": {
        "type": "object",
        "description": "Gather facts on instances of Apache CloudStack based clouds.",
        "properties": {
          "filter": {
            "description": "Filter for a specific fact.",
            "type": "string"
          }
        }
      }
    },
    {
      "cs_firewall": {
        "type": "object",
        "description": "Manages firewall rules on Apache CloudStack based clouds.",
        "properties": {
          "account": {
            "description": "Account the firewall rule is related to.",
            "type": "string"
          },
          "api_http_method": {
            "description": "HTTP method used.",
            "type": "string"
          },
          "api_key": {
            "description": "API key of the CloudStack API.",
            "type": "string"
          },
          "api_region": {
            "description": "Name of the ini section in the `cloustack.ini' file.",
            "type": "string"
          },
          "api_secret": {
            "description": "Secret key of the CloudStack API.",
            "type": "string"
          },
          "api_timeout": {
            "description": "HTTP timeout.",
            "type": "string"
          },
          "api_url": {
            "description": "URL of the CloudStack API e.g. https://cloud.exa mple.com/client/a pi.",
            "type": "string"
          },
          "cidr": {
            "description": "CIDR (full notation) to be used for firewall rule.",
            "type": "string"
          },
          "domain": {
            "description": "Domain the firewall rule is related to.",
            "type": "string"
          },
          "end_port": {
            "description": "End port for this rule. Considered if `protocol=tcp' or `protocol=udp'. If not specified, equal `start_port'.",
            "type": "string"
          },
          "icmp_code": {
            "description": "Error code for this icmp message. Considered if `protocol=icmp'.",
            "type": "string"
          },
          "icmp_type": {
            "description": "Type of the icmp message being sent. Considered if `protocol=icmp'.",
            "type": "string"
          },
          "ip_address": {
            "description": "Public IP address the ingress rule is assigned to. Required if `type=ingress'.",
            "type": "string"
          },
          "network": {
            "description": "Network the egress rule is related to. Required if `type=egress'.",
            "type": "string"
          },
          "poll_async": {
            "description": "Poll async jobs until job has finished.",
            "type": "string"
          },
          "project": {
            "description": "Name of the project the firewall rule is related to.",
            "type": "string"
          },
          "protocol": {
            "description": "Protocol of the firewall rule. `all' is only available if `type=egress'",
            "type": "string"
          },
          "start_port": {
            "description": "Start port for this rule. Considered if `protocol=tcp' or `protocol=udp'.",
            "type": "string"
          },
          "state": {
            "description": "State of the firewall rule.",
            "type": "string"
          },
          "type": {
            "description": "Type of the firewall rule.",
            "type": "string"
          },
          "zone": {
            "description": "Name of the zone in which the virtual machine is in. If not set, default zone is used.",
            "type": "string"
          }
        }
      }
    },
    {
      "cs_instance": {
        "type": "object",
        "description": "Manages instances and virtual machines on Apache CloudStack based clouds.",
        "properties": {
          "account": {
            "description": "Account the instance is related to.",
            "type": "string"
          },
          "affinity_groups": {
            "description": "Affinity groups names to be applied to the new instance.",
            "type": "string"
          },
          "api_http_method": {
            "description": "HTTP method used.",
            "type": "string"
          },
          "api_key": {
            "description": "API key of the CloudStack API.",
            "type": "string"
          },
          "api_region": {
            "description": "Name of the ini section in the `cloustack.ini' file.",
            "type": "string"
          },
          "api_secret": {
            "description": "Secret key of the CloudStack API.",
            "type": "string"
          },
          "api_timeout": {
            "description": "HTTP timeout.",
            "type": "string"
          },
          "api_url": {
            "description": "URL of the CloudStack API e.g. https://cloud.exa mple.com/client/a pi.",
            "type": "string"
          },
          "cpu": {
            "description": "The number of CPUs to allocate to the instance, used with custom service offerings",
            "type": "string"
          },
          "cpu_speed": {
            "description": "The clock speed/shares allocated to the instance, used with custom service offerings",
            "type": "string"
          },
          "disk_offering": {
            "description": "Name of the disk offering to be used.",
            "type": "string"
          },
          "disk_size": {
            "description": "Disk size in GByte required if deploying instance from ISO.",
            "type": "string"
          },
          "display_name": {
            "description": "Custom display name of the instances. Display name will be set to `name' if not specified. Either `name' or `display_name' is required.",
            "type": "string"
          },
          "domain": {
            "description": "Domain the instance is related to.",
            "type": "string"
          },
          "force": {
            "description": "Force stop/start the instance if required to apply changes, otherwise a running instance will not be changed.",
            "type": "string"
          },
          "group": {
            "description": "Group in where the new instance should be in.",
            "type": "string"
          },
          "hypervisor": {
            "description": "Name the hypervisor to be used for creating the new instance. Relevant when using `state=present', but only considered if not set on ISO/template. If not set or found on ISO/template, first found hypervisor will be used.",
            "type": "string"
          },
          "ip6_address": {
            "description": "IPv6 address for default instance's network.",
            "type": "string"
          },
          "ip_address": {
            "description": "IPv4 address for default instance's network during creation.",
            "type": "string"
          },
          "ip_to_networks": {
            "description": "List of mappings in the form {'network': NetworkName, 'ip': 1.2.3.4} Mutually exclusive with `networks' option.",
            "type": "string"
          },
          "iso": {
            "description": "Name or id of the ISO to be used for creating the new instance. Required when using `state=present'. Mutually exclusive with `template' option.",
            "type": "string"
          },
          "keyboard": {
            "description": "Keyboard device type for the instance.",
            "type": "string"
          },
          "memory": {
            "description": "The memory allocated to the instance, used with custom service offerings",
            "type": "string"
          },
          "name": {
            "description": "Host name of the instance. `name' can only contain ASCII letters. Name will be generated (UUID) by CloudStack if not specified and can not be changed afterwards. Either `name' or `display_name' is required.",
            "type": "string"
          },
          "networks": {
            "description": "List of networks to use for the new instance.",
            "type": "string"
          },
          "poll_async": {
            "description": "Poll async jobs until job has finished.",
            "type": "string"
          },
          "project": {
            "description": "Name of the project the instance to be deployed in.",
            "type": "string"
          },
          "root_disk_size": {
            "description": "Root disk size in GByte required if deploying instance with KVM hypervisor and want resize the root disk size at startup (need CloudStack >= 4.4, cloud- initramfs- growroot installed and enabled in the template)",
            "type": "string"
          },
          "security_groups": {
            "description": "List of security groups the instance to be applied to.",
            "type": "string"
          },
          "service_offering": {
            "description": "Name or id of the service offering of the new instance. If not set, first found service offering is used.",
            "type": "string"
          },
          "ssh_key": {
            "description": "Name of the SSH key to be deployed on the new instance.",
            "type": "string"
          },
          "state": {
            "description": "State of the instance.",
            "type": "string"
          },
          "tags": {
            "description": "List of tags. Tags are a list of dictionaries having keys `key' and `value'. If you want to delete all tags, set a empty list e.g. `tags: []'.",
            "type": "string"
          },
          "template": {
            "description": "Name or id of the template to be used for creating the new instance. Required when using `state=present'. Mutually exclusive with `ISO' option.",
            "type": "string"
          },
          "template_filter": {
            "description": "Name of the filter used to search for the template or iso. Used for params `iso' or `template' on `state=present'.",
            "type": "string"
          },
          "user_data": {
            "description": "Optional data (ASCII) that can be sent to the instance upon a successful deployment. The data will be automatically base64 encoded. Consider switching to HTTP_POST by using `CLOUDSTACK _METHOD=post' to increase the HTTP_GET size limit of 2KB to 32 KB.",
            "type": "string"
          },
          "zone": {
            "description": "Name of the zone in which the instance shoud be deployed. If not set, default zone is used.",
            "type": "string"
          }
        }
      }
    },
    {
      "cs_instance_facts": {
        "type": "object",
        "description": "Gathering facts from the API of instances from Apache CloudStack based clouds.",
        "properties": {
          "account": {
            "description": "Account the instance is related to.",
            "type": "string"
          },
          "api_http_method": {
            "description": "HTTP method used.",
            "type": "string"
          },
          "api_key": {
            "description": "API key of the CloudStack API.",
            "type": "string"
          },
          "api_region": {
            "description": "Name of the ini section in the `cloustack.ini' file.",
            "type": "string"
          },
          "api_secret": {
            "description": "Secret key of the CloudStack API.",
            "type": "string"
          },
          "api_timeout": {
            "description": "HTTP timeout.",
            "type": "string"
          },
          "api_url": {
            "description": "URL of the CloudStack API e.g. https://cloud.exa mple.com/client/a pi.",
            "type": "string"
          },
          "domain": {
            "description": "Domain the instance is related to.",
            "type": "string"
          },
          "name": {
            "description": "Name or display name of the instance.",
            "type": "string"
          },
          "project": {
            "description": "Project the instance is related to.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "cs_instancegroup": {
        "type": "object",
        "description": "Manages instance groups on Apache CloudStack based clouds.",
        "properties": {
          "account": {
            "description": "Account the instance group is related to.",
            "type": "string"
          },
          "api_http_method": {
            "description": "HTTP method used.",
            "type": "string"
          },
          "api_key": {
            "description": "API key of the CloudStack API.",
            "type": "string"
          },
          "api_region": {
            "description": "Name of the ini section in the `cloustack.ini' file.",
            "type": "string"
          },
          "api_secret": {
            "description": "Secret key of the CloudStack API.",
            "type": "string"
          },
          "api_timeout": {
            "description": "HTTP timeout.",
            "type": "string"
          },
          "api_url": {
            "description": "URL of the CloudStack API e.g. https://cloud.exa mple.com/client/a pi.",
            "type": "string"
          },
          "domain": {
            "description": "Domain the instance group is related to.",
            "type": "string"
          },
          "name": {
            "description": "Name of the instance group.",
            "type": "string"
          },
          "project": {
            "description": "Project the instance group is related to.",
            "type": "string"
          },
          "state": {
            "description": "State of the instance group.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "cs_ip_address": {
        "type": "object",
        "description": "Manages public IP address associations on Apache CloudStack based clouds.",
        "properties": {
          "account": {
            "description": "Account the IP address is related to.",
            "type": "string"
          },
          "api_http_method": {
            "description": "HTTP method used.",
            "type": "string"
          },
          "api_key": {
            "description": "API key of the CloudStack API.",
            "type": "string"
          },
          "api_region": {
            "description": "Name of the ini section in the `cloustack.ini' file.",
            "type": "string"
          },
          "api_secret": {
            "description": "Secret key of the CloudStack API.",
            "type": "string"
          },
          "api_timeout": {
            "description": "HTTP timeout.",
            "type": "string"
          },
          "api_url": {
            "description": "URL of the CloudStack API e.g. https://cloud.exa mple.com/client/a pi.",
            "type": "string"
          },
          "domain": {
            "description": "Domain the IP address is related to.",
            "type": "string"
          },
          "ip_address": {
            "description": "Public IP address. Required if `state=absent'",
            "type": "string"
          },
          "network": {
            "description": "Network the IP address is related to.",
            "type": "string"
          },
          "poll_async": {
            "description": "Poll async jobs until job has finished.",
            "type": "string"
          },
          "project": {
            "description": "Name of the project the IP address is related to.",
            "type": "string"
          },
          "vpc": {
            "description": "VPC the IP address is related to.",
            "type": "string"
          },
          "zone": {
            "description": "Name of the zone in which the IP address is in. If not set, default zone is used.",
            "type": "string"
          }
        }
      }
    },
    {
      "cs_iso": {
        "type": "object",
        "description": "Manages ISO images on Apache CloudStack based clouds.",
        "properties": {
          "account": {
            "description": "Account the ISO is related to.",
            "type": "string"
          },
          "api_http_method": {
            "description": "HTTP method used.",
            "type": "string"
          },
          "api_key": {
            "description": "API key of the CloudStack API.",
            "type": "string"
          },
          "api_region": {
            "description": "Name of the ini section in the `cloustack.ini' file.",
            "type": "string"
          },
          "api_secret": {
            "description": "Secret key of the CloudStack API.",
            "type": "string"
          },
          "api_timeout": {
            "description": "HTTP timeout.",
            "type": "string"
          },
          "api_url": {
            "description": "URL of the CloudStack API e.g. https://cloud.exa mple.com/client/a pi.",
            "type": "string"
          },
          "bootable": {
            "description": "Register the ISO to be bootable. Only used if `state' is present.",
            "type": "string"
          },
          "checksum": {
            "description": "The MD5 checksum value of this ISO. If set, we search by checksum instead of name.",
            "type": "string"
          },
          "domain": {
            "description": "Domain the ISO is related to.",
            "type": "string"
          },
          "is_dynamically_scalable": {
            "description": "Register the ISO having XS/VMWare tools installed inorder to support dynamic scaling of VM cpu/memory. Only used if `state' is present.",
            "type": "string"
          },
          "is_featured": {
            "description": "Register the ISO to be featured. Only used if `state' is present.",
            "type": "string"
          },
          "is_public": {
            "description": "Register the ISO to be publicly available to all users. Only used if `state' is present.",
            "type": "string"
          },
          "is_ready": {
            "description": "This flag is used for searching existing ISOs. If set to `true', it will only list ISO ready for deployment e.g. successfully downloaded and installed. Recommended to set it to `false'.",
            "type": "string"
          },
          "iso_filter": {
            "description": "Name of the filter used to search for the ISO.",
            "type": "string"
          },
          "name": {
            "description": "Name of the ISO.",
            "type": "string"
          },
          "os_type": {
            "description": "Name of the OS that best represents the OS of this ISO. If the iso is bootable this parameter needs to be passed. Required if `state' is present.",
            "type": "string"
          },
          "project": {
            "description": "Name of the project the ISO to be registered in.",
            "type": "string"
          },
          "state": {
            "description": "State of the ISO.",
            "type": "string"
          },
          "url": {
            "description": "URL where the ISO can be downloaded from. Required if `state' is present.",
            "type": "string"
          },
          "zone": {
            "description": "Name of the zone you wish the ISO to be registered or deleted from. If not specified, first zone found will be used.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "cs_loadbalancer_rule": {
        "type": "object",
        "description": "Manages load balancer rules on Apache CloudStack based clouds.",
        "properties": {
          "account": {
            "description": "Account the rule is related to.",
            "type": "string"
          },
          "algorithm": {
            "description": "Load balancer algorithm Required when using `state=present'.",
            "type": "string"
          },
          "api_http_method": {
            "description": "HTTP method used.",
            "type": "string"
          },
          "api_key": {
            "description": "API key of the CloudStack API.",
            "type": "string"
          },
          "api_region": {
            "description": "Name of the ini section in the `cloustack.ini' file.",
            "type": "string"
          },
          "api_secret": {
            "description": "Secret key of the CloudStack API.",
            "type": "string"
          },
          "api_timeout": {
            "description": "HTTP timeout.",
            "type": "string"
          },
          "api_url": {
            "description": "URL of the CloudStack API e.g. https://cloud.exa mple.com/client/a pi.",
            "type": "string"
          },
          "cidr": {
            "description": "CIDR (full notation) to be used for firewall rule if required.",
            "type": "string"
          },
          "description": {
            "description": "The description of the load balancer rule.",
            "type": "string"
          },
          "domain": {
            "description": "Domain the rule is related to.",
            "type": "string"
          },
          "ip_address": {
            "description": "Public IP address from where the network traffic will be load balanced from.",
            "type": "string"
          },
          "name": {
            "description": "The name of the load balancer rule.",
            "type": "string"
          },
          "open_firewall": {
            "description": "Whether the firewall rule for public port should be created, while creating the new rule. Use [cs_firewall] for managing firewall rules.",
            "type": "string"
          },
          "private_port": {
            "description": "The private port of the private ip address/virtual machine where the network traffic will be load balanced to. Required when using `state=present'. Can not be changed once the rule exists due API limitation.",
            "type": "string"
          },
          "project": {
            "description": "Name of the project the load balancer IP address is related to.",
            "type": "string"
          },
          "protocol": {
            "description": "The protocol to be used on the load balancer",
            "type": "string"
          },
          "public_port": {
            "description": "The public port from where the network traffic will be load balanced from. Required when using `state=present'. Can not be changed once the rule exists due API limitation.",
            "type": "string"
          },
          "state": {
            "description": "State of the rule.",
            "type": "string"
          },
          "zone": {
            "description": "Name of the zone in which the rule shoud be created. If not set, default zone is used.",
            "type": "string"
          }
        },
        "required": [
          "ip_address",
          "name",
          "public_port",
          "state"
        ]
      }
    },
    {
      "cs_loadbalancer_rule_member": {
        "type": "object",
        "description": "Manages load balancer rule members on Apache CloudStack based clouds.",
        "properties": {
          "account": {
            "description": "Account the rule is related to.",
            "type": "string"
          },
          "api_http_method": {
            "description": "HTTP method used.",
            "type": "string"
          },
          "api_key": {
            "description": "API key of the CloudStack API.",
            "type": "string"
          },
          "api_region": {
            "description": "Name of the ini section in the `cloustack.ini' file.",
            "type": "string"
          },
          "api_secret": {
            "description": "Secret key of the CloudStack API.",
            "type": "string"
          },
          "api_timeout": {
            "description": "HTTP timeout.",
            "type": "string"
          },
          "api_url": {
            "description": "URL of the CloudStack API e.g. https://cloud.exa mple.com/client/a pi.",
            "type": "string"
          },
          "domain": {
            "description": "Domain the rule is related to.",
            "type": "string"
          },
          "ip_address": {
            "description": "Public IP address from where the network traffic will be load balanced from. Only needed to find the rule if `name' is not unique.",
            "type": "string"
          },
          "name": {
            "description": "The name of the load balancer rule.",
            "type": "string"
          },
          "project": {
            "description": "Name of the project the firewall rule is related to.",
            "type": "string"
          },
          "state": {
            "description": "Should the VMs be present or absent from the rule.",
            "type": "string"
          },
          "vms": {
            "description": "List of VMs to assign to or remove from the rule.",
            "type": "string"
          },
          "zone": {
            "description": "Name of the zone in which the rule should be located. If not set, default zone is used.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "vms"
        ]
      }
    },
    {
      "cs_network": {
        "type": "object",
        "description": "Manages networks on Apache CloudStack based clouds.",
        "properties": {
          "account": {
            "description": "Account the network is related to.",
            "type": "string"
          },
          "acl_type": {
            "description": "Access control type. Only considered on create.",
            "type": "string"
          },
          "api_http_method": {
            "description": "HTTP method used.",
            "type": "string"
          },
          "api_key": {
            "description": "API key of the CloudStack API.",
            "type": "string"
          },
          "api_region": {
            "description": "Name of the ini section in the `cloustack.ini' file.",
            "type": "string"
          },
          "api_secret": {
            "description": "Secret key of the CloudStack API.",
            "type": "string"
          },
          "api_timeout": {
            "description": "HTTP timeout.",
            "type": "string"
          },
          "api_url": {
            "description": "URL of the CloudStack API e.g. https://cloud.exa mple.com/client/a pi.",
            "type": "string"
          },
          "cidr_ipv6": {
            "description": "CIDR of IPv6 network, must be at least /64. Only considered on create.",
            "type": "string"
          },
          "clean_up": {
            "description": "Cleanup old network elements. Only considered on `state=restarted' .",
            "type": "string"
          },
          "display_text": {
            "description": "Display text of the network. If not specified, `name' will be used as `display_text'.",
            "type": "string"
          },
          "domain": {
            "description": "Domain the network is related to.",
            "type": "string"
          },
          "end_ip": {
            "description": "The ending IPv4 address of the network belongs to. If not specified, value of `start_ip' is used. Only considered on create.",
            "type": "string"
          },
          "end_ipv6": {
            "description": "The ending IPv6 address of the network belongs to. If not specified, value of `start_ipv6' is used. Only considered on create.",
            "type": "string"
          },
          "gateway": {
            "description": "The gateway of the network. Required for shared networks and isolated networks when it belongs to a VPC. Only considered on create.",
            "type": "string"
          },
          "gateway_ipv6": {
            "description": "The gateway of the IPv6 network. Required for shared networks. Only considered on create.",
            "type": "string"
          },
          "isolated_pvlan": {
            "description": "The isolated private VLAN for this network.",
            "type": "string"
          },
          "name": {
            "description": "Name (case sensitive) of the network.",
            "type": "string"
          },
          "netmask": {
            "description": "The netmask of the network. Required for shared networks and isolated networks when it belongs to a VPC. Only considered on create.",
            "type": "string"
          },
          "network_domain": {
            "description": "The network domain.",
            "type": "string"
          },
          "network_offering": {
            "description": "Name of the offering for the network. Required if `state=present'.",
            "type": "string"
          },
          "poll_async": {
            "description": "Poll async jobs until job has finished.",
            "type": "string"
          },
          "project": {
            "description": "Name of the project the network to be deployed in.",
            "type": "string"
          },
          "start_ip": {
            "description": "The beginning IPv4 address of the network belongs to. Only considered on create.",
            "type": "string"
          },
          "start_ipv6": {
            "description": "The beginning IPv6 address of the network belongs to. Only considered on create.",
            "type": "string"
          },
          "state": {
            "description": "State of the network.",
            "type": "string"
          },
          "vlan": {
            "description": "The ID or VID of the network.",
            "type": "string"
          },
          "vpc": {
            "description": "Name of the VPC of the network.",
            "type": "string"
          },
          "zone": {
            "description": "Name of the zone in which the network should be deployed. If not set, default zone is used.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "cs_pod": {
        "type": "object",
        "description": "Manages pods on Apache CloudStack based clouds.",
        "properties": {
          "api_http_method": {
            "description": "HTTP method used.",
            "type": "string"
          },
          "api_key": {
            "description": "API key of the CloudStack API.",
            "type": "string"
          },
          "api_region": {
            "description": "Name of the ini section in the `cloustack.ini' file.",
            "type": "string"
          },
          "api_secret": {
            "description": "Secret key of the CloudStack API.",
            "type": "string"
          },
          "api_timeout": {
            "description": "HTTP timeout.",
            "type": "string"
          },
          "api_url": {
            "description": "URL of the CloudStack API e.g. https://cloud.exa mple.com/client/a pi.",
            "type": "string"
          },
          "end_ip": {
            "description": "Ending IP address for the Pod.",
            "type": "string"
          },
          "gateway": {
            "description": "Gateway for the Pod. Required on `state=present'",
            "type": "string"
          },
          "id": {
            "description": "uuid of the exising pod.",
            "type": "string"
          },
          "name": {
            "description": "Name of the pod.",
            "type": "string"
          },
          "netmask": {
            "description": "Netmask for the Pod. Required on `state=present'",
            "type": "string"
          },
          "start_ip": {
            "description": "Starting IP address for the Pod. Required on `state=present'",
            "type": "string"
          },
          "state": {
            "description": "State of the pod.",
            "type": "string"
          },
          "zone": {
            "description": "Name of the zone in which the pod belongs to. If not set, default zone is used.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "cs_portforward": {
        "type": "object",
        "description": "Manages port forwarding rules on Apache CloudStack based clouds.",
        "properties": {
          "account": {
            "description": "Account the `vm' is related to.",
            "type": "string"
          },
          "api_http_method": {
            "description": "HTTP method used.",
            "type": "string"
          },
          "api_key": {
            "description": "API key of the CloudStack API.",
            "type": "string"
          },
          "api_region": {
            "description": "Name of the ini section in the `cloustack.ini' file.",
            "type": "string"
          },
          "api_secret": {
            "description": "Secret key of the CloudStack API.",
            "type": "string"
          },
          "api_timeout": {
            "description": "HTTP timeout.",
            "type": "string"
          },
          "api_url": {
            "description": "URL of the CloudStack API e.g. https://cloud.exa mple.com/client/a pi.",
            "type": "string"
          },
          "domain": {
            "description": "Domain the `vm' is related to.",
            "type": "string"
          },
          "ip_address": {
            "description": "Public IP address the rule is assigned to.",
            "type": "string"
          },
          "open_firewall": {
            "description": "Whether the firewall rule for public port should be created, while creating the new rule. Use [cs_firewall] for managing firewall rules.",
            "type": "string"
          },
          "poll_async": {
            "description": "Poll async jobs until job has finished.",
            "type": "string"
          },
          "private_end_port": {
            "description": "End private port for this rule. If not specified equal `private_port'.",
            "type": "string"
          },
          "private_port": {
            "description": "Start private port for this rule.",
            "type": "string"
          },
          "project": {
            "description": "Name of the project the `vm' is located in.",
            "type": "string"
          },
          "protocol": {
            "description": "Protocol of the port forwarding rule.",
            "type": "string"
          },
          "public_end_port": {
            "description": "End public port for this rule. If not specified equal `public_port'.",
            "type": "string"
          },
          "public_port": {
            "description": "Start public port for this rule.",
            "type": "string"
          },
          "state": {
            "description": "State of the port forwarding rule.",
            "type": "string"
          },
          "vm": {
            "description": "Name of virtual machine which we make the port forwarding rule for. Required if `state=present'.",
            "type": "string"
          },
          "vm_guest_ip": {
            "description": "VM guest NIC secondary IP address for the port forwarding rule.",
            "type": "string"
          },
          "zone": {
            "description": "Name of the zone in which the virtual machine is in. If not set, default zone is used.",
            "type": "string"
          }
        },
        "required": [
          "ip_address",
          "private_port",
          "public_port"
        ]
      }
    },
    {
      "cs_project": {
        "type": "object",
        "description": "Manages projects on Apache CloudStack based clouds.",
        "properties": {
          "account": {
            "description": "Account the project is related to.",
            "type": "string"
          },
          "api_http_method": {
            "description": "HTTP method used.",
            "type": "string"
          },
          "api_key": {
            "description": "API key of the CloudStack API.",
            "type": "string"
          },
          "api_region": {
            "description": "Name of the ini section in the `cloustack.ini' file.",
            "type": "string"
          },
          "api_secret": {
            "description": "Secret key of the CloudStack API.",
            "type": "string"
          },
          "api_timeout": {
            "description": "HTTP timeout.",
            "type": "string"
          },
          "api_url": {
            "description": "URL of the CloudStack API e.g. https://cloud.exa mple.com/client/a pi.",
            "type": "string"
          },
          "display_text": {
            "description": "Display text of the project. If not specified, `name' will be used as `display_text'.",
            "type": "string"
          },
          "domain": {
            "description": "Domain the project is related to.",
            "type": "string"
          },
          "name": {
            "description": "Name of the project.",
            "type": "string"
          },
          "poll_async": {
            "description": "Poll async jobs until job has finished.",
            "type": "string"
          },
          "state": {
            "description": "State of the project.",
            "type": "string"
          },
          "tags": {
            "description": "List of tags. Tags are a list of dictionaries having keys `key' and `value'. If you want to delete all tags, set a empty list e.g. `tags: []'.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "cs_resourcelimit": {
        "type": "object",
        "description": "Manages resource limits on Apache CloudStack based clouds.",
        "properties": {
          "account": {
            "description": "Account the resource is related to.",
            "type": "string"
          },
          "api_http_method": {
            "description": "HTTP method used.",
            "type": "string"
          },
          "api_key": {
            "description": "API key of the CloudStack API.",
            "type": "string"
          },
          "api_region": {
            "description": "Name of the ini section in the `cloustack.ini' file.",
            "type": "string"
          },
          "api_secret": {
            "description": "Secret key of the CloudStack API.",
            "type": "string"
          },
          "api_timeout": {
            "description": "HTTP timeout.",
            "type": "string"
          },
          "api_url": {
            "description": "URL of the CloudStack API e.g. https://cloud.exa mple.com/client/a pi.",
            "type": "string"
          },
          "domain": {
            "description": "Domain the resource is related to.",
            "type": "string"
          },
          "limit": {
            "description": "Maximum number of the resource. Default is unlimited `-1'.",
            "type": "string"
          },
          "project": {
            "description": "Name of the project the resource is related to.",
            "type": "string"
          },
          "resource_type": {
            "description": "Type of the resource.",
            "type": "string"
          }
        },
        "required": "resource_type"
      }
    },
    {
      "cs_router": {
        "type": "object",
        "description": "Manages routers on Apache CloudStack based clouds.",
        "properties": {
          "account": {
            "description": "Account the router is related to.",
            "type": "string"
          },
          "api_http_method": {
            "description": "HTTP method used.",
            "type": "string"
          },
          "api_key": {
            "description": "API key of the CloudStack API.",
            "type": "string"
          },
          "api_region": {
            "description": "Name of the ini section in the `cloustack.ini' file.",
            "type": "string"
          },
          "api_secret": {
            "description": "Secret key of the CloudStack API.",
            "type": "string"
          },
          "api_timeout": {
            "description": "HTTP timeout.",
            "type": "string"
          },
          "api_url": {
            "description": "URL of the CloudStack API e.g. https://cloud.exa mple.com/client/a pi.",
            "type": "string"
          },
          "domain": {
            "description": "Domain the router is related to.",
            "type": "string"
          },
          "name": {
            "description": "Name of the router.",
            "type": "string"
          },
          "project": {
            "description": "Name of the project the router is related to.",
            "type": "string"
          },
          "service_offering": {
            "description": "Name or id of the service offering of the router.",
            "type": "string"
          },
          "state": {
            "description": "State of the router.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "cs_securitygroup": {
        "type": "object",
        "description": "Manages security groups on Apache CloudStack based clouds.",
        "properties": {
          "account": {
            "description": "Account the security group is related to.",
            "type": "string"
          },
          "api_http_method": {
            "description": "HTTP method used.",
            "type": "string"
          },
          "api_key": {
            "description": "API key of the CloudStack API.",
            "type": "string"
          },
          "api_region": {
            "description": "Name of the ini section in the `cloustack.ini' file.",
            "type": "string"
          },
          "api_secret": {
            "description": "Secret key of the CloudStack API.",
            "type": "string"
          },
          "api_timeout": {
            "description": "HTTP timeout.",
            "type": "string"
          },
          "api_url": {
            "description": "URL of the CloudStack API e.g. https://cloud.exa mple.com/client/a pi.",
            "type": "string"
          },
          "description": {
            "description": "Description of the security group.",
            "type": "string"
          },
          "domain": {
            "description": "Domain the security group is related to.",
            "type": "string"
          },
          "name": {
            "description": "Name of the security group.",
            "type": "string"
          },
          "project": {
            "description": "Name of the project the security group to be created in.",
            "type": "string"
          },
          "state": {
            "description": "State of the security group.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "cs_securitygroup_rule": {
        "type": "object",
        "description": "Manages security group rules on Apache CloudStack based clouds.",
        "properties": {
          "api_http_method": {
            "description": "HTTP method used.",
            "type": "string"
          },
          "api_key": {
            "description": "API key of the CloudStack API.",
            "type": "string"
          },
          "api_region": {
            "description": "Name of the ini section in the `cloustack.ini' file.",
            "type": "string"
          },
          "api_secret": {
            "description": "Secret key of the CloudStack API.",
            "type": "string"
          },
          "api_timeout": {
            "description": "HTTP timeout.",
            "type": "string"
          },
          "api_url": {
            "description": "URL of the CloudStack API e.g. https://cloud.exa mple.com/client/a pi.",
            "type": "string"
          },
          "cidr": {
            "description": "CIDR (full notation) to be used for security group rule.",
            "type": "string"
          },
          "end_port": {
            "description": "End port for this rule. Required if `protocol=tcp' or `protocol=udp', but `start_port' will be used if not set.",
            "type": "string"
          },
          "icmp_code": {
            "description": "Error code for this icmp message. Required if `protocol=icmp'.",
            "type": "string"
          },
          "icmp_type": {
            "description": "Type of the icmp message being sent. Required if `protocol=icmp'.",
            "type": "string"
          },
          "poll_async": {
            "description": "Poll async jobs until job has finished.",
            "type": "string"
          },
          "project": {
            "description": "Name of the project the security group to be created in.",
            "type": "string"
          },
          "protocol": {
            "description": "Protocol of the security group rule.",
            "type": "string"
          },
          "security_group": {
            "description": "Name of the security group the rule is related to. The security group must be existing.",
            "type": "string"
          },
          "start_port": {
            "description": "Start port for this rule. Required if `protocol=tcp' or `protocol=udp'.",
            "type": "string"
          },
          "state": {
            "description": "State of the security group rule.",
            "type": "string"
          },
          "type": {
            "description": "Ingress or egress security group rule.",
            "type": "string"
          },
          "user_security_group": {
            "description": "Security group this rule is based of.",
            "type": "string"
          }
        },
        "required": "security_group"
      }
    },
    {
      "cs_snapshot_policy": {
        "type": "object",
        "description": "Manages volume snapshot policies on Apache CloudStack based clouds.",
        "properties": {
          "account": {
            "description": "Account the volume is related to.",
            "type": "string"
          },
          "api_http_method": {
            "description": "HTTP method used.",
            "type": "string"
          },
          "api_key": {
            "description": "API key of the CloudStack API.",
            "type": "string"
          },
          "api_region": {
            "description": "Name of the ini section in the `cloustack.ini' file.",
            "type": "string"
          },
          "api_secret": {
            "description": "Secret key of the CloudStack API.",
            "type": "string"
          },
          "api_timeout": {
            "description": "HTTP timeout.",
            "type": "string"
          },
          "api_url": {
            "description": "URL of the CloudStack API e.g. https://cloud.exa mple.com/client/a pi.",
            "type": "string"
          },
          "domain": {
            "description": "Domain the volume is related to.",
            "type": "string"
          },
          "interval_type": {
            "description": "Interval of the snapshot.",
            "type": "string"
          },
          "max_snaps": {
            "description": "Max number of snapshots.",
            "type": "string"
          },
          "project": {
            "description": "Name of the project the volume is related to.",
            "type": "string"
          },
          "schedule": {
            "description": "Time the snapshot is scheduled. Required if `state=present'. Format for `inter val_type=HOURLY': `MM' Format for ` interval_type=DAI LY': `MM:HH' Format for `inter val_type=WEEKLY': `MM:HH:DD (1-7') Format for `inter val_type=MONTHLY' : `MM:HH:DD (1-28')",
            "type": "string"
          },
          "state": {
            "description": "State of the snapshot policy.",
            "type": "string"
          },
          "time_zone": {
            "description": "Specifies a timezone for this command.",
            "type": "string"
          },
          "volume": {
            "description": "Name of the volume.",
            "type": "string"
          }
        },
        "required": "volume"
      }
    },
    {
      "cs_sshkeypair": {
        "type": "object",
        "description": "Manages SSH keys on Apache CloudStack based clouds.",
        "properties": {
          "account": {
            "description": "Account the public key is related to.",
            "type": "string"
          },
          "api_http_method": {
            "description": "HTTP method used.",
            "type": "string"
          },
          "api_key": {
            "description": "API key of the CloudStack API.",
            "type": "string"
          },
          "api_region": {
            "description": "Name of the ini section in the `cloustack.ini' file.",
            "type": "string"
          },
          "api_secret": {
            "description": "Secret key of the CloudStack API.",
            "type": "string"
          },
          "api_timeout": {
            "description": "HTTP timeout.",
            "type": "string"
          },
          "api_url": {
            "description": "URL of the CloudStack API e.g. https://cloud.exa mple.com/client/a pi.",
            "type": "string"
          },
          "domain": {
            "description": "Domain the public key is related to.",
            "type": "string"
          },
          "name": {
            "description": "Name of public key.",
            "type": "string"
          },
          "project": {
            "description": "Name of the project the public key to be registered in.",
            "type": "string"
          },
          "public_key": {
            "description": "String of the public key.",
            "type": "string"
          },
          "state": {
            "description": "State of the public key.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "cs_staticnat": {
        "type": "object",
        "description": "Manages static NATs on Apache CloudStack based clouds.",
        "properties": {
          "account": {
            "description": "Account the static NAT is related to.",
            "type": "string"
          },
          "api_http_method": {
            "description": "HTTP method used.",
            "type": "string"
          },
          "api_key": {
            "description": "API key of the CloudStack API.",
            "type": "string"
          },
          "api_region": {
            "description": "Name of the ini section in the `cloustack.ini' file.",
            "type": "string"
          },
          "api_secret": {
            "description": "Secret key of the CloudStack API.",
            "type": "string"
          },
          "api_timeout": {
            "description": "HTTP timeout.",
            "type": "string"
          },
          "api_url": {
            "description": "URL of the CloudStack API e.g. https://cloud.exa mple.com/client/a pi.",
            "type": "string"
          },
          "domain": {
            "description": "Domain the static NAT is related to.",
            "type": "string"
          },
          "ip_address": {
            "description": "Public IP address the static NAT is assigned to.",
            "type": "string"
          },
          "network": {
            "description": "Network the IP address is related to.",
            "type": "string"
          },
          "poll_async": {
            "description": "Poll async jobs until job has finished.",
            "type": "string"
          },
          "project": {
            "description": "Name of the project the static NAT is related to.",
            "type": "string"
          },
          "state": {
            "description": "State of the static NAT.",
            "type": "string"
          },
          "vm": {
            "description": "Name of virtual machine which we make the static NAT for. Required if `state=present'.",
            "type": "string"
          },
          "vm_guest_ip": {
            "description": "VM guest NIC secondary IP address for the static NAT.",
            "type": "string"
          },
          "zone": {
            "description": "Name of the zone in which the virtual machine is in. If not set, default zone is used.",
            "type": "string"
          }
        },
        "required": "ip_address"
      }
    },
    {
      "cs_template": {
        "type": "object",
        "description": "Manages templates on Apache CloudStack based clouds.",
        "properties": {
          "account": {
            "description": "Account the template, snapshot or VM is related to.",
            "type": "string"
          },
          "api_http_method": {
            "description": "HTTP method used.",
            "type": "string"
          },
          "api_key": {
            "description": "API key of the CloudStack API.",
            "type": "string"
          },
          "api_region": {
            "description": "Name of the ini section in the `cloustack.ini' file.",
            "type": "string"
          },
          "api_secret": {
            "description": "Secret key of the CloudStack API.",
            "type": "string"
          },
          "api_timeout": {
            "description": "HTTP timeout.",
            "type": "string"
          },
          "api_url": {
            "description": "URL of the CloudStack API e.g. https://cloud.exa mple.com/client/a pi.",
            "type": "string"
          },
          "bits": {
            "description": "32 or 64 bits support.",
            "type": "string"
          },
          "checksum": {
            "description": "The MD5 checksum value of this template. If set, we search by checksum instead of name.",
            "type": "string"
          },
          "cross_zones": {
            "description": "Whether the template should be synced or removed across zones. Only used if `state' is present or absent.",
            "type": "string"
          },
          "details": {
            "description": "Template details in key/value pairs.",
            "type": "string"
          },
          "display_text": {
            "description": "Display text of the template.",
            "type": "string"
          },
          "domain": {
            "description": "Domain the template, snapshot or VM is related to.",
            "type": "string"
          },
          "format": {
            "description": "The format for the template. Relevant when using `state=present'.",
            "type": "string"
          },
          "hypervisor": {
            "description": "Name the hypervisor to be used for creating the new template. Relevant when using `state=present'.",
            "type": "string"
          },
          "is_dynamically_scalable": {
            "description": "Register the template having XS/VMWare tools installed in order to support dynamic scaling of VM CPU/memory. Only used if `state' is present.",
            "type": "string"
          },
          "is_extractable": {
            "description": "True if the template or its derivatives are extractable.",
            "type": "string"
          },
          "is_featured": {
            "description": "Register the template to be featured. Only used if `state' is present.",
            "type": "string"
          },
          "is_public": {
            "description": "Register the template to be publicly available to all users. Only used if `state' is present.",
            "type": "string"
          },
          "is_ready": {
            "description": "This flag is used for searching existing templates. If set to `true', it will only list template ready for deployment e.g. successfully downloaded and installed. Recommended to set it to `false'.",
            "type": "string"
          },
          "is_routing": {
            "description": "True if the template type is routing i.e., if template is used to deploy router. Only considered if `url' is used.",
            "type": "string"
          },
          "mode": {
            "description": "Mode for the template extraction. Only used if `state=extracted' .",
            "type": "string"
          },
          "name": {
            "description": "Name of the template.",
            "type": "string"
          },
          "os_type": {
            "description": "OS type that best represents the OS of this template.",
            "type": "string"
          },
          "password_enabled": {
            "description": "True if the template supports the password reset feature.",
            "type": "string"
          },
          "poll_async": {
            "description": "Poll async jobs until job has finished.",
            "type": "string"
          },
          "project": {
            "description": "Name of the project the template to be registered in.",
            "type": "string"
          },
          "requires_hvm": {
            "description": "true if this template requires HVM.",
            "type": "string"
          },
          "snapshot": {
            "description": "Name of the snapshot, created from the VM ROOT volume, the template will be created from. `vm' is required together with this argument.",
            "type": "string"
          },
          "sshkey_enabled": {
            "description": "True if the template supports the sshkey upload feature.",
            "type": "string"
          },
          "state": {
            "description": "State of the template.",
            "type": "string"
          },
          "template_filter": {
            "description": "Name of the filter used to search for the template.",
            "type": "string"
          },
          "template_tag": {
            "description": "the tag for this template.",
            "type": "string"
          },
          "url": {
            "description": "URL of where the template is hosted on `state=present'. URL to which the template would be extracted on `sta te=extracted'. Mutually exclusive with `vm'.",
            "type": "string"
          },
          "vm": {
            "description": "VM name the template will be created from its volume or alternatively from a snapshot. VM must be in stopped state if created from its volume. Mutually exclusive with `url'.",
            "type": "string"
          },
          "zone": {
            "description": "Name of the zone you wish the template to be registered or deleted from. If not specified, first found zone will be used.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "cs_user": {
        "type": "object",
        "description": "Manages users on Apache CloudStack based clouds.",
        "properties": {
          "account": {
            "description": "Account the user will be created under. Required on `state=present'.",
            "type": "string"
          },
          "api_http_method": {
            "description": "HTTP method used.",
            "type": "string"
          },
          "api_key": {
            "description": "API key of the CloudStack API.",
            "type": "string"
          },
          "api_region": {
            "description": "Name of the ini section in the `cloustack.ini' file.",
            "type": "string"
          },
          "api_secret": {
            "description": "Secret key of the CloudStack API.",
            "type": "string"
          },
          "api_timeout": {
            "description": "HTTP timeout.",
            "type": "string"
          },
          "api_url": {
            "description": "URL of the CloudStack API e.g. https://cloud.exa mple.com/client/a pi.",
            "type": "string"
          },
          "domain": {
            "description": "Domain the user is related to.",
            "type": "string"
          },
          "email": {
            "description": "Email of the user. Required on `state=present'.",
            "type": "string"
          },
          "first_name": {
            "description": "First name of the user. Required on `state=present'.",
            "type": "string"
          },
          "last_name": {
            "description": "Last name of the user. Required on `state=present'.",
            "type": "string"
          },
          "password": {
            "description": "Password of the user to be created. Required on `state=present'. Only considered on creation and will not be updated if user exists.",
            "type": "string"
          },
          "poll_async": {
            "description": "Poll async jobs until job has finished.",
            "type": "string"
          },
          "state": {
            "description": "State of the user. `unlocked' is an alias for `enabled'.",
            "type": "string"
          },
          "timezone": {
            "description": "Timezone of the user.",
            "type": "string"
          },
          "username": {
            "description": "Username of the user.",
            "type": "string"
          }
        },
        "required": "username"
      }
    },
    {
      "cs_vmsnapshot": {
        "type": "object",
        "description": "Manages VM snapshots on Apache CloudStack based clouds.",
        "properties": {
          "account": {
            "description": "Account the VM snapshot is related to.",
            "type": "string"
          },
          "api_http_method": {
            "description": "HTTP method used.",
            "type": "string"
          },
          "api_key": {
            "description": "API key of the CloudStack API.",
            "type": "string"
          },
          "api_region": {
            "description": "Name of the ini section in the `cloustack.ini' file.",
            "type": "string"
          },
          "api_secret": {
            "description": "Secret key of the CloudStack API.",
            "type": "string"
          },
          "api_timeout": {
            "description": "HTTP timeout.",
            "type": "string"
          },
          "api_url": {
            "description": "URL of the CloudStack API e.g. https://cloud.exa mple.com/client/a pi.",
            "type": "string"
          },
          "description": {
            "description": "Description of the snapshot.",
            "type": "string"
          },
          "domain": {
            "description": "Domain the VM snapshot is related to.",
            "type": "string"
          },
          "name": {
            "description": "Unique Name of the snapshot. In CloudStack terms display name.",
            "type": "string"
          },
          "poll_async": {
            "description": "Poll async jobs until job has finished.",
            "type": "string"
          },
          "project": {
            "description": "Name of the project the VM is assigned to.",
            "type": "string"
          },
          "snapshot_memory": {
            "description": "Snapshot memory if set to true.",
            "type": "string"
          },
          "state": {
            "description": "State of the snapshot.",
            "type": "string"
          },
          "vm": {
            "description": "Name of the virtual machine.",
            "type": "string"
          },
          "zone": {
            "description": "Name of the zone in which the VM is in. If not set, default zone is used.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "vm"
        ]
      }
    },
    {
      "cs_volume": {
        "type": "object",
        "description": "Manages volumes on Apache CloudStack based clouds.",
        "properties": {
          "account": {
            "description": "Account the volume is related to.",
            "type": "string"
          },
          "api_http_method": {
            "description": "HTTP method used.",
            "type": "string"
          },
          "api_key": {
            "description": "API key of the CloudStack API.",
            "type": "string"
          },
          "api_region": {
            "description": "Name of the ini section in the `cloustack.ini' file.",
            "type": "string"
          },
          "api_secret": {
            "description": "Secret key of the CloudStack API.",
            "type": "string"
          },
          "api_timeout": {
            "description": "HTTP timeout.",
            "type": "string"
          },
          "api_url": {
            "description": "URL of the CloudStack API e.g. https://cloud.exa mple.com/client/a pi.",
            "type": "string"
          },
          "custom_id": {
            "description": "Custom id to the resource. Allowed to Root Admins only.",
            "type": "string"
          },
          "disk_offering": {
            "description": "Name of the disk offering to be used. Required one of `disk_offering', `snapshot' if volume is not already `state=present'.",
            "type": "string"
          },
          "display_volume": {
            "description": "Whether to display the volume to the end user or not. Allowed to Root Admins only.",
            "type": "string"
          },
          "domain": {
            "description": "Name of the domain the volume to be deployed in.",
            "type": "string"
          },
          "force": {
            "description": "Force removal of volume even it is attached to a VM. Considered on `state=absnet' only.",
            "type": "string"
          },
          "max_iops": {
            "description": "Max iops",
            "type": "string"
          },
          "min_iops": {
            "description": "Min iops",
            "type": "string"
          },
          "name": {
            "description": "Name of the volume. `name' can only contain ASCII letters.",
            "type": "string"
          },
          "poll_async": {
            "description": "Poll async jobs until job has finished.",
            "type": "string"
          },
          "project": {
            "description": "Name of the project the volume to be deployed in.",
            "type": "string"
          },
          "shrink_ok": {
            "description": "Whether to allow to shrink the volume.",
            "type": "string"
          },
          "size": {
            "description": "Size of disk in GB",
            "type": "string"
          },
          "snapshot": {
            "description": "The snapshot name for the disk volume. Required one of `disk_offering', `snapshot' if volume is not already `state=present'.",
            "type": "string"
          },
          "state": {
            "description": "State of the volume.",
            "type": "string"
          },
          "vm": {
            "description": "Name of the virtual machine to attach the volume to.",
            "type": "string"
          },
          "zone": {
            "description": "Name of the zone in which the volume should be deployed. If not set, default zone is used.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "cs_zone": {
        "type": "object",
        "description": "Manages zones on Apache CloudStack based clouds.",
        "properties": {
          "api_http_method": {
            "description": "HTTP method used.",
            "type": "string"
          },
          "api_key": {
            "description": "API key of the CloudStack API.",
            "type": "string"
          },
          "api_region": {
            "description": "Name of the ini section in the `cloustack.ini' file.",
            "type": "string"
          },
          "api_secret": {
            "description": "Secret key of the CloudStack API.",
            "type": "string"
          },
          "api_timeout": {
            "description": "HTTP timeout.",
            "type": "string"
          },
          "api_url": {
            "description": "URL of the CloudStack API e.g. https://cloud.exa mple.com/client/a pi.",
            "type": "string"
          },
          "dhcp_provider": {
            "description": "DHCP provider for the Zone.",
            "type": "string"
          },
          "dns1": {
            "description": "First DNS for the zone. Required if `state=present'",
            "type": "string"
          },
          "dns1_ipv6": {
            "description": "First DNS for IPv6 for the zone.",
            "type": "string"
          },
          "dns2": {
            "description": "Second DNS for the zone.",
            "type": "string"
          },
          "dns2_ipv6": {
            "description": "Second DNS for IPv6 for the zone.",
            "type": "string"
          },
          "domain": {
            "description": "Domain the zone is related to. Zone is a public zone if not set.",
            "type": "string"
          },
          "guest_cidr_address": {
            "description": "Guest CIDR address for the zone.",
            "type": "string"
          },
          "id": {
            "description": "uuid of the exising zone.",
            "type": "string"
          },
          "internal_dns1": {
            "description": "First internal DNS for the zone. If not set `dns1' will be used on `state=present'.",
            "type": "string"
          },
          "internal_dns2": {
            "description": "Second internal DNS for the zone.",
            "type": "string"
          },
          "name": {
            "description": "Name of the zone.",
            "type": "string"
          },
          "network_domain": {
            "description": "Network domain for the zone.",
            "type": "string"
          },
          "network_type": {
            "description": "Network type of the zone.",
            "type": "string"
          },
          "state": {
            "description": "State of the zone.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "cs_zone_facts": {
        "type": "object",
        "description": "Gathering facts of zones from Apache CloudStack based clouds.",
        "properties": {
          "api_http_method": {
            "description": "HTTP method used.",
            "type": "string"
          },
          "api_key": {
            "description": "API key of the CloudStack API.",
            "type": "string"
          },
          "api_region": {
            "description": "Name of the ini section in the `cloustack.ini' file.",
            "type": "string"
          },
          "api_secret": {
            "description": "Secret key of the CloudStack API.",
            "type": "string"
          },
          "api_timeout": {
            "description": "HTTP timeout.",
            "type": "string"
          },
          "api_url": {
            "description": "URL of the CloudStack API e.g. https://cloud.exa mple.com/client/a pi.",
            "type": "string"
          },
          "name": {
            "description": "Name of the zone.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "datadog_event": {
        "type": "object",
        "description": "Posts events to DataDog  service",
        "properties": {
          "aggregation_key": {
            "description": "An arbitrary string to use for aggregation.",
            "type": "string"
          },
          "alert_type": {
            "description": "Type of alert.",
            "type": "string"
          },
          "api_key": {
            "description": "Your DataDog API key.",
            "type": "string"
          },
          "app_key": {
            "description": "Your DataDog app key.",
            "type": "string"
          },
          "date_happened": {
            "description": "POSIX timestamp of the event. Default value is now.",
            "type": "string"
          },
          "priority": {
            "description": "The priority of the event.",
            "type": "string"
          },
          "tags": {
            "description": "Comma separated list of tags to apply to the event.",
            "type": "string"
          },
          "text": {
            "description": "The body of the event.",
            "type": "string"
          },
          "title": {
            "description": "The event title.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": [
          "api_key",
          "app_key",
          "text",
          "title"
        ]
      }
    },
    {
      "datadog_monitor": {
        "type": "object",
        "description": "Manages Datadog monitors",
        "properties": {
          "api_key": {
            "description": "Your DataDog API key.",
            "type": "string"
          },
          "app_key": {
            "description": "Your DataDog app key.",
            "type": "string"
          },
          "escalation_message": {
            "description": "A message to include with a re-notification. Supports the '@username' notification we allow elsewhere. Not applicable if renotify_interval is None",
            "type": "string"
          },
          "locked": {
            "description": "A boolean indicating whether changes to this monitor should be restricted to the creator or admins.",
            "type": "string"
          },
          "message": {
            "description": "A message to include with notifications for this monitor. Email notifications can be sent to specific users by using the same '@username' notation as events. Monitor message template variables can be accessed by using double square brackets, i.e '[[' and ']]'.",
            "type": "string"
          },
          "name": {
            "description": "The name of the alert.",
            "type": "string"
          },
          "no_data_timeframe": {
            "description": "The number of minutes before a monitor will notify when data stops reporting. Must be at least 2x the monitor timeframe for metric alerts or 2 minutes for service checks.",
            "type": "string"
          },
          "notify_audit": {
            "description": "A boolean indicating whether tagged users will be notified on changes to this monitor.",
            "type": "string"
          },
          "notify_no_data": {
            "description": "A boolean indicating whether this monitor will notify when data stops reporting..",
            "type": "string"
          },
          "query": {
            "description": "The monitor query to notify on with syntax varying depending on what type of monitor you are creating.",
            "type": "string"
          },
          "renotify_interval": {
            "description": "The number of minutes after the last notification before a monitor will re-notify on the current status. It will only re-notify if it's not resolved.",
            "type": "string"
          },
          "silenced": {
            "description": "Dictionary of scopes to timestamps or None. Each scope will be muted until the given POSIX timestamp or forever if the value is None.",
            "type": "string"
          },
          "state": {
            "description": "The designated state of the monitor.",
            "type": "string"
          },
          "tags": {
            "description": "A list of tags to associate with your monitor when creating or updating. This can help you categorize and filter monitors.",
            "type": "string"
          },
          "thresholds": {
            "description": "A dictionary of thresholds by status. This option is only available for service checks and metric alerts. Because each of them can have multiple thresholds, we don't define them directly in the query.",
            "type": "string"
          },
          "timeout_h": {
            "description": "The number of hours of the monitor not reporting data before it will automatically resolve from a triggered state.",
            "type": "string"
          },
          "type": {
            "description": "The type of the monitor. The 'event alert'is available starting at Ansible 2.1",
            "type": "string"
          }
        },
        "required": [
          "api_key",
          "app_key",
          "name",
          "state"
        ]
      }
    },
    {
      "debconf": {
        "type": "object",
        "description": "Configure a .deb package",
        "properties": {
          "name": {
            "description": "Name of package to configure.",
            "type": "string"
          },
          "question": {
            "description": "A debconf configuration setting",
            "type": "string"
          },
          "unseen": {
            "description": "Do not set 'seen' flag when pre-seeding",
            "type": "string"
          },
          "value": {
            "description": "Value to set the configuration to",
            "type": "string"
          },
          "vtype": {
            "description": "The type of the value supplied. `seen' was added in 2.2.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "debug": {
        "type": "object",
        "description": "Print statements during execution",
        "properties": {
          "msg": {
            "description": "The customized message that is printed. If omitted, prints a generic message.",
            "type": "string"
          },
          "var": {
            "description": "A variable name to debug.  Mutually exclusive with the 'msg' option.",
            "type": "string"
          },
          "verbosity": {
            "description": "A number that controls when the debug is run, if you set to 3 it will only run debug when -vvv or above",
            "type": "string"
          }
        }
      }
    },
    {
      "dellos10_command": {
        "type": "object",
        "description": "Run commands on remote devices running Dell OS10",
        "properties": {
          "commands": {
            "description": "List of commands to send to the remote dellos10 device over the configured provider. The resulting output from the command is returned. If the `wait_for' argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "interval": {
            "description": "Configures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.",
            "type": "string"
          },
          "password": {
            "description": "This value `password' is used to authenticate the SSH session to the remote device. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_PASSWORD will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device.",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all [dellos10] arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "retries": {
            "description": "Specifies the number of retries a command should by tried before it is considered failed. The command is run on the target device every retry and evaluated against the `wait_for' conditions.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "This value `ssh_keyfile' is the path to the key used to authenticate the SSH session to the remote device.  If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_SSH_KEYFILE will be used instead.",
            "type": "string"
          },
          "timeout": {
            "description": "Specifies idle timeout (in seconds) for the connection. Useful if the console freezes before continuing. For example when saving configurations.",
            "type": "string"
          },
          "username": {
            "description": "This value `username' is used to authenticate the SSH session to the remote device. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_USERNAME will be used instead.",
            "type": "string"
          },
          "wait_for": {
            "description": "List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of `retries', the task fails. See examples.",
            "type": "string"
          }
        },
        "required": [
          "commands",
          "host"
        ]
      }
    },
    {
      "dellos10_config": {
        "type": "object",
        "description": "Manage Dell OS10 configuration sections",
        "properties": {
          "after": {
            "description": "The ordered set of commands to append to the end of the command stack if a change needs to be made. Just like with `before' this allows the playbook designer to append a set of commands to be executed after the command set.",
            "type": "string"
          },
          "backup": {
            "description": "This argument will cause the module to create a full backup of the current `running-config' from the remote device before any changes are made. The backup file is written to the `backup' folder in the playbook root directory. If the directory does not exist, it is created.",
            "type": "string"
          },
          "before": {
            "description": "The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.",
            "type": "string"
          },
          "config": {
            "description": "The `config' argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "lines": {
            "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config. Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser. This argument is mutually exclusive with `src'.",
            "type": "string"
          },
          "match": {
            "description": "Instructs the module on the way to perform the matching of the set of commands against the current device config.  If match is set to `line', commands are matched line by line.  If match is set to `strict', command lines are matched with respect to position.  If match is set to `exact', command lines must be an equal match. Finally, if match is set to `none', the module will not attempt to compare the source configuration with the running configuration on the remote device.",
            "type": "string"
          },
          "parents": {
            "description": "The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.",
            "type": "string"
          },
          "password": {
            "description": "This value `password' is used to authenticate the SSH session to the remote device. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_PASSWORD will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device.",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all [dellos10] arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "replace": {
            "description": "Instructs the module on the way to perform the configuration on the device.  If the replace argument is set to `line' then the modified lines are pushed to the device in configuration mode.  If the replace argument is set to `block' then the entire command block is pushed to the device in configuration mode if any line is not correct.",
            "type": "string"
          },
          "save": {
            "description": "The `save' argument instructs the module to save the running- config to the startup-config at the conclusion of the module running.  If check mode is specified, this argument is ignored.",
            "type": "string"
          },
          "src": {
            "description": "Specifies the source path to the file that contains the configuration or configuration template to load. The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root dir. This argument is mutually exclusive with `lines'.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "This value `ssh_keyfile' is the path to the key used to authenticate the SSH session to the remote device.  If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_SSH_KEYFILE will be used instead.",
            "type": "string"
          },
          "timeout": {
            "description": "Specifies idle timeout (in seconds) for the connection. Useful if the console freezes before continuing. For example when saving configurations.",
            "type": "string"
          },
          "update": {
            "description": "The `update' argument controls how the configuration statements are processed on the remote device. Valid choices for the `update' argument are `merge' and `check'.  When the argument is set to `merge', the configuration changes are merged with the current device running configuration. When the argument is set to `check' the configuration updates are determined but not actually configured on the remote device.",
            "type": "string"
          },
          "username": {
            "description": "This value `username' is used to authenticate the SSH session to the remote device. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_USERNAME will be used instead.",
            "type": "string"
          }
        },
        "required": "host"
      }
    },
    {
      "dellos10_facts": {
        "type": "object",
        "description": "Collect facts from remote devices running Dell OS10",
        "properties": {
          "gather_subset": {
            "description": "When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  Can specify a list of values to include a larger subset. Values can also be used with an initial `[!]' to specify that a specific subset should not be collected.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "This value `password' is used to authenticate the SSH session to the remote device. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_PASSWORD will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device.",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all [dellos10] arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "This value `ssh_keyfile' is the path to the key used to authenticate the SSH session to the remote device.  If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_SSH_KEYFILE will be used instead.",
            "type": "string"
          },
          "timeout": {
            "description": "Specifies idle timeout (in seconds) for the connection. Useful if the console freezes before continuing. For example when saving configurations.",
            "type": "string"
          },
          "username": {
            "description": "This value `username' is used to authenticate the SSH session to the remote device. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_USERNAME will be used instead.",
            "type": "string"
          }
        },
        "required": "host"
      }
    },
    {
      "dellos6_command": {
        "type": "object",
        "description": "Run commands on remote devices running Dell OS6",
        "properties": {
          "auth_pass": {
            "description": "Specifies the password to use if required to enter privileged mode on the remote device. If `authorize' is false, then this argument does nothing. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_AUTH_PASS will be used instead.",
            "type": "string"
          },
          "authorize": {
            "description": "Instructs the module to enter priviledged mode on the remote device before sending any commands.  If not specified, the device will attempt to excecute all commands in non- priviledged mode. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_AUTHORIZE will be used instead.",
            "type": "string"
          },
          "commands": {
            "description": "List of commands to send to the remote dellos6 device over the configured provider. The resulting output from the command is returned. If the `wait_for' argument is provided, the module is not returned until the condition is satisfied or the number of `retries' as expired.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "interval": {
            "description": "Configures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.",
            "type": "string"
          },
          "password": {
            "description": "Password to authenticate the SSH session to the remote device. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_PASSWORD will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device.",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all [dellos6] arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "retries": {
            "description": "Specifies the number of retries a command should be tried before it is considered failed. The command is run on the target device every retry and evaluated against the `wait_for' conditions.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Path to an ssh key used to authenticate the SSH session to the remote device. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_SSH_KEYFILE will be used instead.",
            "type": "string"
          },
          "timeout": {
            "description": "Specifies idle timeout (in seconds) for the connection. Useful if the console freezes before continuing. For example when saving configurations.",
            "type": "string"
          },
          "username": {
            "description": "User to authenticate the SSH session to the remote device. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_USERNAME will be used instead.",
            "type": "string"
          },
          "wait_for": {
            "description": "List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of `retries', the task fails. See examples.",
            "type": "string"
          }
        },
        "required": [
          "commands",
          "host"
        ]
      }
    },
    {
      "dellos6_config": {
        "type": "object",
        "description": "Manage Dell OS6 configuration sections",
        "properties": {
          "after": {
            "description": "The ordered set of commands to append to the end of the command stack if a change needs to be made. Just like with `before' this allows the playbook designer to append a set of commands to be executed after the command set.",
            "type": "string"
          },
          "auth_pass": {
            "description": "Specifies the password to use if required to enter privileged mode on the remote device. If `authorize' is false, then this argument does nothing. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_AUTH_PASS will be used instead.",
            "type": "string"
          },
          "authorize": {
            "description": "Instructs the module to enter priviledged mode on the remote device before sending any commands.  If not specified, the device will attempt to excecute all commands in non- priviledged mode. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_AUTHORIZE will be used instead.",
            "type": "string"
          },
          "backup": {
            "description": "This argument will cause the module to create a full backup of the current `running-config' from the remote device before any changes are made. The backup file is written to the `backup' folder in the playbook root directory. If the directory does not exist, it is created.",
            "type": "string"
          },
          "before": {
            "description": "The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.",
            "type": "string"
          },
          "config": {
            "description": "The `config' argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "lines": {
            "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config. Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser. This argument is mutually exclusive with `src'.",
            "type": "string"
          },
          "match": {
            "description": "Instructs the module on the way to perform the matching of the set of commands against the current device config.  If match is set to `line', commands are matched line by line.  If match is set to `strict', command lines are matched with respect to position.  If match is set to `exact', command lines must be an equal match. Finally, if match is set to `none', the module will not attempt to compare the source configuration with the running configuration on the remote device.",
            "type": "string"
          },
          "parents": {
            "description": "The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.",
            "type": "string"
          },
          "password": {
            "description": "Password to authenticate the SSH session to the remote device. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_PASSWORD will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device.",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all [dellos6] arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "replace": {
            "description": "Instructs the module on the way to perform the configuration on the device.  If the replace argument is set to `line' then the modified lines are pushed to the device in configuration mode.  If the replace argument is set to `block' then the entire command block is pushed to the device in configuration mode if any line is not correct.",
            "type": "string"
          },
          "save": {
            "description": "The `save' argument instructs the module to save the running- config to the startup-config at the conclusion of the module running.  If check mode is specified, this argument is ignored.",
            "type": "string"
          },
          "src": {
            "description": "Specifies the source path to the file that contains the configuration or configuration template to load. The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root dir. This argument is mutually exclusive with `lines'.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Path to an ssh key used to authenticate the SSH session to the remote device. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_SSH_KEYFILE will be used instead.",
            "type": "string"
          },
          "timeout": {
            "description": "Specifies idle timeout (in seconds) for the connection. Useful if the console freezes before continuing. For example when saving configurations.",
            "type": "string"
          },
          "update": {
            "description": "The `update' argument controls how the configuration statements are processed on the remote device. Valid choices for the `update' argument are `merge' and `check'.  When the argument is set to `merge', the configuration changes are merged with the current device running configuration. When the argument is set to `check' the configuration updates are determined but not actually configured on the remote device.",
            "type": "string"
          },
          "username": {
            "description": "User to authenticate the SSH session to the remote device. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_USERNAME will be used instead.",
            "type": "string"
          }
        },
        "required": "host"
      }
    },
    {
      "dellos6_facts": {
        "type": "object",
        "description": "Collect facts from remote devices running Dell OS6",
        "properties": {
          "auth_pass": {
            "description": "Specifies the password to use if required to enter privileged mode on the remote device. If `authorize' is false, then this argument does nothing. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_AUTH_PASS will be used instead.",
            "type": "string"
          },
          "authorize": {
            "description": "Instructs the module to enter priviledged mode on the remote device before sending any commands.  If not specified, the device will attempt to excecute all commands in non- priviledged mode. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_AUTHORIZE will be used instead.",
            "type": "string"
          },
          "gather_subset": {
            "description": "When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  Can specify a list of values to include a larger subset. Values can also be used with an initial `[!]' to specify that a specific subset should not be collected.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "Password to authenticate the SSH session to the remote device. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_PASSWORD will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device.",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all [dellos6] arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Path to an ssh key used to authenticate the SSH session to the remote device. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_SSH_KEYFILE will be used instead.",
            "type": "string"
          },
          "timeout": {
            "description": "Specifies idle timeout (in seconds) for the connection. Useful if the console freezes before continuing. For example when saving configurations.",
            "type": "string"
          },
          "username": {
            "description": "User to authenticate the SSH session to the remote device. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_USERNAME will be used instead.",
            "type": "string"
          }
        },
        "required": "host"
      }
    },
    {
      "dellos9_command": {
        "type": "object",
        "description": "Run commands on remote devices running Dell OS9",
        "properties": {
          "auth_pass": {
            "description": "Specifies the password to use if required to enter privileged mode on the remote device. If `authorize' is false, then this argument does nothing. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_AUTH_PASS will be used instead.",
            "type": "string"
          },
          "authorize": {
            "description": "Instructs the module to enter priviledged mode on the remote device before sending any commands.  If not specified, the device will attempt to excecute all commands in non- priviledged mode. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_AUTHORIZE will be used instead.",
            "type": "string"
          },
          "commands": {
            "description": "List of commands to send to the remote dellos9 device over the configured provider. The resulting output from the command is returned. If the `wait_for' argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "interval": {
            "description": "Configures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.",
            "type": "string"
          },
          "password": {
            "description": "Password to authenticate the SSH session to the remote device. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_PASSWORD will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device.",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all [dellos9] arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "retries": {
            "description": "Specifies the number of retries a command should be tried before it is considered failed. The command is run on the target device every retry and evaluated against the `wait_for' conditions.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Path to an ssh key used to authenticate the SSH session to the remote device. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_SSH_KEYFILE will be used instead.",
            "type": "string"
          },
          "timeout": {
            "description": "Specifies idle timeout (in seconds) for the connection. Useful if the console freezes before continuing. For example when saving configurations.",
            "type": "string"
          },
          "username": {
            "description": "User to authenticate the SSH session to the remote device. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_USERNAME will be used instead.",
            "type": "string"
          },
          "wait_for": {
            "description": "List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of `retries', the task fails. See examples.",
            "type": "string"
          }
        },
        "required": [
          "commands",
          "host"
        ]
      }
    },
    {
      "dellos9_config": {
        "type": "object",
        "description": "Manage Dell OS9 configuration sections",
        "properties": {
          "after": {
            "description": "The ordered set of commands to append to the end of the command stack if a change needs to be made. Just like with `before' this allows the playbook designer to append a set of commands to be executed after the command set.",
            "type": "string"
          },
          "auth_pass": {
            "description": "Specifies the password to use if required to enter privileged mode on the remote device. If `authorize' is false, then this argument does nothing. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_AUTH_PASS will be used instead.",
            "type": "string"
          },
          "authorize": {
            "description": "Instructs the module to enter priviledged mode on the remote device before sending any commands.  If not specified, the device will attempt to excecute all commands in non- priviledged mode. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_AUTHORIZE will be used instead.",
            "type": "string"
          },
          "backup": {
            "description": "This argument will cause the module to create a full backup of the current `running-config' from the remote device before any changes are made. The backup file is written to the `backup' folder in the playbook root directory. If the directory does not exist, it is created.",
            "type": "string"
          },
          "before": {
            "description": "The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.",
            "type": "string"
          },
          "config": {
            "description": "The `config' argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "lines": {
            "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config. Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser. This argument is mutually exclusive with `src'.",
            "type": "string"
          },
          "match": {
            "description": "Instructs the module on the way to perform the matching of the set of commands against the current device config.  If match is set to `line', commands are matched line by line.  If match is set to `strict', command lines are matched with respect to position.  If match is set to `exact', command lines must be an equal match. Finally, if match is set to `none', the module will not attempt to compare the source configuration with the running configuration on the remote device.",
            "type": "string"
          },
          "parents": {
            "description": "The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.",
            "type": "string"
          },
          "password": {
            "description": "Password to authenticate the SSH session to the remote device. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_PASSWORD will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device.",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all [dellos9] arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "replace": {
            "description": "Instructs the module on the way to perform the configuration on the device.  If the replace argument is set to `line' then the modified lines are pushed to the device in configuration mode.  If the replace argument is set to `block' then the entire command block is pushed to the device in configuration mode if any line is not correct.",
            "type": "string"
          },
          "save": {
            "description": "The `save' argument instructs the module to save the running- config to the startup-config at the conclusion of the module running.  If check mode is specified, this argument is ignored.",
            "type": "string"
          },
          "src": {
            "description": "Specifies the source path to the file that contains the configuration or configuration template to load. The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root dir. This argument is mutually exclusive with `lines'.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Path to an ssh key used to authenticate the SSH session to the remote device. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_SSH_KEYFILE will be used instead.",
            "type": "string"
          },
          "timeout": {
            "description": "Specifies idle timeout (in seconds) for the connection. Useful if the console freezes before continuing. For example when saving configurations.",
            "type": "string"
          },
          "update": {
            "description": "The `update' argument controls how the configuration statements are processed on the remote device. Valid choices for the `update' argument are `merge' and `check'.  When the argument is set to `merge', the configuration changes are merged with the current device running configuration. When the argument is set to `check' the configuration updates are determined but not actually configured on the remote device.",
            "type": "string"
          },
          "username": {
            "description": "User to authenticate the SSH session to the remote device. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_USERNAME will be used instead.",
            "type": "string"
          }
        },
        "required": "host"
      }
    },
    {
      "dellos9_facts": {
        "type": "object",
        "description": "Collect facts from remote devices running Dell OS9",
        "properties": {
          "auth_pass": {
            "description": "Specifies the password to use if required to enter privileged mode on the remote device. If `authorize' is false, then this argument does nothing. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_AUTH_PASS will be used instead.",
            "type": "string"
          },
          "authorize": {
            "description": "Instructs the module to enter priviledged mode on the remote device before sending any commands.  If not specified, the device will attempt to excecute all commands in non- priviledged mode. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_AUTHORIZE will be used instead.",
            "type": "string"
          },
          "gather_subset": {
            "description": "When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  Can specify a list of values to include a larger subset. Values can also be used with an initial `[!]' to specify that a specific subset should not be collected.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "Password to authenticate the SSH session to the remote device. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_PASSWORD will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device.",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all [dellos9] arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Path to an ssh key used to authenticate the SSH session to the remote device. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_SSH_KEYFILE will be used instead.",
            "type": "string"
          },
          "timeout": {
            "description": "Specifies idle timeout (in seconds) for the connection. Useful if the console freezes before continuing. For example when saving configurations.",
            "type": "string"
          },
          "username": {
            "description": "User to authenticate the SSH session to the remote device. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_USERNAME will be used instead.",
            "type": "string"
          }
        },
        "required": "host"
      }
    },
    {
      "deploy_helper": {
        "type": "object",
        "description": "Manages some of the steps common in deploying projects.",
        "properties": {
          "clean": {
            "description": "Whether to run the clean procedure in case of `state=finalize'.",
            "type": "string"
          },
          "current_path": {
            "description": "the name of the symlink that is created when the deploy is finalized. Used in `finalize' and `clean'. Returned in the `deploy_he lper.current_path ' fact.",
            "type": "string"
          },
          "keep_releases": {
            "description": "the number of old releases to keep when cleaning. Used in `finalize' and `clean'. Any unfinished builds will be deleted first, so only correct releases will count. The current version will not count.",
            "type": "string"
          },
          "path": {
            "description": "the root path of the project. Alias `dest'. Returned in the ` deploy_helper.pro ject_path' fact.",
            "type": "string"
          },
          "release": {
            "description": "the release version that is being deployed. Defaults to a timestamp format %Y%m%d%H%M%S (i.e. '2014111922 3359'). This parameter is optional during `state=present', but needs to be set explicitly for `state=finalize'. You can use the generated fact `release={{ deplo y_helper.new_rele ase }}'.",
            "type": "string"
          },
          "releases_path": {
            "description": "the name of the folder that will hold the releases. This can be relative to `path' or absolute. Returned in the ` deploy_helper.rel eases_path' fact.",
            "type": "string"
          },
          "shared_path": {
            "description": "the name of the folder that will hold the shared resources. This can be relative to `path' or absolute. If this is set to an empty string, no shared folder will be created. Returned in the ` deploy_helper.sha red_path' fact.",
            "type": "string"
          },
          "state": {
            "description": "the state of the project. `query' will only gather facts, `present' will create the project `root' folder, and in it the `releases' and `shared' folders, `finalize' will remove the unfini shed_filename file, create a symlink to the newly deployed release and optionally clean old releases, `clean' will remove failed & old releases, `absent' will remove the project folder (synonymous to the [file] module with `state=absent')",
            "type": "string"
          },
          "unfinished_filename": {
            "description": "the name of the file that indicates a deploy has not finished. All folders in the releases_path that contain this file will be deleted on `state=finalize' with clean=True, or `state=clean'. This file is automatically deleted from the  `new_release_path ' during `state=finalize'.",
            "type": "string"
          }
        },
        "required": "path"
      }
    },
    {
      "digital_ocean": {
        "type": "object",
        "description": "Create/delete a droplet/SSH_key in DigitalOcean",
        "properties": {
          "api_token": {
            "description": "DigitalOcean api token.",
            "type": "string"
          },
          "backups_enabled": {
            "description": "Optional, Boolean, enables backups for your droplet.",
            "type": "string"
          },
          "command": {
            "description": "Which target you want to operate on.",
            "type": "string"
          },
          "id": {
            "description": "Numeric, the droplet id you want to operate on.",
            "type": "string"
          },
          "image_id": {
            "description": "This is the slug of the image you would like the droplet created with.",
            "type": "string"
          },
          "ipv6": {
            "description": "Optional, Boolean, enable IPv6 for your droplet.",
            "type": "string"
          },
          "name": {
            "description": "String, this is the name of the droplet - must be formatted by hostname rules, or the name of a SSH key.",
            "type": "string"
          },
          "private_networking": {
            "description": "Bool, add an additional, private network interface to droplet for inter-droplet communication.",
            "type": "string"
          },
          "region_id": {
            "description": "This is the slug of the region you would like your server to be created in.",
            "type": "string"
          },
          "size_id": {
            "description": "This is the slug of the size you would like the droplet created with.",
            "type": "string"
          },
          "ssh_key_ids": {
            "description": "Optional, array of of SSH key (numeric) ID that you would like to be added to the server.",
            "type": "string"
          },
          "ssh_pub_key": {
            "description": "The public SSH key you want to add to your account.",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the target.",
            "type": "string"
          },
          "unique_name": {
            "description": "Bool, require unique hostnames.  By default, DigitalOcean allows multiple hosts with the same name. Setting this to \"yes\" allows only one host per name.  Useful for idempotence.",
            "type": "string"
          },
          "user_data": {
            "description": "opaque blob of data which is made available to the droplet",
            "type": "string"
          },
          "virtio": {
            "description": "Bool, turn on virtio driver in droplet for improved network and storage I/O.",
            "type": "string"
          },
          "wait": {
            "description": "Wait for the droplet to be in state 'running' before returning. If wait is \"no\" an ip_address may not be returned.",
            "type": "string"
          },
          "wait_timeout": {
            "description": "How long before wait gives up, in seconds.",
            "type": "string"
          }
        }
      }
    },
    {
      "digital_ocean_block_storage": {
        "type": "object",
        "description": "Create/destroy or attach/detach Block Storage volumes in DigitalOcean",
        "properties": {
          "api_token": {
            "description": "DigitalOcean api token.",
            "type": "string"
          },
          "block_size": {
            "description": "The size of the Block Storage volume in gigabytes. Required when command=create and state=present.",
            "type": "string"
          },
          "command": {
            "description": "Which operation do you want to perform.",
            "type": "string"
          },
          "description": {
            "description": "Description of the Block Storage volume.",
            "type": "string"
          },
          "droplet_id": {
            "description": "The droplet id you want to operate on. Required when command=attach.",
            "type": "string"
          },
          "region": {
            "description": "The slug of the region where your Block Storage volume should be located in.",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the target.",
            "type": "string"
          },
          "timeout": {
            "description": "The timeout in seconds used for polling DigitalOcean's API.",
            "type": "string"
          },
          "volume_name": {
            "description": "The name of the Block Storage volume.",
            "type": "string"
          }
        },
        "required": [
          "api_token",
          "command",
          "region",
          "state",
          "volume_name"
        ]
      }
    },
    {
      "digital_ocean_domain": {
        "type": "object",
        "description": "Create/delete a DNS record in DigitalOcean",
        "properties": {
          "api_token": {
            "description": "DigitalOcean api token.",
            "type": "string"
          },
          "id": {
            "description": "Numeric, the droplet id you want to operate on.",
            "type": "string"
          },
          "ip": {
            "description": "The IP address to point a domain at.",
            "type": "string"
          },
          "name": {
            "description": "String, this is the name of the droplet - must be formatted by hostname rules, or the name of a SSH key, or the name of a domain.",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the target.",
            "type": "string"
          }
        }
      }
    },
    {
      "digital_ocean_sshkey": {
        "type": "object",
        "description": "Create/delete an SSH key in DigitalOcean",
        "properties": {
          "api_key": {
            "description": "DigitalOcean api key.",
            "type": "string"
          },
          "client_id": {
            "description": "DigitalOcean manager id.",
            "type": "string"
          },
          "id": {
            "description": "Numeric, the SSH key id you want to operate on.",
            "type": "string"
          },
          "name": {
            "description": "String, this is the name of an SSH key to create or destroy.",
            "type": "string"
          },
          "ssh_pub_key": {
            "description": "The public SSH key you want to add to your account.",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the target.",
            "type": "string"
          }
        }
      }
    },
    {
      "digital_ocean_tag": {
        "type": "object",
        "description": "Create and remove tag(s) to DigitalOcean resource.",
        "properties": {
          "api_token": {
            "description": "DigitalOcean api token.",
            "type": "string"
          },
          "name": {
            "description": "The name of the tag. The supported characters for names include alphanumeric characters, dashes, and underscores.",
            "type": "string"
          },
          "resource_id": {
            "description": "The ID of the resource to operate on.",
            "type": "string"
          },
          "resource_type": {
            "description": "The type of resource to operate on. Currently only tagging of droplets is supported.",
            "type": "string"
          },
          "state": {
            "description": "Whether the tag should be present or absent on the resource.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "django_manage": {
        "type": "object",
        "description": "Manages a Django application.",
        "properties": {
          "app_path": {
            "description": "The path to the root of the Django application where *manage.py* lives.",
            "type": "string"
          },
          "apps": {
            "description": "A list of space-delimited apps to target. Used by the 'test' command.",
            "type": "string"
          },
          "cache_table": {
            "description": "The name of the table used for database-backed caching. Used by the 'createcachet able' command.",
            "type": "string"
          },
          "command": {
            "description": "The name of the Django management command to run. Built in commands are cleanup, collectstatic, flush, loaddata, migrate, runfcgi, syncdb, test, and validate. Other commands can be entered, but will fail if they're unknown to Django.  Other commands that may prompt for user input should be run with the `--noinput' flag.",
            "type": "string"
          },
          "database": {
            "description": "The database to target. Used by the 'createcachetable ', 'flush', 'loaddata', and 'syncdb' commands.",
            "type": "string"
          },
          "failfast": {
            "description": "Fail the command immediately if a test fails. Used by the 'test' command.",
            "type": "string"
          },
          "fixtures": {
            "description": "A space-delimited list of fixture file names to load in the database. *Required* by the 'loaddata' command.",
            "type": "string"
          },
          "link": {
            "description": "Will create links to the files instead of copying them, you can only use this parameter with 'collectstatic' command",
            "type": "string"
          },
          "merge": {
            "description": "Will run out-of-order or missing migrations as they are not rollback migrations, you can only use this parameter with 'migrate' command",
            "type": "string"
          },
          "pythonpath": {
            "description": "A directory to add to the Python path. Typically used to include the settings module if it is located external to the application directory.",
            "type": "string"
          },
          "settings": {
            "description": "The Python path to the application's settings module, such as 'myapp.settings'.",
            "type": "string"
          },
          "skip": {
            "description": "Will skip over out-of-order missing migrations, you can only use this parameter with `migrate'",
            "type": "string"
          },
          "virtualenv": {
            "description": "An optional path to a `virtualenv' installation to use while running the manage application.",
            "type": "string"
          }
        },
        "required": [
          "app_path",
          "command"
        ]
      }
    },
    {
      "dladm_etherstub": {
        "type": "object",
        "description": "Manage etherstubs on Solaris/illumos systems.",
        "properties": {
          "name": {
            "description": "Etherstub name.",
            "type": "string"
          },
          "state": {
            "description": "Create or delete Solaris/illumos etherstub.",
            "type": "string"
          },
          "temporary": {
            "description": "Specifies that the etherstub is temporary. Temporary etherstubs do not persist across reboots.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "dladm_vnic": {
        "type": "object",
        "description": "Manage VNICs on Solaris/illumos systems.",
        "properties": {
          "link": {
            "description": "VNIC underlying link name.",
            "type": "string"
          },
          "mac": {
            "description": "Sets the VNIC's MAC address. Must be valid unicast MAC address.",
            "type": "string"
          },
          "name": {
            "description": "VNIC name.",
            "type": "string"
          },
          "state": {
            "description": "Create or delete Solaris/illumos VNIC.",
            "type": "string"
          },
          "temporary": {
            "description": "Specifies that the VNIC is temporary. Temporary VNICs do not persist across reboots.",
            "type": "string"
          },
          "vlan": {
            "description": "Enable VLAN tagging for this VNIC. The VLAN tag will have id `vlan'.",
            "type": "string"
          }
        },
        "required": [
          "link",
          "name"
        ]
      }
    },
    {
      "dnf": {
        "type": "object",
        "description": "Manages packages with the `dnf' package manager",
        "properties": {
          "conf_file": {
            "description": "The remote dnf configuration file to use for the transaction.",
            "type": "string"
          },
          "disable_gpg_check": {
            "description": "Whether to disable the GPG checking of signatures of packages being installed. Has an effect only if state is `present' or `latest'.",
            "type": "string"
          },
          "disablerepo": {
            "description": "`Repoid' of repositories to disable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a \",\".",
            "type": "string"
          },
          "enablerepo": {
            "description": "`Repoid' of repositories to enable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a \",\".",
            "type": "string"
          },
          "list": {
            "description": "Various (non-idempotent) commands for usage with `/usr/bin/ansible ' and `not' playbooks. See examples.",
            "type": "string"
          },
          "name": {
            "description": "Package name, or package specifier with version, like `name-1.0'. When using state=latest, this can be '*' which means run: dnf -y update. You can also pass a url or a local path to a rpm file.",
            "type": "string"
          },
          "state": {
            "description": "Whether to install (`present', `latest'), or remove (`absent') a package.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "dnsimple": {
        "type": "object",
        "description": "Interface with dnsimple.com (a DNS hosting service).",
        "properties": {
          "account_api_token": {
            "description": "Account API token. See `account_email' for info.",
            "type": "string"
          },
          "account_email": {
            "description": "Account email. If omitted, the env variables DNSIMPLE_EMAIL and DNSIMPLE_API_ TOKEN will be looked for. If those aren't found, a `.dnsimple' file will be looked for, see: https:/ /github.com/mikem accana/dnsimple- python#getting- started",
            "type": "string"
          },
          "domain": {
            "description": "Domain to work with. Can be the domain name (e.g. \"mydomain.com\") or the numeric ID of the domain in DNSimple. If omitted, a list of domains will be returned. If domain is present but the domain doesn't exist, it will be created.",
            "type": "string"
          },
          "priority": {
            "description": "Record priority",
            "type": "string"
          },
          "record": {
            "description": "Record to add, if blank a record for the domain will be created, supports the wildcard (*)",
            "type": "string"
          },
          "record_ids": {
            "description": "List of records to ensure they either exist or don't exist",
            "type": "string"
          },
          "solo": {
            "description": "Whether the record should be the only one for that record type and record name. Only use with state=present on a record",
            "type": "string"
          },
          "state": {
            "description": "whether the record should exist or not",
            "type": "string"
          },
          "ttl": {
            "description": "The TTL to give the new record",
            "type": "string"
          },
          "type": {
            "description": "The type of DNS record to create",
            "type": "string"
          },
          "value": {
            "description": "Record value Must be specified when trying to ensure a record exists",
            "type": "string"
          }
        }
      }
    },
    {
      "dnsmadeeasy": {
        "type": "object",
        "description": "Interface with dnsmadeeasy.com (a DNS hosting service).",
        "properties": {
          "account_key": {
            "description": "Account API Key.",
            "type": "string"
          },
          "account_secret": {
            "description": "Account Secret Key.",
            "type": "string"
          },
          "domain": {
            "description": "Domain to work with. Can be the domain name (e.g. \"mydomain.com\") or the numeric ID of the domain in DNS Made Easy (e.g. \"839989\") for faster resolution.",
            "type": "string"
          },
          "record_name": {
            "description": "Record name to get/create/delete/update. If record_name is not specified; all records for the domain will be returned in \"result\" regardless of the state argument.",
            "type": "string"
          },
          "record_ttl": {
            "description": "record's \"Time to live\".  Number of seconds the record remains cached in DNS servers.",
            "type": "string"
          },
          "record_type": {
            "description": "Record type.",
            "type": "string"
          },
          "record_value": {
            "description": "Record value. HTTPRED: <redirection URL>, MX: <priority> <target name>, NS: <name server>, PTR: <target name>, SRV: <priority> <weight> <port> <target name>, TXT: <text value> If record_value is not specified; no changes will be made and the record will be returned in 'result' (in other words, this module can be used to fetch a record's current id, type, and ttl)",
            "type": "string"
          },
          "state": {
            "description": "whether the record should exist or not",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": [
          "account_key",
          "account_secret",
          "domain",
          "state"
        ]
      }
    },
    {
      "docker": {
        "type": "object",
        "description": "manage docker containers",
        "properties": {
          "cap_add": {
            "description": "Add capabilities for the container. Requires docker-py >= 0.5.0.",
            "type": "string"
          },
          "cap_drop": {
            "description": "Drop capabilities for the container. Requires docker-py >= 0.5.0.",
            "type": "string"
          },
          "command": {
            "description": "Command used to match and launch containers.",
            "type": "string"
          },
          "count": {
            "description": "Number of matching containers that should be in the desired state.",
            "type": "string"
          },
          "cpu_set": {
            "description": "CPUs in which to allow execution. Requires docker-py >= 0.6.0.",
            "type": "string"
          },
          "cpu_shares": {
            "description": "CPU shares (relative weight). Requires docker-py >= 0.6.0.",
            "type": "string"
          },
          "detach": {
            "description": "Enable detached mode to leave the container running in background. If disabled, fail unless the process exits cleanly.",
            "type": "string"
          },
          "devices": {
            "description": "List of host devices to expose to container",
            "type": "string"
          },
          "dns": {
            "description": "List of custom DNS servers for the container.",
            "type": "string"
          },
          "docker_api_version": {
            "description": "Remote API version to use. This defaults to the current default as specified by docker-py.",
            "type": "string"
          },
          "docker_url": {
            "description": "URL of the host running the docker daemon. This will default to the env var DOCKER_HOST if unspecified.",
            "type": "string"
          },
          "docker_user": {
            "description": "Username or UID to use within the container",
            "type": "string"
          },
          "domainname": {
            "description": "Container domain name.",
            "type": "string"
          },
          "email": {
            "description": "Remote API email.",
            "type": "string"
          },
          "entrypoint": {
            "description": "Corresponds to ``--entrypoint`` option of ``docker run`` command and ``ENTRYPOINT`` directive of Dockerfile. Used to match and launch containers.",
            "type": "string"
          },
          "env": {
            "description": "Pass a dict of environment variables to the container.",
            "type": "string"
          },
          "env_file": {
            "description": "Pass in a path to a file with environment variable (FOO=BAR). If a key value is present in both explicitly presented (i.e. as 'env') and in the environment file, the explicit value will override. Requires docker- py >= 1.4.0.",
            "type": "string"
          },
          "expose": {
            "description": "List of additional container ports to expose for port mappings or links. If the port is already exposed using EXPOSE in a Dockerfile, you don't need to expose it again.",
            "type": "string"
          },
          "extra_hosts": {
            "description": "Dict of custom host-to-IP mappings to be defined in the container",
            "type": "string"
          },
          "hostname": {
            "description": "Container hostname.",
            "type": "string"
          },
          "image": {
            "description": "Container image used to match and launch containers.",
            "type": "string"
          },
          "insecure_registry": {
            "description": "Use insecure private registry by HTTP instead of HTTPS. Needed for docker-py >= 0.5.0.",
            "type": "string"
          },
          "labels": {
            "description": "Set container labels. Requires docker >= 1.6 and docker-py >= 1.2.0.",
            "type": "string"
          },
          "links": {
            "description": "List of other containers to link within this container with an optional alias. Use docker CLI- style syntax: `redis:myredis'.",
            "type": "string"
          },
          "log_driver": {
            "description": "You can specify a different logging driver for the container than for the daemon. \"json- file\" Default logging driver for Docker. Writes JSON messages to file. docker logs command is available only for this logging driver. \"none\" disables any logging for the container. \"syslog\" Syslog logging driver for Docker. Writes log messages to syslog. docker logs command is not available for this logging driver. \"journald\" Journald logging driver for Docker. Writes log messages to \"journald\". \"gelf\" Graylog Extended Log Format (GELF) logging driver for Docker. Writes log messages to a GELF endpoint likeGraylog or Logstash. \"fluentd\" Fluentd logging driver for Docker. Writes log messages to \"fluentd\" (forward input). \"awslogs\" (added in 2.1) Awslogs logging driver for Docker. Writes log messages to AWS Cloudwatch Logs. If not defined explicitly, the Docker daemon's default (\"json- file\") will apply. Requires docker >= 1.6.0.",
            "type": "string"
          },
          "log_opt": {
            "description": "Additional options to pass to the logging driver selected above. See Docker `log- driver <https://d ocs.docker.com/re ference/logging/o verview/>` documentation for more information. Requires docker >=1.7.0.",
            "type": "string"
          },
          "lxc_conf": {
            "description": "LXC configuration parameters, such as `lxc.aa_profile:u nconfined'.",
            "type": "string"
          },
          "memory_limit": {
            "description": "RAM allocated to the container as a number of bytes or as a human-readable string like \"512MB\". Leave as \"0\" to specify no limit.",
            "type": "string"
          },
          "name": {
            "description": "Name used to match and uniquely name launched containers. Explicit names are used to uniquely identify a single container or to link among containers. Mutually exclusive with a \"count\" other than \"1\".",
            "type": "string"
          },
          "net": {
            "description": "Network mode for the launched container: bridge, none, container:< name|id> or host. Requires docker >= 0.11.",
            "type": "string"
          },
          "password": {
            "description": "Remote API password.",
            "type": "string"
          },
          "pid": {
            "description": "Set the PID namespace mode for the container (currently only supports 'host'). Requires docker- py >= 1.0.0 and docker >= 1.5.0",
            "type": "string"
          },
          "ports": {
            "description": "List containing private to public port mapping specification. Use docker 'CLI- style syntax: `8000', `9000:8000', or ` 0.0.0.0:9000:8000 '' where 8000 is a container port, 9000 is a host port, and 0.0.0.0 is - a host interface. The container ports need to be exposed either in the Dockerfile or via the `expose' option.",
            "type": "string"
          },
          "privileged": {
            "description": "Whether the container should run in privileged mode or not.",
            "type": "string"
          },
          "publish_all_ports": {
            "description": "Publish all exposed ports to the host interfaces.",
            "type": "string"
          },
          "pull": {
            "description": "Control when container images are updated from the `docker_url' registry. If \"missing,\" images will be pulled only when missing from the host; if '\"always,\" the registry will be checked for a newer version of the image' each time the task executes.",
            "type": "string"
          },
          "read_only": {
            "description": "Mount the container's root filesystem as read only",
            "type": "string"
          },
          "registry": {
            "description": "Remote registry URL to pull images from.",
            "type": "string"
          },
          "restart_policy": {
            "description": "Container restart policy. The 'unless-stopped' choice is only available starting in Ansible 2.1 and for Docker 1.9 and above.",
            "type": "string"
          },
          "restart_policy_retry": {
            "description": "Maximum number of times to restart a container. Leave as \"0\" for unlimited retries.",
            "type": "string"
          },
          "signal": {
            "description": "With the state \"killed\", you can alter the signal sent to the container.",
            "type": "string"
          },
          "state": {
            "description": "Assert the container's desired state. \"present\" only asserts that the matching containers exist. \"started\" asserts that the matching containers both exist and are running, but takes no action if any configuration has changed. \"reloaded\" (added in Ansible 1.9) asserts that all matching containers are running and restarts any that have any images or configuration out of date. \"restarted\" unconditionally restarts (or starts) the matching containers. \"stopped\" and '\"killed\" stop and kill all matching containers. \"absent\" stops and then' removes any matching containers.",
            "type": "string"
          },
          "stdin_open": {
            "description": "Keep stdin open after a container is launched.",
            "type": "string"
          },
          "stop_timeout": {
            "description": "How many seconds to wait for the container to stop before killing it.",
            "type": "string"
          },
          "timeout": {
            "description": "Docker daemon response timeout in seconds.",
            "type": "string"
          },
          "tls_ca_cert": {
            "description": "Path to a PEM-encoded certificate authority to secure the Docker connection. This has no effect if use_tls is encrypt.",
            "type": "string"
          },
          "tls_client_cert": {
            "description": "Path to the PEM-encoded certificate used to authenticate docker client. If specified tls_client_key must be valid",
            "type": "string"
          },
          "tls_client_key": {
            "description": "Path to the PEM-encoded key used to authenticate docker client. If specified tls_client_cert must be valid",
            "type": "string"
          },
          "tls_hostname": {
            "description": "A hostname to check matches what's supplied in the docker server's certificate.  If unspecified, the hostname is taken from the docker_url.",
            "type": "string"
          },
          "tty": {
            "description": "Allocate a pseudo-tty within the container.",
            "type": "string"
          },
          "ulimits": {
            "description": "ulimits, list ulimits with name, soft and optionally hard limit separated by colons. e.g. nofile:1024:2048 Requires docker- py >= 1.2.0 and docker >= 1.6.0",
            "type": "string"
          },
          "use_tls": {
            "description": "Whether to use tls to connect to the docker server.  \"no\" means not to use tls (and ignore any other tls related parameters). \"encrypt\" means to use tls to encrypt the connection to the server.  \"verify\" means to also verify that the server's certificate is valid for the server (this both verifies the certificate against the CA and that the certificate was issued for that host. If this is unspecified, tls will only be used if one of the other tls options require it.",
            "type": "string"
          },
          "username": {
            "description": "Remote API username.",
            "type": "string"
          },
          "volumes": {
            "description": "List of volumes to mount within the container Use docker CLI- style syntax: `/h ost:/container[:m ode]' You can specify a read mode for the mount with either `ro' or `rw'. Starting at version 2.1, SELinux hosts can additionally use `z' or `Z' mount options to use a shared or private label for the volume.",
            "type": "string"
          },
          "volumes_from": {
            "description": "List of names of containers to mount volumes from.",
            "type": "string"
          }
        },
        "required": "image"
      }
    },
    {
      "docker_container": {
        "type": "object",
        "description": "manage docker containers",
        "properties": {
          "api_version": {
            "description": "The version of the Docker API running on the Docker Host. Defaults to the latest version of the API supported by docker-py.",
            "type": "string"
          },
          "blkio_weight": {
            "description": "Block IO (relative weight), between 10 and 1000.",
            "type": "string"
          },
          "cacert_path": {
            "description": "Use a CA certificate when performing server verification by providing the path to a CA certificate file.",
            "type": "string"
          },
          "capabilities": {
            "description": "List of capabilities to add to the container.",
            "type": "string"
          },
          "cert_path": {
            "description": "Path to the client's TLS certificate file.",
            "type": "string"
          },
          "cleanup": {
            "description": "Use with `detach' to remove the container after successful execution.",
            "type": "string"
          },
          "command": {
            "description": "Command to execute when the container starts.",
            "type": "string"
          },
          "cpu_period": {
            "description": "Limit CPU CFS (Completely Fair Scheduler) period",
            "type": "string"
          },
          "cpu_quota": {
            "description": "Limit CPU CFS (Completely Fair Scheduler) quota",
            "type": "string"
          },
          "cpu_shares": {
            "description": "CPU shares (relative weight).",
            "type": "string"
          },
          "cpuset_cpus": {
            "description": "CPUs in which to allow execution `1,3' or `1-3'.",
            "type": "string"
          },
          "cpuset_mems": {
            "description": "Memory nodes (MEMs) in which to allow execution `0-3' or `0,1'",
            "type": "string"
          },
          "detach": {
            "description": "Enable detached mode to leave the container running in background. If disabled, the task will reflect the status of the container run (failed if the command failed).",
            "type": "string"
          },
          "devices": {
            "description": "List of host device bindings to add to the container. Each binding is a mapping expressed in the format: <p ath_on_host>:<pat h_in_container>:< cgroup_permission s>",
            "type": "string"
          },
          "dns_search_domains": {
            "description": "List of custom DNS search domains.",
            "type": "string"
          },
          "dns_servers": {
            "description": "List of custom DNS servers.",
            "type": "string"
          },
          "docker_host": {
            "description": "The URL or Unix socket path used to connect to the Docker API. To connect to a remote host, provide the TCP connection string. For example, 'tcp://1 92.0.2.23:2376'. If TLS is used to encrypt the connection, the module will automatically replace 'tcp' in the connection URL with 'https'.",
            "type": "string"
          },
          "entrypoint": {
            "description": "Command that overwrites the default ENTRYPOINT of the image.",
            "type": "string"
          },
          "env": {
            "description": "Dictionary of key,value pairs.",
            "type": "string"
          },
          "env_file": {
            "description": "Path to a file containing environment variables `FOO=BAR'. If variable also present in `env', then `env' value will override. Requires docker- py >= 1.4.0.",
            "type": "string"
          },
          "etc_hosts": {
            "description": "Dict of host-to-IP mappings, where each host name is a key in the dictionary. Each host name will be added to the container's /etc/hosts file.",
            "type": "string"
          },
          "exposed_ports": {
            "description": "List of additional container ports which informs Docker that the container listens on the specified network ports at runtime. If the port is already exposed using EXPOSE in a Dockerfile, it does not need to be exposed again.",
            "type": "string"
          },
          "force_kill": {
            "description": "Use the kill command when stopping a running container.",
            "type": "string"
          },
          "groups": {
            "description": "List of additional group names and/or IDs that the container process will run as.",
            "type": "string"
          },
          "hostname": {
            "description": "Container hostname.",
            "type": "string"
          },
          "ignore_image": {
            "description": "When `state' is `present' or `started' the module compares the configuration of an existing container to requested configuration. The evaluation includes the image version. If the image version in the registry does not match the container, the container will be recreated. Stop this behavior by setting `ignore_image' to `True'.",
            "type": "string"
          },
          "image": {
            "description": "Repository path and tag used to create the container. If an image is not found or pull is true, the image will be pulled from the registry. If no tag is included, 'latest' will be used.",
            "type": "string"
          },
          "interactive": {
            "description": "Keep stdin open after a container is launched, even if not attached.",
            "type": "string"
          },
          "ipc_mode": {
            "description": "Set the IPC mode for the container. Can be one of 'container:<na me|id>' to reuse another container's IPC namespace or 'host' to use the host's IPC namespace within the container.",
            "type": "string"
          },
          "keep_volumes": {
            "description": "Retain volumes associated with a removed container.",
            "type": "string"
          },
          "kernel_memory": {
            "description": "Kernel memory limit (format: <number>[<unit>]). Number is a positive integer. Unit can be one of b, k, m, or g. Minimum is 4M.",
            "type": "string"
          },
          "key_path": {
            "description": "Path to the client's TLS key file.",
            "type": "string"
          },
          "kill_signal": {
            "description": "Override default signal used to kill a running container.",
            "type": "string"
          },
          "labels": {
            "description": "Dictionary of key value pairs.",
            "type": "string"
          },
          "links": {
            "description": "List of name aliases for linked containers in the format `conta iner_name:alias'",
            "type": "string"
          },
          "log_driver": {
            "description": "Specify the logging driver. Docker uses json- file by default.",
            "type": "string"
          },
          "log_options": {
            "description": "Dictionary of options specific to the chosen log_driver. See h ttps://docs.docke r.com/engine/admi n/logging/overvie w/ for details.",
            "type": "string"
          },
          "mac_address": {
            "description": "Container MAC address (e.g. 92:d0:c6:0a:29:33)",
            "type": "string"
          },
          "memory": {
            "description": "Memory limit (format: <number>[<unit>]). Number is a positive integer. Unit can be one of b, k, m, or g",
            "type": "string"
          },
          "memory_reservation": {
            "description": "Memory soft limit (format: <number>[<unit>]). Number is a positive integer. Unit can be one of b, k, m, or g",
            "type": "string"
          },
          "memory_swap": {
            "description": "Total memory limit (memory + swap, format:<number>[< unit>]). Number is a positive integer. Unit can be one of b, k, m, or g.",
            "type": "string"
          },
          "memory_swappiness": {
            "description": "Tune a container's memory swappiness behavior. Accepts an integer between 0 and 100.",
            "type": "string"
          },
          "name": {
            "description": "Assign a name to a new container or match an existing container. When identifying an existing container name may be a name or a long or short container ID.",
            "type": "string"
          },
          "network_mode": {
            "description": "Connect the container to a network.",
            "type": "string"
          },
          "networks": {
            "description": "List of networks the container belongs to. Each network is a dict with keys `name', `ipv4_address', `ipv6_address', `links', `aliases'. For each network `name' is required, all other keys are optional. If included, `links' or `aliases' are lists. For examples of the data structure and usage see EXAMPLES below. To remove a container from one or more networks, use the `purge_networks' option.",
            "type": "string"
          },
          "oom_killer": {
            "description": "Whether or not to disable OOM Killer for the container.",
            "type": "string"
          },
          "oom_score_adj": {
            "description": "An integer value containing the score given to the container in order to tune OOM killer preferences.",
            "type": "string"
          },
          "paused": {
            "description": "Use with the started state to pause running processes inside the container.",
            "type": "string"
          },
          "pid_mode": {
            "description": "Set the PID namespace mode for the container. Currently only supports 'host'.",
            "type": "string"
          },
          "privileged": {
            "description": "Give extended privileges to the container.",
            "type": "string"
          },
          "published_ports": {
            "description": "List of ports to publish from the container to the host. Use docker CLI syntax: `8000', `9000:8000', or ` 0.0.0.0:9000:8000 ', where 8000 is a container port, 9000 is a host port, and 0.0.0.0 is a host interface. Container ports must be exposed either in the Dockerfile or via the `expose' option. A value of ALL will publish all exposed container ports to random host ports, ignoring any other mappings. If `networks' parameter is provided, will inspect each network to see if there exists a bridge network with optional parameter com.doc ker.network.bridg e.host_binding_ip v4. If such a network is found, then published ports where no host IP address is specified will be bound to the host IP pointed to by com.docker. network.bridge.ho st_binding_ipv4. Note that the first bridge network with a co m.docker.network. bridge.host_bindi ng_ipv4 value encountered in the list of `networks' is the one that will be used.",
            "type": "string"
          },
          "pull": {
            "description": "If true, always pull the latest version of an image. Otherwise, will only pull an image when missing.",
            "type": "string"
          },
          "purge_networks": {
            "description": "Remove the container from ALL networks not included in `networks' parameter. Any default networks such as `bridge', if not found in `networks', will be removed as well.",
            "type": "string"
          },
          "read_only": {
            "description": "Mount the container's root file system as read- only.",
            "type": "string"
          },
          "recreate": {
            "description": "Use with present and started states to force the re-creation of an existing container.",
            "type": "string"
          },
          "restart": {
            "description": "Use with started state to force a matching container to be stopped and restarted.",
            "type": "string"
          },
          "restart_policy": {
            "description": "Container restart policy. Place quotes around `no' option.",
            "type": "string"
          },
          "restart_retries": {
            "description": "Use with restart policy to control maximum number of restart attempts.",
            "type": "string"
          },
          "security_opts": {
            "description": "List of security options in the form of `\"label:user:User \"'",
            "type": "string"
          },
          "shm_size": {
            "description": "Size of `/dev/shm`. The format is `<number><unit>`. `number` must be greater than `0`. Unit is optional and can be `b` (bytes), `k` (kilobytes), `m` (megabytes), or `g` (gigabytes). Omitting the unit defaults to bytes. If you omit the size entirely, the system uses `64m`.",
            "type": "string"
          },
          "ssl_version": {
            "description": "Provide a valid SSL version number. Default value determined by docker-py, currently 1.0.",
            "type": "string"
          },
          "state": {
            "description": "`absent' - A container matching the specified name will be stopped and removed. Use force_kill to kill the container rather than stopping it. Use keep_volumes to retain volumes associated with the removed container. `present' - Asserts the existence of a container matching the name and any provided configuration parameters. If no container matches the name, a container will be created. If a container matches the name but the provided configuration does not match, the container will be updated, if it can be. If it cannot be updated, it will be removed and re-created with the requested config. Image version will be taken into account when comparing configuration. To ignore image version use the ignore_image option. Use the recreate option to force the re- creation of the matching container. Use force_kill to kill the container rather than stopping it. Use keep_volumes to retain volumes associated with a removed container. `started' - Asserts there is a running container matching the name and any provided configuration. If no container matches the name, a container will be created and started. If a container matching the name is found but the configuration does not match, the container will be updated, if it can be. If it cannot be updated, it will be removed and a new container will be created with the requested configuration and started. Image version will be taken into account when comparing configuration. To ignore image version use the ignore_image option. Use recreate to always re-create a matching container, even if it is running. Use restart to force a matching container to be stopped and restarted. Use force_kill to kill a container rather than stopping it. Use keep_volumes to retain volumes associated with a removed container. `stopped' - Asserts that the container is first `present', and then if the container is running moves it to a stopped state. Use force_kill to kill a container rather than stopping it.",
            "type": "string"
          },
          "stop_signal": {
            "description": "Override default signal used to stop the container.",
            "type": "string"
          },
          "stop_timeout": {
            "description": "Number of seconds to wait for the container to stop before sending SIGKILL.",
            "type": "string"
          },
          "timeout": {
            "description": "The maximum amount of time in seconds to wait on a response from the API.",
            "type": "string"
          },
          "tls": {
            "description": "Secure the connection to the API by using TLS without verifying the authenticity of the Docker host server.",
            "type": "string"
          },
          "tls_hostname": {
            "description": "When verifying the authenticity of the Docker Host server, provide the expected name of the server.",
            "type": "string"
          },
          "tls_verify": {
            "description": "Secure the connection to the API by using TLS and verifying the authenticity of the Docker host server.",
            "type": "string"
          },
          "trust_image_content": {
            "description": "If true, skip image verification.",
            "type": "string"
          },
          "tty": {
            "description": "Allocate a psuedo-TTY.",
            "type": "string"
          },
          "ulimits": {
            "description": "List of ulimit options. A ulimit is specified as `nofile:262144:26 2144'",
            "type": "string"
          },
          "user": {
            "description": "Sets the username or UID used and optionally the groupname or GID for the specified command. Can be [ user | user:group | uid | uid:gid | user:gid | uid:group ]",
            "type": "string"
          },
          "uts": {
            "description": "Set the UTS namespace mode for the container.",
            "type": "string"
          },
          "volume_driver": {
            "description": "The container volume driver.",
            "type": "string"
          },
          "volumes": {
            "description": "List of volumes to mount within the container. Use docker CLI- style syntax: `/h ost:/container[:m ode]' You can specify a read mode for the mount with either `ro' or `rw'. SELinux hosts can additionally use `z' or `Z' to use a shared or private label for the volume.",
            "type": "string"
          },
          "volumes_from": {
            "description": "List of container names or Ids to get volumes from.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "docker_image": {
        "type": "object",
        "description": "Manage docker images.",
        "properties": {
          "api_version": {
            "description": "The version of the Docker API running on the Docker Host. Defaults to the latest version of the API supported by docker-py.",
            "type": "string"
          },
          "archive_path": {
            "description": "Use with state `present' to archive an image to a .tar file.",
            "type": "string"
          },
          "buildargs": {
            "description": "Provide a dictionary of `key:value' build arguments that map to Dockerfile ARG directive. Docker expects the value to be a string. For convenience any non-string values will be converted to strings. Requires Docker API >= 1.21 and docker-py >= 1.7.0.",
            "type": "string"
          },
          "cacert_path": {
            "description": "Use a CA certificate when performing server verification by providing the path to a CA certificate file.",
            "type": "string"
          },
          "cert_path": {
            "description": "Path to the client's TLS certificate file.",
            "type": "string"
          },
          "container_limits": {
            "description": "A dictionary of limits applied to each container created by the build process.",
            "type": "string"
          },
          "docker_host": {
            "description": "The URL or Unix socket path used to connect to the Docker API. To connect to a remote host, provide the TCP connection string. For example, 'tcp://1 92.0.2.23:2376'. If TLS is used to encrypt the connection, the module will automatically replace 'tcp' in the connection URL with 'https'.",
            "type": "string"
          },
          "dockerfile": {
            "description": "Use with state `present' to provide an alternate name for the Dockerfile to use when building an image.",
            "type": "string"
          },
          "force": {
            "description": "Use with state `absent' to un-tag and remove all images matching the specified name. Use with state `present' to build, load or pull an image when the image already exists.",
            "type": "string"
          },
          "http_timeout": {
            "description": "Timeout for HTTP requests during the image build operation. Provide a positive integer value for the number of seconds.",
            "type": "string"
          },
          "key_path": {
            "description": "Path to the client's TLS key file.",
            "type": "string"
          },
          "load_path": {
            "description": "Use with state `present' to load an image from a .tar file.",
            "type": "string"
          },
          "name": {
            "description": "Image name. Name format will be one of: name, repository/name,  registry_server:p ort/name. When pushing or pulling an image the name can optionally include the tag by appending ':tag_name'.",
            "type": "string"
          },
          "nocache": {
            "description": "Do not use cache when building an image.",
            "type": "string"
          },
          "path": {
            "description": "Use with state 'present' to build an image. Will be the path to a directory containing the context and Dockerfile for building an image.",
            "type": "string"
          },
          "pull": {
            "description": "When building an image downloads any updates to the FROM image in Dockerfile.",
            "type": "string"
          },
          "push": {
            "description": "Push the image to the registry. Specify the registry as part of the `name' or `repository' parameter.",
            "type": "string"
          },
          "repository": {
            "description": "Full path to a repository. Use with state `present' to tag the image into the repository. Expects format `repository:tag'. If no tag is provided, will use the value of the `tag' parameter or `latest'.",
            "type": "string"
          },
          "rm": {
            "description": "Remove intermediate containers after build.",
            "type": "string"
          },
          "ssl_version": {
            "description": "Provide a valid SSL version number. Default value determined by docker-py, currently 1.0.",
            "type": "string"
          },
          "state": {
            "description": "Make assertions about the state of an image. When `absent' an image will be removed. Use the force option to un-tag and remove all images matching the provided name. When `present' check if an image exists using the provided name and tag. If the image is not found or the force option is used, the image will either be pulled, built or loaded. By default the image will be pulled from Docker Hub. To build the image, provide a path value set to a directory containing a context and Dockerfile. To load an image, specify load_path to provide a path to an archive file. To tag an image to a repository, provide a repository path. If the name contains a repository path, it will be pushed. NOTE: `build' is DEPRECATED and will be removed in release 2.3. Specifying `build' will behave the same as `present'.",
            "type": "string"
          },
          "tag": {
            "description": "Used to select an image when pulling. Will be added to the image when pushing, tagging or building. Defaults to `latest'. If `name' parameter format is `name:tag', then tag value from `name' will take precedence.",
            "type": "string"
          },
          "timeout": {
            "description": "The maximum amount of time in seconds to wait on a response from the API.",
            "type": "string"
          },
          "tls": {
            "description": "Secure the connection to the API by using TLS without verifying the authenticity of the Docker host server.",
            "type": "string"
          },
          "tls_hostname": {
            "description": "When verifying the authenticity of the Docker Host server, provide the expected name of the server.",
            "type": "string"
          },
          "tls_verify": {
            "description": "Secure the connection to the API by using TLS and verifying the authenticity of the Docker host server.",
            "type": "string"
          },
          "use_tls": {
            "description": "DEPRECATED. Whether to use tls to connect to the docker server. Set to `no' when TLS will not be used. Set to `encrypt' to use TLS. And set to `verify' to use TLS and verify that the server's certificate is valid for the server. NOTE: If you specify this option, it will set the value of the tls or tls_verify parameters.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "docker_image_facts": {
        "type": "object",
        "description": "Inspect docker images",
        "properties": {
          "api_version": {
            "description": "The version of the Docker API running on the Docker Host. Defaults to the latest version of the API supported by docker-py.",
            "type": "string"
          },
          "cacert_path": {
            "description": "Use a CA certificate when performing server verification by providing the path to a CA certificate file.",
            "type": "string"
          },
          "cert_path": {
            "description": "Path to the client's TLS certificate file.",
            "type": "string"
          },
          "docker_host": {
            "description": "The URL or Unix socket path used to connect to the Docker API. To connect to a remote host, provide the TCP connection string. For example, 'tcp://1 92.0.2.23:2376'. If TLS is used to encrypt the connection, the module will automatically replace 'tcp' in the connection URL with 'https'.",
            "type": "string"
          },
          "key_path": {
            "description": "Path to the client's TLS key file.",
            "type": "string"
          },
          "name": {
            "description": "An image name or a list of image names. Name format will be name[:tag] or rep ository/name[:tag ], where tag is optional. If a tag is not provided, 'latest' will be used.",
            "type": "string"
          },
          "ssl_version": {
            "description": "Provide a valid SSL version number. Default value determined by docker-py, currently 1.0.",
            "type": "string"
          },
          "timeout": {
            "description": "The maximum amount of time in seconds to wait on a response from the API.",
            "type": "string"
          },
          "tls": {
            "description": "Secure the connection to the API by using TLS without verifying the authenticity of the Docker host server.",
            "type": "string"
          },
          "tls_hostname": {
            "description": "When verifying the authenticity of the Docker Host server, provide the expected name of the server.",
            "type": "string"
          },
          "tls_verify": {
            "description": "Secure the connection to the API by using TLS and verifying the authenticity of the Docker host server.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "docker_login": {
        "type": "object",
        "description": "Log into a Docker registry.",
        "properties": {
          "api_version": {
            "description": "The version of the Docker API running on the Docker Host. Defaults to the latest version of the API supported by docker-py.",
            "type": "string"
          },
          "cacert_path": {
            "description": "Use a CA certificate when performing server verification by providing the path to a CA certificate file.",
            "type": "string"
          },
          "cert_path": {
            "description": "Path to the client's TLS certificate file.",
            "type": "string"
          },
          "config_path": {
            "description": "Custom path to the Docker CLI configuration file.",
            "type": "string"
          },
          "docker_host": {
            "description": "The URL or Unix socket path used to connect to the Docker API. To connect to a remote host, provide the TCP connection string. For example, 'tcp://1 92.0.2.23:2376'. If TLS is used to encrypt the connection, the module will automatically replace 'tcp' in the connection URL with 'https'.",
            "type": "string"
          },
          "email": {
            "description": "The email address for the registry account. NOTE: private registries may not require this, but Docker Hub requires it.",
            "type": "string"
          },
          "key_path": {
            "description": "Path to the client's TLS key file.",
            "type": "string"
          },
          "password": {
            "description": "The plaintext password for the registry account",
            "type": "string"
          },
          "reauthorize": {
            "description": "Refresh exiting authentication found in the configuration file.",
            "type": "string"
          },
          "registry_url": {
            "description": "The registry URL.",
            "type": "string"
          },
          "ssl_version": {
            "description": "Provide a valid SSL version number. Default value determined by docker-py, currently 1.0.",
            "type": "string"
          },
          "timeout": {
            "description": "The maximum amount of time in seconds to wait on a response from the API.",
            "type": "string"
          },
          "tls": {
            "description": "Secure the connection to the API by using TLS without verifying the authenticity of the Docker host server.",
            "type": "string"
          },
          "tls_hostname": {
            "description": "When verifying the authenticity of the Docker Host server, provide the expected name of the server.",
            "type": "string"
          },
          "tls_verify": {
            "description": "Secure the connection to the API by using TLS and verifying the authenticity of the Docker host server.",
            "type": "string"
          },
          "username": {
            "description": "The username for the registry account",
            "type": "string"
          }
        },
        "required": [
          "password",
          "username"
        ]
      }
    },
    {
      "docker_network": {
        "type": "object",
        "description": "Manage Docker networks",
        "properties": {
          "api_version": {
            "description": "The version of the Docker API running on the Docker Host. Defaults to the latest version of the API supported by docker-py.",
            "type": "string"
          },
          "appends": {
            "description": "By default the connected list is canonical, meaning containers not on the list are removed from the network. Use `appends' to leave existing containers connected.",
            "type": "string"
          },
          "cacert_path": {
            "description": "Use a CA certificate when performing server verification by providing the path to a CA certificate file.",
            "type": "string"
          },
          "cert_path": {
            "description": "Path to the client's TLS certificate file.",
            "type": "string"
          },
          "connected": {
            "description": "List of container names or container IDs to connect to a network.",
            "type": "string"
          },
          "docker_host": {
            "description": "The URL or Unix socket path used to connect to the Docker API. To connect to a remote host, provide the TCP connection string. For example, 'tcp://1 92.0.2.23:2376'. If TLS is used to encrypt the connection, the module will automatically replace 'tcp' in the connection URL with 'https'.",
            "type": "string"
          },
          "driver": {
            "description": "Specify the type of network. Docker provides bridge and overlay drivers, but 3rd party drivers can also be used.",
            "type": "string"
          },
          "driver_options": {
            "description": "Dictionary of network settings. Consult docker docs for valid options and values.",
            "type": "string"
          },
          "force": {
            "description": "With state `absent' forces disconnecting all containers from the network prior to deleting the network. With state `present' will disconnect all containers, delete the network and re- create the network.  This option is required if you have changed the IPAM or driver options and want an existing network to be updated to use the new options.",
            "type": "string"
          },
          "ipam_driver": {
            "description": "Specify an IPAM driver.",
            "type": "string"
          },
          "ipam_options": {
            "description": "Dictionary of IPAM options.",
            "type": "string"
          },
          "key_path": {
            "description": "Path to the client's TLS key file.",
            "type": "string"
          },
          "name": {
            "description": "Name of the network to operate on.",
            "type": "string"
          },
          "ssl_version": {
            "description": "Provide a valid SSL version number. Default value determined by docker-py, currently 1.0.",
            "type": "string"
          },
          "state": {
            "description": "`absent' deletes the network. If a network has connected containers, it cannot be deleted. Use the `force' option to disconnect all containers and delete the network. `present' creates the network, if it does not already exist with the specified parameters, and connects the list of containers provided via the connected parameter. Containers not on the list will be disconnected. An empty list will leave no containers connected to the network. Use the `appends' option to leave existing containers connected. Use the `force' options to force re-creation of the network.",
            "type": "string"
          },
          "timeout": {
            "description": "The maximum amount of time in seconds to wait on a response from the API.",
            "type": "string"
          },
          "tls": {
            "description": "Secure the connection to the API by using TLS without verifying the authenticity of the Docker host server.",
            "type": "string"
          },
          "tls_hostname": {
            "description": "When verifying the authenticity of the Docker Host server, provide the expected name of the server.",
            "type": "string"
          },
          "tls_verify": {
            "description": "Secure the connection to the API by using TLS and verifying the authenticity of the Docker host server.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "docker_service": {
        "type": "object",
        "description": "Manage docker services and containers.",
        "properties": {
          "api_version": {
            "description": "The version of the Docker API running on the Docker Host. Defaults to the latest version of the API supported by docker-py.",
            "type": "string"
          },
          "build": {
            "description": "Use with state `present' to always build images prior to starting the application. Same as running docker-compose build with the pull option. Images will only be rebuilt if Docker detects a change in the Dockerfile or build directory contents. Use the `nocache' option to ignore the image cache when performing the build. If an existing image is replaced, services using the image will be recreated unless `recreate' is `never'.",
            "type": "string"
          },
          "cacert_path": {
            "description": "Use a CA certificate when performing server verification by providing the path to a CA certificate file.",
            "type": "string"
          },
          "cert_path": {
            "description": "Path to the client's TLS certificate file.",
            "type": "string"
          },
          "debug": {
            "description": "Include `actions' in the return values.",
            "type": "string"
          },
          "definition": {
            "description": "Provide docker-compose yaml describing one or more services, networks and volumes. Mutually exclusive with `project_src' and `files'.",
            "type": "string"
          },
          "dependencies": {
            "description": "When `state' is `present' specify whether or not to include linked services.",
            "type": "string"
          },
          "docker_host": {
            "description": "The URL or Unix socket path used to connect to the Docker API. To connect to a remote host, provide the TCP connection string. For example, 'tcp://1 92.0.2.23:2376'. If TLS is used to encrypt the connection, the module will automatically replace 'tcp' in the connection URL with 'https'.",
            "type": "string"
          },
          "files": {
            "description": "List of file names relative to `project_src'. Overrides docker- compose.yml or docker- compose.yaml. Files are loaded and merged in the order given.",
            "type": "string"
          },
          "hostname_check": {
            "description": "Whether or not to check the Docker daemon's hostname against the name provided in the client certificate.",
            "type": "string"
          },
          "key_path": {
            "description": "Path to the client's TLS key file.",
            "type": "string"
          },
          "nocache": {
            "description": "Use with the build option to ignore the cache during the image build process.",
            "type": "string"
          },
          "project_name": {
            "description": "Provide a project name. If not provided, the project name is taken from the basename of `project_src'. Required when no `definition' is provided.",
            "type": "string"
          },
          "project_src": {
            "description": "Path to a directory containing a docker- compose.yml or docker- compose.yaml file. Mutually exclusive with `definition'. Required when no `definition' is provided.",
            "type": "string"
          },
          "pull": {
            "description": "Use with state `present' to always pull images prior to starting the application. Same as running docker-compose pull. When a new image is pulled, services using the image will be recreated unless `recreate' is `never'.",
            "type": "string"
          },
          "recreate": {
            "description": "By default containers will be recreated when their configuration differs from the service definition. Setting to `never' ignores configuration differences and leaves existing containers unchanged. Setting to `always' forces recreation of all existing containers.",
            "type": "string"
          },
          "remove_images": {
            "description": "Use with state `absent' to remove the all images or only local images.",
            "type": "string"
          },
          "remove_volumes": {
            "description": "Use with state `absent' to remove data volumes.",
            "type": "string"
          },
          "restarted": {
            "description": "Use with state `present' to restart all containers.",
            "type": "string"
          },
          "scale": {
            "description": "When `state' is `present' scale services. Provide a dictionary of key/value pairs where the key is the name of the service and the value is an integer count for the number of containers.",
            "type": "string"
          },
          "services": {
            "description": "When `state' is `present' run `docker-compose up' on a subset of services.",
            "type": "string"
          },
          "ssl_version": {
            "description": "Provide a valid SSL version number. Default value determined by docker-py, currently 1.0.",
            "type": "string"
          },
          "state": {
            "description": "Desired state of the project. Specifying `present' is the same as running `docker-compose up'. Specifying `absent' is the same as running `docker-compose down'.",
            "type": "string"
          },
          "stopped": {
            "description": "Use with state `present' to leave the containers in an exited or non-running state.",
            "type": "string"
          },
          "timeout": {
            "description": "The maximum amount of time in seconds to wait on a response from the API.",
            "type": "string"
          },
          "tls": {
            "description": "Secure the connection to the API by using TLS without verifying the authenticity of the Docker host server.",
            "type": "string"
          },
          "tls_hostname": {
            "description": "When verifying the authenticity of the Docker Host server, provide the expected name of the server.",
            "type": "string"
          },
          "tls_verify": {
            "description": "Secure the connection to the API by using TLS and verifying the authenticity of the Docker host server.",
            "type": "string"
          }
        }
      }
    },
    {
      "dpkg_selections": {
        "type": "object",
        "description": "Dpkg package selection selections",
        "properties": {
          "name": {
            "description": "Name of the package",
            "type": "string"
          },
          "selection": {
            "description": "The selection state to set the package to.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "selection"
        ]
      }
    },
    {
      "dynamodb_table": {
        "type": "object",
        "description": "Create, update or delete AWS Dynamo DB tables.",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "hash_key_name": {
            "description": "Name of the hash key. Required when `state=present'.",
            "type": "string"
          },
          "hash_key_type": {
            "description": "Type of the hash key.",
            "type": "string"
          },
          "indexes": {
            "description": "list of dictionaries describing indexes to add to the table. global indexes can be updated. local indexes don't support updates or have throughput. required options: ['name', 'type', 'hash_key_name'] valid types: ['all', 'global_all', 'global_include', 'global_keys_only ', 'include', 'keys_only'] other options: ['hash_key_type', 'range_key_name', 'range_key_type', 'includes', 'read_capacity', 'write_capacity']",
            "type": "string"
          },
          "name": {
            "description": "Name of the table.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "range_key_name": {
            "description": "Name of the range key.",
            "type": "string"
          },
          "range_key_type": {
            "description": "Type of the range key.",
            "type": "string"
          },
          "read_capacity": {
            "description": "Read throughput capacity (units) to provision.",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "Create or delete the table",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "write_capacity": {
            "description": "Write throughput capacity (units) to provision.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "easy_install": {
        "type": "object",
        "description": "Installs Python libraries",
        "properties": {
          "executable": {
            "description": "The explicit executable or a pathname to the executable to be used to run easy_install for a specific version of Python installed in the system. For example `easy_ins tall-3.3', if there are both Python 2.7 and 3.3 installations in the system and you want to run easy_install for the Python 3.3 installation.",
            "type": "string"
          },
          "name": {
            "description": "A Python library name",
            "type": "string"
          },
          "state": {
            "description": "The desired state of the library. `latest' ensures that the latest version is installed.",
            "type": "string"
          },
          "virtualenv": {
            "description": "an optional `virtualenv' directory path to install into. If the `virtualenv' does not exist, it is created automatically",
            "type": "string"
          },
          "virtualenv_command": {
            "description": "The command to create the virtual environment with. For example `pyvenv', `virtualenv', `virtualenv2'.",
            "type": "string"
          },
          "virtualenv_site_packages": {
            "description": "Whether the virtual environment will inherit packages from the global site- packages directory.  Note that if this setting is changed on an already existing virtual environment it will not have any effect, the environment must be deleted and newly created.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "ec2": {
        "type": "object",
        "description": "create, terminate, start or stop an instance in ec2",
        "properties": {
          "assign_public_ip": {
            "description": "when provisioning within vpc, assign a public IP address. Boto library must be 2.13.0+",
            "type": "string"
          },
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "count": {
            "description": "number of instances to launch",
            "type": "string"
          },
          "count_tag": {
            "description": "Used with 'exact_count' to determine how many nodes based on a specific tag criteria should be running.  This can be expressed in multiple ways and is shown in the EXAMPLES section.  For instance, one can request 25 servers that are tagged with \"clas s=webserver\". The specified tag must already exist or be passed in as the 'instance_tags' option.",
            "type": "string"
          },
          "ebs_optimized": {
            "description": "whether instance is using optimized EBS volumes, see http://docs.a ws.amazon.com/AWS EC2/latest/UserGu ide/EBSOptimized. html",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "exact_count": {
            "description": "An integer value which indicates how many instances that match the 'count_tag' parameter should be running. Instances are either created or terminated based on this value.",
            "type": "string"
          },
          "group": {
            "description": "security group (or list of groups) to use with the instance",
            "type": "string"
          },
          "group_id": {
            "description": "security group id (or list of ids) to use with the instance",
            "type": "string"
          },
          "image": {
            "description": "`ami' ID to use for the instance",
            "type": "string"
          },
          "instance_ids": {
            "description": "list of instance ids, currently used for states: absent, running, stopped",
            "type": "string"
          },
          "instance_initiated_shutdown_behavior": {
            "description": "Set whether AWS will Stop or Terminate an instance on shutdown",
            "type": "string"
          },
          "instance_profile_name": {
            "description": "Name of the IAM instance profile to use. Boto library must be 2.5.0+",
            "type": "string"
          },
          "instance_tags": {
            "description": "a hash/dictionary of tags to add to the new instance or for starting/stopping instance by tag; '{\"key\":\"value\"}' and '{\"key\":\"valu e\",\"key\":\"value\"} '",
            "type": "string"
          },
          "instance_type": {
            "description": "instance type to use for the instance, see http: //docs.aws.amazon .com/AWSEC2/lates t/UserGuide /instance- types.html",
            "type": "string"
          },
          "kernel": {
            "description": "kernel `eki' to use for the instance",
            "type": "string"
          },
          "key_name": {
            "description": "key pair to use on the instance",
            "type": "string"
          },
          "monitoring": {
            "description": "enable detailed monitoring (CloudWatch) for instance",
            "type": "string"
          },
          "network_interfaces": {
            "description": "A list of existing network interfaces to attach to the instance at launch. When specifying existing network interfaces, none of the assign_public_ip, private_ip, vpc_subnet_id, group, or group_id parameters may be used. (Those parameters are for creating a new network interface at launch.)",
            "type": "string"
          },
          "placement_group": {
            "description": "placement group for the instance when using EC2 Clustered Compute",
            "type": "string"
          },
          "private_ip": {
            "description": "the private ip address to assign the instance (from the vpc subnet)",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "ramdisk": {
            "description": "ramdisk `eri' to use for the instance",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use.  Must be specified if ec2_url is not used. If not specified then the value of the EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "source_dest_check": {
            "description": "Enable or Disable the Source/Destination checks (for NAT instances and Virtual Routers)",
            "type": "string"
          },
          "spot_launch_group": {
            "description": "Launch group for spot request, see http://docs.a ws.amazon.com/AWS EC2/latest/UserGu ide/how-spot- instances- work.html#spot- launch-group",
            "type": "string"
          },
          "spot_price": {
            "description": "Maximum spot price to bid, If not set a regular on-demand instance is requested. A spot request is made with this maximum bid. When it is filled, the instance is started.",
            "type": "string"
          },
          "spot_type": {
            "description": "Type of spot request; one of \"one-time\" or \"persistent\". Defaults to \"one- time\" if not supplied.",
            "type": "string"
          },
          "spot_wait_timeout": {
            "description": "how long to wait for the spot instance request to be fulfilled",
            "type": "string"
          },
          "state": {
            "description": "create or terminate instances",
            "type": "string"
          },
          "tenancy": {
            "description": "An instance with a tenancy of \"dedicated\" runs on single-tenant hardware and can only be launched into a VPC. Note that to use dedicated tenancy you MUST specify a vpc_subnet_id as well. Dedicated tenancy is not available for EC2 \"micro\" instances.",
            "type": "string"
          },
          "termination_protection": {
            "description": "Enable or Disable the Termination Protection",
            "type": "string"
          },
          "user_data": {
            "description": "opaque blob of data which is made available to the ec2 instance",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "volumes": {
            "description": "a list of hash/dictionaries of volumes to add to the new instance; '[{\"key\":\"value\", \"key\":\"value\"}]'; keys allowed are - device_name (str; required),  delete_on_termina tion (bool; False), device_type (deprecated), ephemeral (str), encrypted (bool; False), snapshot (str), volume_type (str), iops (int) - device_type is deprecated use volume_type, iops must be set when  volume_type='io1' , ephemeral and snapshot are mutually exclusive.",
            "type": "string"
          },
          "vpc_subnet_id": {
            "description": "the subnet ID in which to launch the instance (VPC)",
            "type": "string"
          },
          "wait": {
            "description": "wait for the instance to be 'running' before returning.  Does not wait for SSH, see 'wait_for' example for details.",
            "type": "string"
          },
          "wait_timeout": {
            "description": "how long before wait gives up, in seconds",
            "type": "string"
          },
          "zone": {
            "description": "AWS availability zone in which to launch the instance",
            "type": "string"
          }
        },
        "required": [
          "image",
          "instance_type"
        ]
      }
    },
    {
      "ec2_ami": {
        "type": "object",
        "description": "create or destroy an image in ec2",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "delete_snapshot": {
            "description": "Whether or not to delete snapshots when deregistering AMI.",
            "type": "string"
          },
          "description": {
            "description": "An optional human-readable string describing the contents and purpose of the AMI.",
            "type": "string"
          },
          "device_mapping": {
            "description": "An optional list of device hashes/dictionaries with custom configurations (same block- device-mapping parameters) Valid properties include: device_name, volume_type, size (in GB), delete_o n_termination (boolean), no_device (boolean), snapshot_id, iops (for io1 volume_type)",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "image_id": {
            "description": "Image ID to be deregistered.",
            "type": "string"
          },
          "instance_id": {
            "description": "instance id of the image to create",
            "type": "string"
          },
          "launch_permissions": {
            "description": "Users and groups that should be able to launch the ami. Expects dictionary with a key of user_ids and/or group_names. user_ids should be a list of account ids. group_name should be a list of groups, \"all\" is the only acceptable value currently.",
            "type": "string"
          },
          "name": {
            "description": "The name of the new image to create",
            "type": "string"
          },
          "no_reboot": {
            "description": "An optional flag indicating that the bundling process should not attempt to shutdown the instance before bundling. If this flag is True, the responsibility of maintaining file system integrity is left to the owner of the instance. The default choice is \"no\".",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "create or deregister/delete image",
            "type": "string"
          },
          "tags": {
            "description": "a dictionary of tags to add to the new image; '{\"key\":\"value\"}' and '{\"key\":\"valu e\",\"key\":\"value\"} '",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "wait": {
            "description": "wait for the AMI to be in state 'available' before returning.",
            "type": "string"
          },
          "wait_timeout": {
            "description": "how long before wait gives up, in seconds",
            "type": "string"
          }
        }
      }
    },
    {
      "ec2_ami_copy": {
        "type": "object",
        "description": "copies AMI between AWS regions, return new image id",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "description": {
            "description": "An optional human-readable string describing the contents and purpose of the new AMI.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "encrypted": {
            "description": "Whether or not to encrypt the target image",
            "type": "string"
          },
          "kms_key_id": {
            "description": "KMS key id used to encrypt image. If not specified, uses default EBS Customer Master Key (CMK) for your account.",
            "type": "string"
          },
          "name": {
            "description": "The name of the new image to copy",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "source_image_id": {
            "description": "the id of the image in source region that should be copied",
            "type": "string"
          },
          "source_region": {
            "description": "the source region that AMI should be copied from",
            "type": "string"
          },
          "tags": {
            "description": "a hash/dictionary of tags to add to the new copied AMI; '{\"key\":\"value\"}' and '{\"key\":\"valu e\",\"key\":\"value\"} '",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "wait": {
            "description": "wait for the copied AMI to be in state 'available' before returning.",
            "type": "string"
          },
          "wait_timeout": {
            "description": "how long before wait gives up, in seconds",
            "type": "string"
          }
        },
        "required": [
          "source_image_id",
          "source_region"
        ]
      }
    },
    {
      "ec2_ami_find": {
        "type": "object",
        "description": "Searches for AMIs to obtain the AMI ID and other information",
        "properties": {
          "ami_id": {
            "description": "An AMI ID to match.",
            "type": "string"
          },
          "ami_tags": {
            "description": "A hash/dictionary of tags to match for the AMI.",
            "type": "string"
          },
          "architecture": {
            "description": "An architecture type to match (e.g. x86_64).",
            "type": "string"
          },
          "hypervisor": {
            "description": "A hypervisor type type to match (e.g. xen).",
            "type": "string"
          },
          "is_public": {
            "description": "Whether or not the image(s) are public.",
            "type": "string"
          },
          "name": {
            "description": "An AMI name to match.",
            "type": "string"
          },
          "no_result_action": {
            "description": "What to do when no results are found. 'success' reports success and returns an empty array 'fail' causes the module to report failure",
            "type": "string"
          },
          "owner": {
            "description": "Search AMIs owned by the specified owner Can specify an AWS account ID, or one of the special IDs 'self', 'amazon' or 'aws- marketplace' If not specified, all EC2 AMIs in the specified region will be searched. You can include wildcards in many of the search options. An asterisk (*) matches zero or more characters, and a question mark (?) matches exactly one character. You can escape special characters using a backslash (\\) before the character. For example, a value of \\*amazon\\?\\ searches for the literal string *amazon?\\.",
            "type": "string"
          },
          "platform": {
            "description": "Platform type to match.",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use.",
            "type": "string"
          },
          "sort": {
            "description": "Optional attribute which with to sort the results. If specifying 'tag', the 'tag_name' parameter is required. Starting at version 2.1, additional sort choices of architecture, blo ck_device_mapping , creationDate, hypervisor, is_public, location, owner_id, platform, root_device_name, root_device_type, state, and virtua lization_type are supported.",
            "type": "string"
          },
          "sort_end": {
            "description": "Which result to end with (when sorting). Corresponds to Python slice notation.",
            "type": "string"
          },
          "sort_order": {
            "description": "Order in which to sort results. Only used when the 'sort' parameter is specified.",
            "type": "string"
          },
          "sort_start": {
            "description": "Which result to start with (when sorting). Corresponds to Python slice notation.",
            "type": "string"
          },
          "sort_tag": {
            "description": "Tag name with which to sort results. Required when specifying 'sort=tag'.",
            "type": "string"
          },
          "state": {
            "description": "AMI state to match.",
            "type": "string"
          },
          "virtualization_type": {
            "description": "Virtualization type to match (e.g. hvm).",
            "type": "string"
          }
        },
        "required": "region"
      }
    },
    {
      "ec2_asg": {
        "type": "object",
        "description": "Create or delete AWS Autoscaling Groups",
        "properties": {
          "availability_zones": {
            "description": "List of availability zone names in which to create the group. Defaults to all the availability zones in the region if vpc_zon e_identifier is not set.",
            "type": "string"
          },
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "default_cooldown": {
            "description": "The number of seconds after a scaling activity completes before another can begin.",
            "type": "string"
          },
          "desired_capacity": {
            "description": "Desired number of instances in group, if unspecified then the current group value will be used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "health_check_period": {
            "description": "Length of time in seconds after a new EC2 instance comes into service that Auto Scaling starts checking its health.",
            "type": "string"
          },
          "health_check_type": {
            "description": "The service you want the health status from, Amazon EC2 or Elastic Load Balancer.",
            "type": "string"
          },
          "launch_config_name": {
            "description": "Name of the Launch configuration to use for the group. See the ec2_lc module for managing these.",
            "type": "string"
          },
          "lc_check": {
            "description": "Check to make sure instances that are being replaced with replace_instances do not already have the current launch_config.",
            "type": "string"
          },
          "load_balancers": {
            "description": "List of ELB names to use for the group",
            "type": "string"
          },
          "max_size": {
            "description": "Maximum number of instances in group, if unspecified then the current group value will be used.",
            "type": "string"
          },
          "min_size": {
            "description": "Minimum number of instances in group, if unspecified then the current group value will be used.",
            "type": "string"
          },
          "name": {
            "description": "Unique name for group to be created or deleted",
            "type": "string"
          },
          "notification_topic": {
            "description": "A SNS topic ARN to send auto scaling notifications to.",
            "type": "string"
          },
          "notification_types": {
            "description": "A list of auto scaling events to trigger notifications on.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "replace_all_instances": {
            "description": "In a rolling fashion, replace all instances with an old launch configuration with one from the current launch configuration.",
            "type": "string"
          },
          "replace_batch_size": {
            "description": "Number of instances you'd like to replace at a time.  Used with  replace_all_insta nces.",
            "type": "string"
          },
          "replace_instances": {
            "description": "List of instance_ids belonging to the named ASG that you would like to terminate and be replaced with instances matching the current launch configuration.",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "register or deregister the instance",
            "type": "string"
          },
          "tags": {
            "description": "A list of tags to add to the Auto Scale Group. Optional key is ' propagate_at_laun ch', which defaults to true.",
            "type": "string"
          },
          "termination_policies": {
            "description": "An ordered list of criteria used for selecting instances to be removed from the Auto Scaling group when reducing capacity. For 'Default', when used to create a new autoscaling group, the \"Default\"i value is used. When used to change an existent autoscaling group, the current termination policies are maintained.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "vpc_zone_identifier": {
            "description": "List of VPC subnets to use",
            "type": "string"
          },
          "wait_for_instances": {
            "description": "Wait for the ASG instances to be in a ready state before exiting.  If instances are behind an ELB, it will wait until the ELB determines all instances have a lifecycle_state of  \"InService\" and  a health_status of \"Healthy\".",
            "type": "string"
          },
          "wait_timeout": {
            "description": "how long before wait instances to become viable when replaced. Used in conjunction with instance_ids option.",
            "type": "string"
          }
        },
        "required": [
          "launch_config_name",
          "name"
        ]
      }
    },
    {
      "ec2_asg_facts": {
        "type": "object",
        "description": "Gather facts about ec2 Auto Scaling Groups (ASGs) in AWS",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "name": {
            "description": "The prefix or name of the auto scaling group(s) you are searching for. Note: This is a regular expression match with implicit '^' (beginning of string). Append '$' for a complete name match.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "tags": {
            "description": "A dictionary/hash of tags in the format { tag1_name: 'tag1_value', tag2_name: 'tag2_value' } to match against the auto scaling group(s) you are searching for.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        }
      }
    },
    {
      "ec2_customer_gateway": {
        "type": "object",
        "description": "Manage an AWS customer gateway",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "bgp_asn": {
            "description": "Border Gateway Protocol (BGP) Autonomous System Number (ASN), required when state=present.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "ip_address": {
            "description": "Internet-routable IP address for customers gateway, must be a static address.",
            "type": "string"
          },
          "name": {
            "description": "Name of the customer gateway.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "Create or terminate the Customer Gateway.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        },
        "required": [
          "ip_address",
          "name"
        ]
      }
    },
    {
      "ec2_eip": {
        "type": "object",
        "description": "manages EC2 elastic IP (EIP) addresses.",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "device_id": {
            "description": "The id of the device for the EIP. Can be an EC2 Instance id or Elastic Network Interface (ENI) id.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "in_vpc": {
            "description": "allocate an EIP inside a VPC or not",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "public_ip": {
            "description": "The IP address of a previously allocated EIP. If present and device is specified, the EIP is associated with the device. If absent and device is specified, the EIP is disassociated from the device.",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "release_on_disassociation": {
            "description": "whether or not to automatically release the EIP when it is disassociated",
            "type": "string"
          },
          "reuse_existing_ip_allowed": {
            "description": "Reuse an EIP that is not associated to a device (when available), instead of allocating a new one.",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "If present, allocate an EIP or associate an existing EIP with a device. If absent, disassociate the EIP from the device and optionally release it.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        }
      }
    },
    {
      "ec2_elb": {
        "type": "object",
        "description": "De-registers or registers instances from EC2 ELBs",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_elbs": {
            "description": "List of ELB names, required for registration. The ec2_elbs fact should be used if there was a previous de- register.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "enable_availability_zone": {
            "description": "Whether to enable the availability zone of the instance on the target ELB if the availability zone has not already been enabled. If set to no, the task will fail if the availability zone is not enabled on the ELB.",
            "type": "string"
          },
          "instance_id": {
            "description": "EC2 Instance ID",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "register or deregister the instance",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "wait": {
            "description": "Wait for instance registration or deregistration to complete successfully before returning.",
            "type": "string"
          },
          "wait_timeout": {
            "description": "Number of seconds to wait for an instance to change state. If 0 then this module may return an error if a transient error occurs. If non- zero then any transient errors are ignored until the timeout is reached. Ignored when wait=no.",
            "type": "string"
          }
        },
        "required": [
          "instance_id",
          "state"
        ]
      }
    },
    {
      "ec2_elb_facts": {
        "type": "object",
        "description": "Gather facts about EC2 Elastic Load Balancers in AWS",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "names": {
            "description": "List of ELB names to gather facts about. Pass this option to gather facts about a set of ELBs, otherwise, all ELBs are returned.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        }
      }
    },
    {
      "ec2_elb_lb": {
        "type": "object",
        "description": "Creates or destroys Amazon ELB.",
        "properties": {
          "access_logs": {
            "description": "An associative array of access logs configuration settings (see example)",
            "type": "string"
          },
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "connection_draining_timeout": {
            "description": "Wait a specified timeout allowing connections to drain before terminating an instance",
            "type": "string"
          },
          "cross_az_load_balancing": {
            "description": "Distribute load across all configured Availability Zones",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "health_check": {
            "description": "An associative array of health check configuration settings (see example)",
            "type": "string"
          },
          "idle_timeout": {
            "description": "ELB connections from clients and to servers are timed out after this amount of time",
            "type": "string"
          },
          "instance_ids": {
            "description": "List of instance ids to attach to this ELB",
            "type": "string"
          },
          "listeners": {
            "description": "List of ports/protocols for this ELB to listen on (see example)",
            "type": "string"
          },
          "name": {
            "description": "The name of the ELB",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "purge_instance_ids": {
            "description": "Purge existing instance ids on ELB that are not found in instance_ids",
            "type": "string"
          },
          "purge_listeners": {
            "description": "Purge existing listeners on ELB that are not found in listeners",
            "type": "string"
          },
          "purge_subnets": {
            "description": "Purge existing subnet on ELB that are not found in subnets",
            "type": "string"
          },
          "purge_zones": {
            "description": "Purge existing availability zones on ELB that are not found in zones",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "scheme": {
            "description": "The scheme to use when creating the ELB. For a private VPC- visible ELB use 'internal'.",
            "type": "string"
          },
          "security_group_ids": {
            "description": "A list of security groups to apply to the elb",
            "type": "string"
          },
          "security_group_names": {
            "description": "A list of security group names to apply to the elb",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "Create or destroy the ELB",
            "type": "string"
          },
          "stickiness": {
            "description": "An associative array of stickiness policy settings. Policy will be applied to all listeners ( see example )",
            "type": "string"
          },
          "subnets": {
            "description": "A list of VPC subnets to use when creating ELB. Zones should be empty if using this.",
            "type": "string"
          },
          "tags": {
            "description": "An associative array of tags. To delete all tags, supply an empty dict.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "wait": {
            "description": "When specified, Ansible will check the status of the load balancer to ensure it has been successfully removed from AWS.",
            "type": "string"
          },
          "wait_timeout": {
            "description": "Used in conjunction with wait. Number of seconds to wait for the elb to be terminated. A maximum of 600 seconds (10 minutes) is allowed.",
            "type": "string"
          },
          "zones": {
            "description": "List of availability zones to enable on this ELB",
            "type": "string"
          }
        },
        "required": [
          "name",
          "state"
        ]
      }
    },
    {
      "ec2_eni": {
        "type": "object",
        "description": "Create and optionally attach an Elastic Network Interface (ENI) to an instance",
        "properties": {
          "attached": {
            "description": "Specifies if network interface should be attached or detached from instance. If ommited, attachment status won't change",
            "type": "string"
          },
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "delete_on_termination": {
            "description": "Delete the interface when the instance it is attached to is terminated. You can only specify this flag when the interface is being modified, not on creation.",
            "type": "string"
          },
          "description": {
            "description": "Optional description of the ENI.",
            "type": "string"
          },
          "device_index": {
            "description": "The index of the device for the network interface attachment on the instance.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "eni_id": {
            "description": "The ID of the ENI",
            "type": "string"
          },
          "force_detach": {
            "description": "Force detachment of the interface. This applies either when explicitly detaching the interface by setting instance_id to None or when deleting an interface with state=absent.",
            "type": "string"
          },
          "instance_id": {
            "description": "Instance ID that you wish to attach ENI to. Since version 2.2, use the 'attached' parameter to attach or detach an ENI. Prior to 2.2, to detach an ENI from an instance, use 'None'.",
            "type": "string"
          },
          "private_ip_address": {
            "description": "Private IP address.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "secondary_private_ip_address_count": {
            "description": "The number of secondary IP addresses to assign to the network interface. This option is mutually exclusive of seco ndary_private_ip_ addresses",
            "type": "string"
          },
          "secondary_private_ip_addresses": {
            "description": "A list of IP addresses to assign as secondary IP addresses to the network interface. This option is mutually exclusive of seco ndary_private_ip_ address_count",
            "type": "string"
          },
          "security_groups": {
            "description": "List of security groups associated with the interface. Only used when state=present. Since version 2.2, you can specify security groups by ID or by name or a combination of both. Prior to 2.2, you can specify only by ID.",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "source_dest_check": {
            "description": "By default, interfaces perform source/destinatio n checks. NAT instances however need this check to be disabled. You can only specify this flag when the interface is being modified, not on creation.",
            "type": "string"
          },
          "state": {
            "description": "Create or delete ENI",
            "type": "string"
          },
          "subnet_id": {
            "description": "ID of subnet in which to create the ENI. Only required when state=present.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        },
        "required": "subnet_id"
      }
    },
    {
      "ec2_eni_facts": {
        "type": "object",
        "description": "Gather facts about ec2 ENI interfaces in AWS",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "filters": {
            "description": "A dict of filters to apply. Each dict item consists of a filter key and a filter value. See http://docs.aws.a mazon.com/AWSEC2/ latest/APIReferen ce/API_DescribeNe tworkInterfaces.h tml for possible filters.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        }
      }
    },
    {
      "ec2_facts": {
        "type": "object",
        "description": "Gathers facts about remote hosts within ec2 (aws)",
        "properties": {
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        }
      }
    },
    {
      "ec2_group": {
        "type": "object",
        "description": "maintain an ec2 VPC security group.",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "description": {
            "description": "Description of the security group.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "name": {
            "description": "Name of the security group.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "purge_rules": {
            "description": "Purge existing rules on security group that are not found in rules",
            "type": "string"
          },
          "purge_rules_egress": {
            "description": "Purge existing rules_egress on security group that are not found in rules_egress",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "rules": {
            "description": "List of firewall inbound rules to enforce in this group (see example). If none are supplied, a default all-out rule is assumed. If an empty list is supplied, no inbound rules will be enabled.",
            "type": "string"
          },
          "rules_egress": {
            "description": "List of firewall outbound rules to enforce in this group (see example). If none are supplied, a default all-out rule is assumed. If an empty list is supplied, no outbound rules will be enabled.",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "Create or delete a security group",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "vpc_id": {
            "description": "ID of the VPC to create the group in.",
            "type": "string"
          }
        },
        "required": [
          "description",
          "name"
        ]
      }
    },
    {
      "ec2_key": {
        "type": "object",
        "description": "maintain an ec2 key pair.",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "key_material": {
            "description": "Public key material.",
            "type": "string"
          },
          "name": {
            "description": "Name of the key pair.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "create or delete keypair",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "wait": {
            "description": "Wait for the specified action to complete before returning.",
            "type": "string"
          },
          "wait_timeout": {
            "description": "How long before wait gives up, in seconds",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "ec2_lc": {
        "type": "object",
        "description": "Create or delete AWS Autoscaling Launch Configurations",
        "properties": {
          "assign_public_ip": {
            "description": "Used for Auto Scaling groups that launch instances into an Amazon Virtual Private Cloud. Specifies whether to assign a public IP address to each instance launched in a Amazon VPC.",
            "type": "string"
          },
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "classic_link_vpc_id": {
            "description": "Id of ClassicLink enabled VPC",
            "type": "string"
          },
          "classic_link_vpc_security_groups": {
            "description": "A list of security group id's with which to associate the ClassicLink VPC instances.",
            "type": "string"
          },
          "ebs_optimized": {
            "description": "Specifies whether the instance is optimized for EBS I/O (true) or not (false).",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "image_id": {
            "description": "The AMI unique identifier to be used for the group",
            "type": "string"
          },
          "instance_monitoring": {
            "description": "whether instances in group are launched with detailed monitoring.",
            "type": "string"
          },
          "instance_profile_name": {
            "description": "The name or the Amazon Resource Name (ARN) of the instance profile associated with the IAM role for the instances.",
            "type": "string"
          },
          "instance_type": {
            "description": "instance type to use for the instance",
            "type": "string"
          },
          "kernel_id": {
            "description": "Kernel id for the EC2 instance",
            "type": "string"
          },
          "key_name": {
            "description": "The SSH key name to be used for access to managed instances",
            "type": "string"
          },
          "name": {
            "description": "Unique name for configuration",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "ramdisk_id": {
            "description": "A RAM disk id for the instances.",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_groups": {
            "description": "A list of security groups to apply to the instances. For VPC instances, specify security group IDs. For EC2-Classic, specify either security group names or IDs.",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "spot_price": {
            "description": "The spot price you are bidding. Only applies for an autoscaling group with spot instances.",
            "type": "string"
          },
          "state": {
            "description": "register or deregister the instance",
            "type": "string"
          },
          "user_data": {
            "description": "opaque blob of data which is made available to the ec2 instance",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "volumes": {
            "description": "a list of volume dicts, each containing device name and optionally ephemeral id or snapshot id. Size and type (and number of iops for io device type) must be specified for a new volume or a root volume, and may be passed for a snapshot volume. For any volume, a volume size less than 1 will be interpreted as a request not to create the volume.",
            "type": "string"
          }
        },
        "required": [
          "instance_type",
          "name",
          "state"
        ]
      }
    },
    {
      "ec2_lc_find": {
        "type": "object",
        "description": "Find AWS Autoscaling Launch Configurations",
        "properties": {
          "limit": {
            "description": "How many results to show. Corresponds to Python slice notation like list[:limit].",
            "type": "string"
          },
          "name_regex": {
            "description": "A Launch Configuration to match It'll be compiled as regex",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use.",
            "type": "string"
          },
          "sort_order": {
            "description": "Order in which to sort results.",
            "type": "string"
          }
        },
        "required": [
          "name_regex",
          "region"
        ]
      }
    },
    {
      "ec2_metric_alarm": {
        "type": "object",
        "description": "Create/update or delete AWS Cloudwatch 'metric alarms'",
        "properties": {
          "alarm_actions": {
            "description": "A list of the names action(s) taken when the alarm is in the 'alarm' status",
            "type": "string"
          },
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "comparison": {
            "description": "Determines how the threshold value is compared",
            "type": "string"
          },
          "description": {
            "description": "A longer description of the alarm",
            "type": "string"
          },
          "dimensions": {
            "description": "Describes to what the alarm is applied",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "evaluation_periods": {
            "description": "The number of times in which the metric is evaluated before final calculation",
            "type": "string"
          },
          "insufficient_data_actions": {
            "description": "A list of the names of action(s) to take when the alarm is in the 'insufficient _data' status",
            "type": "string"
          },
          "metric": {
            "description": "Name of the monitored metric (e.g. CPUUtilization) Metric must already exist",
            "type": "string"
          },
          "name": {
            "description": "Unique name for the alarm",
            "type": "string"
          },
          "namespace": {
            "description": "Name of the appropriate namespace ('AWS/EC2', 'System/Linux', etc.), which determines the category it will appear under in cloudwatch",
            "type": "string"
          },
          "ok_actions": {
            "description": "A list of the names of action(s) to take when the alarm is in the 'ok' status",
            "type": "string"
          },
          "period": {
            "description": "The time (in seconds) between metric evaluations",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "register or deregister the alarm",
            "type": "string"
          },
          "statistic": {
            "description": "Operation applied to the metric Works in conjunction with period and evalua tion_periods to determine the comparison value",
            "type": "string"
          },
          "threshold": {
            "description": "Sets the min/max bound for triggering the alarm",
            "type": "string"
          },
          "unit": {
            "description": "The threshold's unit of measurement",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "state"
        ]
      }
    },
    {
      "ec2_remote_facts": {
        "type": "object",
        "description": "Gather facts about ec2 instances in AWS",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "filters": {
            "description": "A dict of filters to apply. Each dict item consists of a filter key and a filter value. See http://docs.aws.a mazon.com/AWSEC2/ latest/APIReferen ce/API_DescribeIn stances.html for possible filters.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        }
      }
    },
    {
      "ec2_scaling_policy": {
        "type": "object",
        "description": "Create or delete AWS scaling policies for Autoscaling groups",
        "properties": {
          "adjustment_type": {
            "description": "The type of change in capacity of the autoscaling group",
            "type": "string"
          },
          "asg_name": {
            "description": "Name of the associated autoscaling group",
            "type": "string"
          },
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "cooldown": {
            "description": "The minimum period of time between which autoscaling actions can take place",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "min_adjustment_step": {
            "description": "Minimum amount of adjustment when policy is triggered",
            "type": "string"
          },
          "name": {
            "description": "Unique name for the scaling policy",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "scaling_adjustment": {
            "description": "The amount by which the autoscaling group is adjusted by the policy",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "register or deregister the policy",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        },
        "required": [
          "asg_name",
          "name",
          "state"
        ]
      }
    },
    {
      "ec2_snapshot": {
        "type": "object",
        "description": "creates a snapshot from an existing volume",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "description": {
            "description": "description to be applied to the snapshot",
            "type": "string"
          },
          "device_name": {
            "description": "device name of a mounted volume to be snapshotted",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "instance_id": {
            "description": "instance that has the required volume to snapshot mounted",
            "type": "string"
          },
          "last_snapshot_min_age": {
            "description": "If the volume's most recent snapshot has started less than `last_s napshot_min_age' minutes ago, a new snapshot will not be created.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "snapshot_id": {
            "description": "snapshot id to remove",
            "type": "string"
          },
          "snapshot_tags": {
            "description": "a hash/dictionary of tags to add to the snapshot",
            "type": "string"
          },
          "state": {
            "description": "whether to add or create a snapshot",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "volume_id": {
            "description": "volume from which to take the snapshot",
            "type": "string"
          },
          "wait": {
            "description": "wait for the snapshot to be ready",
            "type": "string"
          },
          "wait_timeout": {
            "description": "how long before wait gives up, in seconds specify 0 to wait forever",
            "type": "string"
          }
        }
      }
    },
    {
      "ec2_snapshot_facts": {
        "type": "object",
        "description": "Gather facts about ec2 volume snapshots in AWS",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "filters": {
            "description": "A dict of filters to apply. Each dict item consists of a filter key and a filter value. See http://docs.aws.a mazon.com/AWSEC2/ latest/APIReferen ce/API_DescribeSn apshots.html for possible filters. Filter names and values are case sensitive.",
            "type": "string"
          },
          "owner_ids": {
            "description": "If you specify one or more snapshot owners, only snapshots from the specified owners and for which you have access are returned.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "restorable_by_user_ids": {
            "description": "If you specify a list of restorable users, only snapshots with create snapshot permissions for those users are returned.",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "snapshot_ids": {
            "description": "If you specify one or more snapshot IDs, only snapshots that have the specified IDs are returned.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        }
      }
    },
    {
      "ec2_tag": {
        "type": "object",
        "description": "create and remove tag(s) to ec2 resources.",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "resource": {
            "description": "The EC2 resource id.",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "Whether the tags should be present or absent on the resource. Use list to interrogate the tags of an instance.",
            "type": "string"
          },
          "tags": {
            "description": "a hash/dictionary of tags to add to the resource; '{\"key\":\"value\"}' and '{\"key\":\"valu e\",\"key\":\"value\"} '",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        },
        "required": [
          "resource",
          "tags"
        ]
      }
    },
    {
      "ec2_vol": {
        "type": "object",
        "description": "create and attach a volume, return volume id and device map",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "delete_on_termination": {
            "description": "When set to \"yes\", the volume will be deleted upon instance termination.",
            "type": "string"
          },
          "device_name": {
            "description": "device id to override device mapping. Assumes /dev/sdf for Linux/UNIX and /dev/xvdf for Windows.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "encrypted": {
            "description": "Enable encryption at rest for this volume.",
            "type": "string"
          },
          "id": {
            "description": "volume id if you wish to attach an existing volume (requires instance) or remove an existing volume",
            "type": "string"
          },
          "instance": {
            "description": "instance ID if you wish to attach the volume. Since 1.9 you can set to None to detach.",
            "type": "string"
          },
          "iops": {
            "description": "the provisioned IOPs you want to associate with this volume (integer).",
            "type": "string"
          },
          "name": {
            "description": "volume Name tag if you wish to attach an existing volume (requires instance)",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "snapshot": {
            "description": "snapshot ID on which to base the volume",
            "type": "string"
          },
          "state": {
            "description": "whether to ensure the volume is present or absent, or to list existing volumes (The `list' option was added in version 1.8).",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "volume_size": {
            "description": "size of volume (in GB) to create.",
            "type": "string"
          },
          "volume_type": {
            "description": "Type of EBS volume; standard (magnetic), gp2 (SSD), io1 (Provisioned IOPS). \"Standard\" is the old EBS default and continues to remain the Ansible default for backwards compatibility.",
            "type": "string"
          },
          "zone": {
            "description": "zone in which to create the volume, if unset uses the zone the instance is in (if set)",
            "type": "string"
          }
        }
      }
    },
    {
      "ec2_vol_facts": {
        "type": "object",
        "description": "Gather facts about ec2 volumes in AWS",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "filters": {
            "description": "A dict of filters to apply. Each dict item consists of a filter key and a filter value. See http://docs.aws.a mazon.com/AWSEC2/ latest/APIReferen ce/API_DescribeVo lumes.html for possible filters.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        }
      }
    },
    {
      "ec2_vpc": {
        "type": "object",
        "description": "configure AWS virtual private clouds",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "cidr_block": {
            "description": "The cidr block representing the VPC, e.g. 10.0.0.0/16, required when `state' is 'present'.",
            "type": "string"
          },
          "dns_hostnames": {
            "description": "toggles the \"Enable DNS hostname support for instances\" flag",
            "type": "string"
          },
          "dns_support": {
            "description": "toggles the \"Enable DNS resolution\" flag",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "instance_tenancy": {
            "description": "The supported tenancy options for instances launched into the VPC.",
            "type": "string"
          },
          "internet_gateway": {
            "description": "Toggle whether there should be an Internet gateway attached to the VPC",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "resource_tags": {
            "description": "A dictionary array of resource tags of the form: { tag1: value1, tag2: value2 }. Tags in this list are used in conjunction with CIDR block to uniquely identify a VPC in lieu of vpc_id. Therefore, if CIDR/Tag combination does not exist, a new VPC will be created.  VPC tags not on this list will be ignored. Prior to 1.7, specifying a resource tag was optional.",
            "type": "string"
          },
          "route_tables": {
            "description": "A dictionary array of route tables to add of the form: { subnets: [172.22.2.0/24, 172.22.3.0/24,], routes: [{ dest: 0.0.0.0/0, gw: igw},], resource_tags: ... }. Where the subnets list is those subnets the route table should be associated with, and the routes list is a list of routes to be in the table.  The special keyword for the gw of igw specifies that you should the route should go through the internet gateway attached to the VPC. gw also accepts instance- ids, interface- ids, and vpc- peering- connection-ids in addition igw. resource_tags is optional and uses dictionary form: { \"Name\": \"public\", ... }. This module is currently unable to affect the \"main\" route table due to some limitations in boto, so you must explicitly define the associated subnets or they will be attached to the main table implicitly. As of 1.8, if the route_tables parameter is not specified, no existing routes will be modified.",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "Create or terminate the VPC",
            "type": "string"
          },
          "subnets": {
            "description": "A dictionary array of subnets to add of the form: { cidr: ..., az: ... , resource_tags: ... }. Where az is the desired availability zone of the subnet, but it is not required. Tags (i.e.: resource_tags) is also optional and use dictionary form: { \"Environm ent\":\"Dev\", \"Tier\":\"Web\", ...}. All VPC subnets not in this list will be removed as well. As of 1.8, if the subnets parameter is not specified, no existing subnets will be modified.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "vpc_id": {
            "description": "A VPC id to terminate when state=absent",
            "type": "string"
          },
          "wait": {
            "description": "wait for the VPC to be in state 'available' before returning",
            "type": "string"
          },
          "wait_timeout": {
            "description": "how long before wait gives up, in seconds",
            "type": "string"
          }
        },
        "required": [
          "resource_tags",
          "state"
        ]
      }
    },
    {
      "ec2_vpc_dhcp_options": {
        "type": "object",
        "description": "Manages DHCP Options, and can ensure the DHCP options for the given VPC match what's requested",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "delete_old": {
            "description": "Whether to delete the old VPC DHCP option set when associating a new one. This is primarily useful for debugg ing/development purposes when you want to quickly roll back to the old option set. Note that this setting will be ignored, and the old DHCP option set will be preserved, if it is in use by any other VPC. (Otherwise, AWS will return an error.)",
            "type": "string"
          },
          "dhcp_options_id": {
            "description": "The resource_id of an existing DHCP options set. If this is specified, then it will override other settings, except tags (which will be updated to match)",
            "type": "string"
          },
          "dns_servers": {
            "description": "A list of hosts to set the DNS servers for the VPC to. (Should be a list of IP addresses rather than host names.)",
            "type": "string"
          },
          "domain_name": {
            "description": "The domain name to set in the DHCP option sets",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "inherit_existing": {
            "description": "For any DHCP options not specified in these parameters, whether to inherit them from the options set already applied to vpc_id, or to reset them to be empty.",
            "type": "string"
          },
          "netbios_name_servers": {
            "description": "List of hosts to advertise as NetBIOS servers.",
            "type": "string"
          },
          "netbios_node_type": {
            "description": "NetBIOS node type to advertise in the DHCP options. The AWS recommendation is to use 2 (when using netbios name services) ht tp://docs.aws.ama zon.com/AmazonVPC /latest/UserGuide /VPC_DHCP_Options .html",
            "type": "string"
          },
          "ntp_servers": {
            "description": "List of hosts to advertise as NTP servers for the VPC.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "create/assign or remove the DHCP options. If state is set to absent, then a DHCP options set matched either by id, or tags and options will be removed if possible.",
            "type": "string"
          },
          "tags": {
            "description": "Tags to be applied to a VPC options set if a new one is created, or if the resource_id is provided. (options must match)",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "vpc_id": {
            "description": "VPC ID to associate with the requested DHCP option set. If no vpc id is provided, and no matching option set is found then a new DHCP option set is created.",
            "type": "string"
          }
        }
      }
    },
    {
      "ec2_vpc_dhcp_options_facts": {
        "type": "object",
        "description": "Gather facts about dhcp options sets in AWS",
        "properties": {
          "DhcpOptionsIds": {
            "description": "Get details of specific DHCP Option ID Provide this value as a list",
            "type": "string"
          },
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "filters": {
            "description": "A dict of filters to apply. Each dict item consists of a filter key and a filter value. See http://docs.aws.a mazon.com/AWSEC2/ latest/APIReferen ce/API_DescribeRo uteTables.html for possible filters.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        }
      }
    },
    {
      "ec2_vpc_igw": {
        "type": "object",
        "description": "Manage an AWS VPC Internet gateway",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "Create or terminate the IGW",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "vpc_id": {
            "description": "The VPC ID for the VPC in which to manage the Internet Gateway.",
            "type": "string"
          }
        },
        "required": "vpc_id"
      }
    },
    {
      "ec2_vpc_nacl": {
        "type": "object",
        "description": "create and delete Network ACLs.",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "egress": {
            "description": "A list of rules for outgoing traffic. Each rule must be specified as a list.",
            "type": "string"
          },
          "ingress": {
            "description": "List of rules for incoming traffic. Each rule must be specified as a list.",
            "type": "string"
          },
          "name": {
            "description": "Tagged name identifying a network ACL.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "Creates or modifies an existing NACL Deletes a NACL and reassociates subnets to the default NACL",
            "type": "string"
          },
          "subnets": {
            "description": "The list of subnets that should be associated with the network ACL. Must be specified as a list Each subnet can be specified as subnet ID, or its tagged name.",
            "type": "string"
          },
          "tags": {
            "description": "Dictionary of tags to look for and apply when creating a network ACL.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "vpc_id": {
            "description": "VPC id of the requesting VPC.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "vpc_id"
        ]
      }
    },
    {
      "ec2_vpc_nacl_facts": {
        "type": "object",
        "description": "Gather facts about Network ACLs in an AWS VPC",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "filters": {
            "description": "A dict of filters to apply. Each dict item consists of a filter key and a filter value. See http://docs.aws.a mazon.com/AWSEC2/ latest/APIReferen ce/API_DescribeNe tworkAcls.html for possible filters. Filter names and values are case sensitive.",
            "type": "string"
          },
          "nacl_ids": {
            "description": "A list of Network ACL IDs to retrieve facts about.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        }
      }
    },
    {
      "ec2_vpc_nat_gateway": {
        "type": "object",
        "description": "Manage AWS VPC NAT Gateways.",
        "properties": {
          "allocation_id": {
            "description": "The id of the elastic IP allocation. If this is not passed and the eip_address is not passed. An EIP is generated for this NAT Gateway.",
            "type": "string"
          },
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "client_token": {
            "description": "Optional unique token to be used during create to ensure idempotency. When specifying this option, ensure you specify the eip_address parameter as well otherwise any subsequent runs will fail.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "eip_address": {
            "description": "The elastic IP address of the EIP you want attached to this NAT Gateway. If this is not passed and the allocation_id is not passed, an EIP is generated for this NAT Gateway.",
            "type": "string"
          },
          "if_exist_do_not_create": {
            "description": "if a NAT Gateway exists already in the subnet_id, then do not create a new one.",
            "type": "string"
          },
          "nat_gateway_id": {
            "description": "The id AWS dynamically allocates to the NAT Gateway on creation. This is required when the absent option is present.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "release_eip": {
            "description": "Deallocate the EIP from the VPC. Option is only valid with the absent state. You should use this with the wait option. Since you can not release an address while a delete operation is happening.",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "Ensure NAT Gateway is present or absent.",
            "type": "string"
          },
          "subnet_id": {
            "description": "The id of the subnet to create the NAT Gateway in. This is required with the present option.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "wait": {
            "description": "Wait for operation to complete before returning.",
            "type": "string"
          },
          "wait_timeout": {
            "description": "How many seconds to wait for an operation to complete before timing out.",
            "type": "string"
          }
        }
      }
    },
    {
      "ec2_vpc_net": {
        "type": "object",
        "description": "Configure AWS virtual private clouds",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "cidr_block": {
            "description": "The CIDR of the VPC",
            "type": "string"
          },
          "dhcp_opts_id": {
            "description": "the id of the DHCP options to use for this vpc",
            "type": "string"
          },
          "dns_hostnames": {
            "description": "Whether to enable AWS hostname support.",
            "type": "string"
          },
          "dns_support": {
            "description": "Whether to enable AWS DNS support.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "multi_ok": {
            "description": "By default the module will not create another VPC if there is another VPC with the same name and CIDR block. Specify this as true if you want duplicate VPCs created.",
            "type": "string"
          },
          "name": {
            "description": "The name to give your VPC. This is used in combination with the cidr_block parameter to determine if a VPC already exists.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "The state of the VPC. Either absent or present.",
            "type": "string"
          },
          "tags": {
            "description": "The tags you want attached to the VPC. This is independent of the name value, note if you pass a 'Name' key it would override the Name of the VPC if it's different.",
            "type": "string"
          },
          "tenancy": {
            "description": "Whether to be default or dedicated tenancy. This cannot be changed after the VPC has been created.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        },
        "required": [
          "cidr_block",
          "name"
        ]
      }
    },
    {
      "ec2_vpc_net_facts": {
        "type": "object",
        "description": "Gather facts about ec2 VPCs in AWS",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "filters": {
            "description": "A dict of filters to apply. Each dict item consists of a filter key and a filter value. See http://docs.aws.a mazon.com/AWSEC2/ latest/APIReferen ce/API_DescribeVp cs.html for possible filters.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        }
      }
    },
    {
      "ec2_vpc_peer": {
        "type": "object",
        "description": "create, delete, accept, and reject VPC peering connections between two VPCs.",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "peer_owner_id": {
            "description": "The AWS account number for cross account peering.",
            "type": "string"
          },
          "peer_vpc_id": {
            "description": "VPC id of the accepting VPC.",
            "type": "string"
          },
          "peering_id": {
            "description": "Peering connection id.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "Create, delete, accept, reject a peering connection.",
            "type": "string"
          },
          "tags": {
            "description": "Dictionary of tags to look for and apply when creating a Peering Connection.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "vpc_id": {
            "description": "VPC id of the requesting VPC.",
            "type": "string"
          }
        }
      }
    },
    {
      "ec2_vpc_route_table": {
        "type": "object",
        "description": "Manage route tables for AWS virtual private clouds",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "lookup": {
            "description": "Look up route table by either tags or by route table ID. Non- unique tag lookup will fail. If no tags are specifed then no lookup for an existing route table is performed and a new route table will be created. To change tags of a route table, you must look up by id.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "propagating_vgw_ids": {
            "description": "Enable route propagation from virtual gateways specified by ID.",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "route_table_id": {
            "description": "The ID of the route table to update or delete.",
            "type": "string"
          },
          "routes": {
            "description": "List of routes in the route table. Routes are specified as dicts containing the keys 'dest' and one of 'gateway_id', 'instance_id', 'interface_id', or 'vpc_peering_c onnection_id'. If 'gateway_id' is specified, you can refer to the VPC's IGW by using the value 'igw'. Routes are required for present states.",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "Create or destroy the VPC route table",
            "type": "string"
          },
          "subnets": {
            "description": "An array of subnets to add to this route table. Subnets may be specified by either subnet ID, Name tag, or by a CIDR such as '10.0.0.0/24'.",
            "type": "string"
          },
          "tags": {
            "description": "A dictionary of resource tags of the form: { tag1: value1, tag2: value2 }. Tags are used to uniquely identify route tables within a VPC when the route_table_id is not supplied.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "vpc_id": {
            "description": "VPC ID of the VPC in which to create the route table.",
            "type": "string"
          }
        },
        "required": [
          "subnets",
          "vpc_id"
        ]
      }
    },
    {
      "ec2_vpc_route_table_facts": {
        "type": "object",
        "description": "Gather facts about ec2 VPC route tables in AWS",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "filters": {
            "description": "A dict of filters to apply. Each dict item consists of a filter key and a filter value. See http://docs.aws.a mazon.com/AWSEC2/ latest/APIReferen ce/API_DescribeRo uteTables.html for possible filters.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        }
      }
    },
    {
      "ec2_vpc_subnet": {
        "type": "object",
        "description": "Manage subnets in AWS virtual private clouds",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "az": {
            "description": "The availability zone for the subnet. Only required when state=present.",
            "type": "string"
          },
          "cidr": {
            "description": "The CIDR block for the subnet. E.g. 192.0.2.0/24. Only required when state=present.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "Create or remove the subnet",
            "type": "string"
          },
          "tags": {
            "description": "A dict of tags to apply to the subnet. Any tags currently applied to the subnet and not present here will be removed.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "vpc_id": {
            "description": "VPC ID of the VPC in which to create the subnet.",
            "type": "string"
          }
        }
      }
    },
    {
      "ec2_vpc_subnet_facts": {
        "type": "object",
        "description": "Gather facts about ec2 VPC subnets in AWS",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "filters": {
            "description": "A dict of filters to apply. Each dict item consists of a filter key and a filter value. See http://docs.aws.a mazon.com/AWSEC2/ latest/APIReferen ce/API_DescribeSu bnets.html for possible filters.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        }
      }
    },
    {
      "ec2_vpc_vgw": {
        "type": "object",
        "description": "Create and delete AWS VPN Virtual Gateways.",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "name": {
            "description": "name of the vgw to be created or deleted",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "present to ensure resource is created. absent to remove resource",
            "type": "string"
          },
          "tags": {
            "description": "dictionary of resource tags",
            "type": "string"
          },
          "type": {
            "description": "type of the virtual gateway to be created",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "vpc_id": {
            "description": "the vpc-id of a vpc to attach or detach",
            "type": "string"
          },
          "vpn_gateway_id": {
            "description": "vpn gateway id of an existing virtual gateway",
            "type": "string"
          },
          "wait_timeout": {
            "description": "number of seconds to wait for status during vpc attach and detach",
            "type": "string"
          }
        }
      }
    },
    {
      "ec2_win_password": {
        "type": "object",
        "description": "gets the default administrator password for ec2 windows instances",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "instance_id": {
            "description": "The instance id to get the password data from.",
            "type": "string"
          },
          "key_file": {
            "description": "Path to the file containing the key pair used on the instance.",
            "type": "string"
          },
          "key_passphrase": {
            "description": "The passphrase for the instance key pair. The key must use DES or 3DES encryption for this module to decrypt it. You can use openssl to convert your password protected keys if they do not use DES or 3DES. ex) openssl rsa -in current_key -out new_key -des3.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "wait": {
            "description": "Whether or not to wait for the password to be available before returning.",
            "type": "string"
          },
          "wait_timeout": {
            "description": "Number of seconds to wait before giving up.",
            "type": "string"
          }
        },
        "required": [
          "instance_id",
          "key_file"
        ]
      }
    },
    {
      "ecs_cluster": {
        "type": "object",
        "description": "create or terminate ecs clusters",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "delay": {
            "description": "Number of seconds to wait",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "name": {
            "description": "The cluster name",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "repeat": {
            "description": "The number of times to wait for the cluster to have an instance",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "The desired state of the cluster",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "state"
        ]
      }
    },
    {
      "ecs_service": {
        "type": "object",
        "description": "create, terminate, start or stop a service in ecs",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "client_token": {
            "description": "Unique, case-sensitive identifier you provide to ensure the idempotency of the request. Up to 32 ASCII characters are allowed.",
            "type": "string"
          },
          "cluster": {
            "description": "The name of the cluster in which the service exists",
            "type": "string"
          },
          "delay": {
            "description": "The time to wait before checking that the service is available",
            "type": "string"
          },
          "desired_count": {
            "description": "The count of how many instances of the service",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "load_balancers": {
            "description": "The list of ELBs defined for this service",
            "type": "string"
          },
          "name": {
            "description": "The name of the service",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "repeat": {
            "description": "The number of times to check that the service is available",
            "type": "string"
          },
          "role": {
            "description": "The name or full Amazon Resource Name (ARN) of the IAM role that allows your Amazon ECS container agent to make calls to your load balancer on your behalf. This parameter is only required if you are using a load balancer with your service.",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "The desired state of the service",
            "type": "string"
          },
          "task_definition": {
            "description": "The task definition the service will run",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "state"
        ]
      }
    },
    {
      "ecs_service_facts": {
        "type": "object",
        "description": "list or describe services in ecs",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "cluster": {
            "description": "The cluster ARNS in which to list the services.",
            "type": "string"
          },
          "details": {
            "description": "Set this to true if you want detailed information about the services.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "service": {
            "description": "The service to get details for (required if details is true)",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        }
      }
    },
    {
      "ecs_task": {
        "type": "object",
        "description": "run, start or stop a task in ecs",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "cluster": {
            "description": "The name of the cluster to run the task on",
            "type": "string"
          },
          "container_instances": {
            "description": "The list of container instances on which to deploy the task",
            "type": "string"
          },
          "count": {
            "description": "How many new instances to start",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "operation": {
            "description": "Which task operation to execute",
            "type": "string"
          },
          "overrides": {
            "description": "A dictionary of values to pass to the new instances",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "started_by": {
            "description": "A value showing who or what started the task (for informational purposes)",
            "type": "string"
          },
          "task": {
            "description": "The task to stop",
            "type": "string"
          },
          "task_definition": {
            "description": "The task definition to start or run",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        },
        "required": "operation"
      }
    },
    {
      "ecs_taskdefinition": {
        "type": "object",
        "description": "register a task definition in ecs",
        "properties": {
          "arn": {
            "description": "The arn of the task description to delete",
            "type": "string"
          },
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "containers": {
            "description": "A list of containers definitions",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "family": {
            "description": "A Name that would be given to the task definition",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "revision": {
            "description": "A revision number for the task definition",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "State whether the task definition should exist or be deleted",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "volumes": {
            "description": "A list of names of volumes to be attached",
            "type": "string"
          }
        },
        "required": "state"
      }
    },
    {
      "efs": {
        "type": "object",
        "description": "create and maintain EFS file systems",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "id": {
            "description": "ID of Amazon EFS. Either name or ID required for delete.",
            "type": "string"
          },
          "name": {
            "description": "Creation Token of Amazon EFS file system. Required for create. Either name or ID required for delete.",
            "type": "string"
          },
          "performance_mode": {
            "description": "File system's performance mode to use. Only takes effect during creation.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "Allows to create, search and destroy Amazon EFS file system",
            "type": "string"
          },
          "tags": {
            "description": "List of tags of Amazon EFS. Should be defined as dictionary In case of 'present' state with list of tags and existing EFS (matched by 'name'), tags of EFS will be replaced with provided data.",
            "type": "string"
          },
          "targets": {
            "description": "List of mounted targets. It should be a list of dictionaries, every dictionary should include next attributes: - subnet_id - Mandatory. The ID of the subnet to add the mount target in.     - ip_address - Optional. A valid IPv4 address within the address range of the specified subnet.     - security_groups - Optional. List of security group IDs, of the form \"sg-xxxxxxxx\". These must be for the same VPC as subnet specified This data may be modified for existing EFS using state 'present' and new list of mount targets.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "wait": {
            "description": "In case of 'present' state should wait for EFS 'available' life cycle state (of course, if current state not 'deleting' or 'deleted') In case of 'absent' state should wait for EFS 'deleted' life cycle state",
            "type": "string"
          },
          "wait_timeout": {
            "description": "How long the module should wait (in seconds) for desired state before returning. Zero means wait as long as necessary.",
            "type": "string"
          }
        }
      }
    },
    {
      "efs_facts": {
        "type": "object",
        "description": "Get information about Amazon EFS file systems",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "id": {
            "description": "ID of Amazon EFS.",
            "type": "string"
          },
          "name": {
            "description": "Creation Token of Amazon EFS file system.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "tags": {
            "description": "List of tags of Amazon EFS. Should be defined as dictionary",
            "type": "string"
          },
          "targets": {
            "description": "List of mounted targets. It should be a list of dictionaries, every dictionary should include next attributes: - SubnetId - Mandatory. The ID of the subnet to add the mount target in.     - IpAddress - Optional. A valid IPv4 address within the address range of the specified subnet.     - SecurityGroups - Optional. List of security group IDs, of the form \"sg-xxxxxxxx\". These must be for the same VPC as subnet specified.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        }
      }
    },
    {
      "ejabberd_user": {
        "type": "object",
        "description": "Manages users for ejabberd servers",
        "properties": {
          "host": {
            "description": "the ejabberd host associated with this username",
            "type": "string"
          },
          "logging": {
            "description": "enables or disables the local syslog facility for this module",
            "type": "string"
          },
          "password": {
            "description": "the password to assign to the username",
            "type": "string"
          },
          "state": {
            "description": "describe the desired state of the user to be managed",
            "type": "string"
          },
          "username": {
            "description": "the name of the user to manage",
            "type": "string"
          }
        },
        "required": [
          "host",
          "username"
        ]
      }
    },
    {
      "elasticache": {
        "type": "object",
        "description": "Manage cache clusters in Amazon Elasticache.",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "cache_engine_version": {
            "description": "The version number of the cache engine",
            "type": "string"
          },
          "cache_parameter_group": {
            "description": "The name of the cache parameter group to associate with this cache cluster. If this argument is omitted, the default cache parameter group for the specified engine will be used.",
            "type": "string"
          },
          "cache_port": {
            "description": "The port number on which each of the cache nodes will accept connections",
            "type": "string"
          },
          "cache_security_groups": {
            "description": "A list of cache security group names to associate with this cache cluster. Must be an empty list if inside a vpc",
            "type": "string"
          },
          "cache_subnet_group": {
            "description": "The subnet group name to associate with. Only use if inside a vpc. Required if inside a vpc",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "engine": {
            "description": "Name of the cache engine to be used.",
            "type": "string"
          },
          "hard_modify": {
            "description": "Whether to destroy and recreate an existing cache cluster if necessary in order to modify its state",
            "type": "string"
          },
          "name": {
            "description": "The cache cluster identifier",
            "type": "string"
          },
          "node_type": {
            "description": "The compute and memory capacity of the nodes in the cache cluster",
            "type": "string"
          },
          "num_nodes": {
            "description": "The initial number of cache nodes that the cache cluster will have. Required when state=present.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_group_ids": {
            "description": "A list of vpc security group names to associate with this cache cluster. Only use if inside a vpc",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "`absent' or `present' are idempotent actions that will create or destroy a cache cluster as needed. `rebooted' will reboot the cluster, resulting in a momentary outage.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "wait": {
            "description": "Wait for cache cluster result before returning",
            "type": "string"
          },
          "zone": {
            "description": "The EC2 Availability Zone in which the cache cluster will be created",
            "type": "string"
          }
        },
        "required": [
          "name",
          "state"
        ]
      }
    },
    {
      "elasticache_subnet_group": {
        "type": "object",
        "description": "manage Elasticache subnet groups",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "description": {
            "description": "Elasticache subnet group description. Only set when a new group is added.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "name": {
            "description": "Database subnet group identifier.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "Specifies whether the subnet should be present or absent.",
            "type": "string"
          },
          "subnets": {
            "description": "List of subnet IDs that make up the Elasticache subnet group.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "state"
        ]
      }
    },
    {
      "elasticsearch_plugin": {
        "type": "object",
        "description": "Manage Elasticsearch plugins",
        "properties": {
          "name": {
            "description": "Name of the plugin to install. In ES 2.x, the name can be an url or file location",
            "type": "string"
          },
          "plugin_bin": {
            "description": "Location of the plugin binary",
            "type": "string"
          },
          "plugin_dir": {
            "description": "Your configured plugin directory specified in Elasticsearch",
            "type": "string"
          },
          "proxy_host": {
            "description": "Proxy host to use during plugin installation",
            "type": "string"
          },
          "proxy_port": {
            "description": "Proxy port to use during plugin installation",
            "type": "string"
          },
          "state": {
            "description": "Desired state of a plugin.",
            "type": "string"
          },
          "timeout": {
            "description": "Timeout setting: 30s, 1m, 1h...",
            "type": "string"
          },
          "url": {
            "description": "Set exact URL to download the plugin from (Only works for ES 1.x)",
            "type": "string"
          },
          "version": {
            "description": "Version of the plugin to be installed. If plugin exists with previous version, it will NOT be updated",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "eos_command": {
        "type": "object",
        "description": "Run arbitrary commands on an Arista EOS device",
        "properties": {
          "auth_pass": {
            "description": "Specifies the password to use if required to enter privileged mode on the remote device. If `authorize' is false, then this argument does nothing. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_AUTH_PASS' will be used instead.",
            "type": "string"
          },
          "authorize": {
            "description": "Instructs the module to enter privileged mode on the remote device before sending any commands.  If not specified, the device will attempt to execute all commands in non- privileged mode. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_AUTHORIZE' will be used instead.",
            "type": "string"
          },
          "commands": {
            "description": "The commands to send to the remote EOS device over the configured provider.  The resulting output from the command is returned.  If the `wait_for' argument is provided, the module is not returned until the condition is satisfied or the number of `retries' has been exceeded.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "interval": {
            "description": "Configures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditional, the interval indicates how to long to wait before trying the command again.",
            "type": "string"
          },
          "match": {
            "description": "The `match' argument is used in conjunction with the `wait_for' argument to specify the match policy.  Valid values are `all' or `any'.  If the value is set to `all' then all conditionals in the `wait_for' must be satisfied.  If the value is set to `any' then only one of the values must be satisfied.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `eapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `eapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `eos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "retries": {
            "description": "Specifies the number of retries a command should be tried before it is considered failed.  The command is run on the target device every retry and evaluated against the `wait_for' conditionals.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH keyfile to use to authenticate the connection to the remote device.  This argument is only used for `cli' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=eapi'. If the transport argument is not eapi, this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the eAPI authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          },
          "wait_for": {
            "description": "Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward. If the conditional is not true by the configured retries, the task fails.  See examples.",
            "type": "string"
          }
        },
        "required": [
          "commands",
          "host",
          "transport"
        ]
      }
    },
    {
      "eos_config": {
        "type": "object",
        "description": "Manage Arista EOS configuration sections",
        "properties": {
          "after": {
            "description": "The ordered set of commands to append to the end of the command stack if a change needs to be made. Just like with `before' this allows the playbook designer to append a set of commands to be executed after the command set.",
            "type": "string"
          },
          "auth_pass": {
            "description": "Specifies the password to use if required to enter privileged mode on the remote device. If `authorize' is false, then this argument does nothing. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_AUTH_PASS' will be used instead.",
            "type": "string"
          },
          "authorize": {
            "description": "Instructs the module to enter privileged mode on the remote device before sending any commands.  If not specified, the device will attempt to execute all commands in non- privileged mode. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_AUTHORIZE' will be used instead.",
            "type": "string"
          },
          "backup": {
            "description": "This argument will cause the module to create a full backup of the current `running-config' from the remote device before any changes are made. The backup file is written to the `backup' folder in the playbook root directory. If the directory does not exist, it is created.",
            "type": "string"
          },
          "before": {
            "description": "The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.",
            "type": "string"
          },
          "config": {
            "description": "The module, by default, will connect to the remote device and retrieve the current running- config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The `config' argument allows the implementer to pass in the configuration to use as the base config for comparison.",
            "type": "string"
          },
          "defaults": {
            "description": "The `defaults' argument will influence how the running-config is collected from the device.  When the value is set to true, the command used to collect the running-config is append with the all keyword. When the value is set to false, the command is issued without the all keyword",
            "type": "string"
          },
          "force": {
            "description": "The force argument instructs the module to not consider the current devices running-config. When set to true, this will cause the module to push the contents of `src' into the device without first checking if already configured. Note this argument should be considered deprecated.  To achieve the equivalent, set the `match=none' which is idempotent.  This argument will be removed in a future release.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "lines": {
            "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config. Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.",
            "type": "string"
          },
          "match": {
            "description": "Instructs the module on the way to perform the matching of the set of commands against the current device config.  If match is set to `line', commands are matched line by line.  If match is set to `strict', command lines are matched with respect to position.  If match is set to `exact', command lines must be an equal match. Finally, if match is set to `none', the module will not attempt to compare the source configuration with the running configuration on the remote device.",
            "type": "string"
          },
          "parents": {
            "description": "The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `eapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `eapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `eos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "replace": {
            "description": "Instructs the module on the way to perform the configuration on the device.  If the replace argument is set to `line' then the modified lines are pushed to the device in configuration mode.  If the replace argument is set to `block' then the entire command block is pushed to the device in configuration mode if any line is not correct.",
            "type": "string"
          },
          "save": {
            "description": "The `save' argument instructs the module to save the running- config to startup-config. This operation is performed after any changes are made to the current running config.  If no changes are made, the configuration is still saved to the startup config.  This option will always cause the module to return changed.",
            "type": "string"
          },
          "src": {
            "description": "The `src' argument provides a path to the configuration file to load into the remote system.  The path can either be a full system path to the configuration file if the value starts with / or relative to the root of the implemented role or playbook. This argument is mutually exclusive with the `lines' and `parents' arguments.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH keyfile to use to authenticate the connection to the remote device.  This argument is only used for `cli' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=eapi'. If the transport argument is not eapi, this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the eAPI authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "transport"
        ]
      }
    },
    {
      "eos_eapi": {
        "type": "object",
        "description": "Manage and configure Arista EOS eAPI.",
        "properties": {
          "auth_pass": {
            "description": "Specifies the password to use if required to enter privileged mode on the remote device. If `authorize' is false, then this argument does nothing. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_AUTH_PASS' will be used instead.",
            "type": "string"
          },
          "authorize": {
            "description": "Instructs the module to enter privileged mode on the remote device before sending any commands.  If not specified, the device will attempt to execute all commands in non- privileged mode. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_AUTHORIZE' will be used instead.",
            "type": "string"
          },
          "config": {
            "description": "The module, by default, will connect to the remote device and retrieve the current running- config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The `config' argument allows the implementer to pass in the configuration to use as the base config for comparison.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "http": {
            "description": "The `http' argument controls the operating state of the HTTP transport protocol when eAPI is present in the running- config. When the value is set to True, the HTTP protocol is enabled and when the value is set to False, the HTTP protocol is disabled. By default, when eAPI is first configured, the HTTP protocol is disabled.",
            "type": "string"
          },
          "http_port": {
            "description": "Configures the HTTP port that will listen for connections when the HTTP transport protocol is enabled.  This argument accepts integer values in the valid range of 1 to 65535.",
            "type": "string"
          },
          "https": {
            "description": "The `https' argument controls the operating state of the HTTPS transport protocol when eAPI is present in the running- config. When the value is set to True, the HTTPS protocol is enabled and when the value is set to False, the HTTPS protocol is disabled. By default, when eAPI is first configured, the HTTPS protocol is enabled.",
            "type": "string"
          },
          "https_port": {
            "description": "Configures the HTTP port that will listen for connections when the HTTP transport protocol is enabled.  This argument accepts integer values in the valid range of 1 to 65535.",
            "type": "string"
          },
          "local_http": {
            "description": "The `local_http' argument controls the operating state of the local HTTP transport protocol when eAPI is present in the running- config.  When the value is set to True, the HTTP protocol is enabled and restricted to connections from localhost only. When the value is set to False, the HTTP local protocol is disabled. Note is value is independent of the `http' argument",
            "type": "string"
          },
          "local_http_port": {
            "description": "Configures the HTTP port that will listen for connections when the HTTP transport protocol is enabled.  This argument accepts integer values in the valid range of 1 to 65535.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `eapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `eapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `eos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "socket": {
            "description": "The `socket' argument controls the operating state of the UNIX Domain Socket used to receive eAPI requests. When the value of this argument is set to True, the UDS will listen for eAPI requests.  When the value is set to False, the UDS will not be available to handle requests. By default when eAPI is first configured, the UDS is disabled.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH keyfile to use to authenticate the connection to the remote device.  This argument is only used for `cli' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "The `state' argument controls the operational state of eAPI on the remote device.  When this argument is set to `started', eAPI is enabled to receive requests and when this argument is `stopped', eAPI is disabled and will not receive requests.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=eapi'. If the transport argument is not eapi, this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the eAPI authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          },
          "vrf": {
            "description": "The `vrf' argument will configure eAPI to listen for connections in the specified VRF.  By default, eAPI transports will listen for connections in the global table. This value requires the VRF to already be created otherwise the task will fail.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "transport"
        ]
      }
    },
    {
      "eos_facts": {
        "type": "object",
        "description": "Collect facts from remote devices running Arista EOS",
        "properties": {
          "auth_pass": {
            "description": "Specifies the password to use if required to enter privileged mode on the remote device. If `authorize' is false, then this argument does nothing. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_AUTH_PASS' will be used instead.",
            "type": "string"
          },
          "authorize": {
            "description": "Instructs the module to enter privileged mode on the remote device before sending any commands.  If not specified, the device will attempt to execute all commands in non- privileged mode. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_AUTHORIZE' will be used instead.",
            "type": "string"
          },
          "gather_subset": {
            "description": "When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  Can specify a list of values to include a larger subset. Values can also be used with an initial `[!]' to specify that a specific subset should not be collected.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `eapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `eapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `eos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH keyfile to use to authenticate the connection to the remote device.  This argument is only used for `cli' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=eapi'. If the transport argument is not eapi, this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the eAPI authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "transport"
        ]
      }
    },
    {
      "execute_lambda": {
        "type": "object",
        "description": "Execute an AWS Lambda function",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "dry_run": {
            "description": "Do not *actually* invoke the function. A `DryRun' call will check that the caller has permissions to call the function, especially for checking cross- account permissions.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "function_arn": {
            "description": "The name of the function to be invoked",
            "type": "string"
          },
          "name": {
            "description": "The name of the function to be invoked. This can only be used for invocations within the calling account. To invoke a function in another account, use `function_arn' to specify the full ARN.",
            "type": "string"
          },
          "payload": {
            "description": "A dictionary in any form to be provided as input to the Lambda function.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "tail_log": {
            "description": "If `tail_log=true', the result of the task will include the last 4 KB of the CloudWatch log for the function execution. Log tailing only works if you use synchronous invocation `wait=true'. This is usually used for development or testing Lambdas.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "version_qualifier": {
            "description": "Which version/alias of the function to run. This defaults to the `LATEST' revision, but can be set to any existing version or alias. See htt ps;//docs.aws.ama zon.com/lambda/la test/dg /versioning- aliases.html for details.",
            "type": "string"
          },
          "wait": {
            "description": "Whether to wait for the function results or not. If `wait' is false, the task will not return any results. To wait for the Lambda function to complete, set `wait=true' and the result will be available in the `output' key.",
            "type": "string"
          }
        }
      }
    },
    {
      "exo_dns_domain": {
        "type": "object",
        "description": "Manages domain records on Exoscale DNS API.",
        "properties": {
          "api_key": {
            "description": "API key of the Exoscale DNS API.",
            "type": "string"
          },
          "api_region": {
            "description": "Name of the ini section in the `cloustack.ini' file.",
            "type": "string"
          },
          "api_secret": {
            "description": "Secret key of the Exoscale DNS API.",
            "type": "string"
          },
          "api_timeout": {
            "description": "HTTP timeout to Exoscale DNS API.",
            "type": "string"
          },
          "name": {
            "description": "Name of the record.",
            "type": "string"
          },
          "state": {
            "description": "State of the resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Validate SSL certs of the Exoscale DNS API.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "exo_dns_record": {
        "type": "object",
        "description": "Manages DNS records on Exoscale DNS.",
        "properties": {
          "api_key": {
            "description": "API key of the Exoscale DNS API.",
            "type": "string"
          },
          "api_region": {
            "description": "Name of the ini section in the `cloustack.ini' file.",
            "type": "string"
          },
          "api_secret": {
            "description": "Secret key of the Exoscale DNS API.",
            "type": "string"
          },
          "api_timeout": {
            "description": "HTTP timeout to Exoscale DNS API.",
            "type": "string"
          },
          "content": {
            "description": "Content of the record. Required if `state=present' or `name=\"\"'",
            "type": "string"
          },
          "domain": {
            "description": "Domain the record is related to.",
            "type": "string"
          },
          "multiple": {
            "description": "Whether there are more than one records with similar `name'. Only allowed with `record_type=A'. `content' will not be updated as it is used as key to find the record.",
            "type": "string"
          },
          "name": {
            "description": "Name of the record.",
            "type": "string"
          },
          "prio": {
            "description": "Priority of the record.",
            "type": "string"
          },
          "record_type": {
            "description": "Type of the record.",
            "type": "string"
          },
          "state": {
            "description": "State of the record.",
            "type": "string"
          },
          "ttl": {
            "description": "TTL of the record in seconds.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Validate SSL certs of the Exoscale DNS API.",
            "type": "string"
          }
        },
        "required": "domain"
      }
    },
    {
      "expect": {
        "type": "object",
        "description": "Executes a command and responds to prompts",
        "properties": {
          "chdir": {
            "description": "cd into this directory before running the command",
            "type": "string"
          },
          "command": {
            "description": "the command module takes command to run.",
            "type": "string"
          },
          "creates": {
            "description": "a filename, when it already exists, this step will *not* be run.",
            "type": "string"
          },
          "echo": {
            "description": "Whether or not to echo out your response strings",
            "type": "string"
          },
          "removes": {
            "description": "a filename, when it does not exist, this step will *not* be run.",
            "type": "string"
          },
          "responses": {
            "description": "Mapping of expected string/regex and string to respond with. If the response is a list, successive matches return successive responses. List functionality is new in 2.1.",
            "type": "string"
          },
          "timeout": {
            "description": "Amount of time in seconds to wait for the expected strings",
            "type": "string"
          }
        },
        "required": [
          "command",
          "responses"
        ]
      }
    },
    {
      "facter": {
        "type": "object",
        "description": "Runs the discovery program `facter' on the remote system",
        "properties": null
      }
    },
    {
      "fail": {
        "type": "object",
        "description": "Fail with custom message",
        "properties": {
          "msg": {
            "description": "The customized message used for failing execution. If omitted, fail will simple bail out with a generic message.",
            "type": "string"
          }
        }
      }
    },
    {
      "fetch": {
        "type": "object",
        "description": "Fetches a file from remote nodes",
        "properties": {
          "dest": {
            "description": "A directory to save the file into. For example, if the `dest' directory is `/backup' a `src' file named `/etc/profile' on host `host.exampl e.com', would be saved into `/back up/host.example.c om/etc/profile'",
            "type": "string"
          },
          "fail_on_missing": {
            "description": "When set to 'yes', the task will fail if the source file is missing.",
            "type": "string"
          },
          "flat": {
            "description": "Allows you to override the default behavior of appending hostnam e/path/to/file to the destination. If dest ends with '/', it will use the basename of the source file, similar to the copy module. Obviously this is only handy if the filenames are unique.",
            "type": "string"
          },
          "src": {
            "description": "The file on the remote system to fetch. This `must' be a file, not a directory. Recursive fetching may be supported in a later release.",
            "type": "string"
          },
          "validate_checksum": {
            "description": "Verify that the source and destination checksums match after the files are fetched.",
            "type": "string"
          }
        },
        "required": [
          "dest",
          "src"
        ]
      }
    },
    {
      "file": {
        "type": "object",
        "description": "Sets attributes of files",
        "properties": {
          "follow": {
            "description": "This flag indicates that filesystem links, if they exist, should be followed.",
            "type": "string"
          },
          "force": {
            "description": "force the creation of the symlinks in two cases: the source file does not exist (but will appear later); the destination exists and is a file (so, we need to unlink the \"path\" file and create symlink to the \"src\" file in place of it).",
            "type": "string"
          },
          "group": {
            "description": "name of the group that should own the file/directory, as would be fed to `chown'",
            "type": "string"
          },
          "mode": {
            "description": "mode the file or directory should be. For those used to `/usr/bin/chmod' remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, `u+rwx' or `u=rw,g=r,o=r').",
            "type": "string"
          },
          "owner": {
            "description": "name of the user that should own the file/directory, as would be fed to `chown'",
            "type": "string"
          },
          "path": {
            "description": "path to the file being managed.  Aliases: `dest', `name'",
            "type": "string"
          },
          "recurse": {
            "description": "recursively set the specified file attributes (applies only to state=directory)",
            "type": "string"
          },
          "selevel": {
            "description": "level part of the SELinux file context. This is the MLS/MCS attribute, sometimes known as the `range'. `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "serole": {
            "description": "role part of SELinux file context, `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "setype": {
            "description": "type part of SELinux file context, `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "seuser": {
            "description": "user part of SELinux file context. Will default to system policy, if applicable. If set to `_default', it will use the `user' portion of the policy if available",
            "type": "string"
          },
          "src": {
            "description": "path of the file to link to (applies only to `state=link'). Will accept absolute, relative and nonexisting paths. Relative paths are not expanded.",
            "type": "string"
          },
          "state": {
            "description": "If `directory', all immediate subdirectories will be created if they do not exist, since 1.7 they will be created with the supplied permissions. If `file', the file will NOT be created if it does not exist, see the [copy] or [template] module if you want that behavior.  If `link', the symbolic link will be created or changed. Use `hard' for hardlinks. If `absent', directories will be recursively deleted, and files or symlinks will be unlinked. Note that [file] will not fail if the `path' does not exist as the state did not change. If `touch' (new in 1.4), an empty file will be created if the `path' does not exist, while an existing file or directory will receive updated file access and modification times (similar to the way `touch` works from the command line).",
            "type": "string"
          },
          "unsafe_writes": {
            "description": "Normally this module uses atomic operations to prevent data corruption or inconsistent reads from the target files, sometimes systems are configured or just broken in ways that prevent this. One example are docker mounted files, they cannot be updated atomically and can only be done in an unsafe manner. This boolean option allows ansible to fall back to unsafe methods of updating files for those cases in which you do not have any other choice. Be aware that this is subject to race conditions and can lead to data corruption.",
            "type": "string"
          }
        },
        "required": "path"
      }
    },
    {
      "filesystem": {
        "type": "object",
        "description": "Makes file system on block device",
        "properties": {
          "dev": {
            "description": "Target block device.",
            "type": "string"
          },
          "force": {
            "description": "If yes, allows to create new filesystem on devices that already has filesystem.",
            "type": "string"
          },
          "fstype": {
            "description": "File System type to be created. reiserfs support was added in 2.2.",
            "type": "string"
          },
          "opts": {
            "description": "List of options to be passed to mkfs command.",
            "type": "string"
          },
          "resizefs": {
            "description": "If yes, if the block device and filessytem size differ, grow the filesystem into the space. Note, XFS Will only grow if mounted.",
            "type": "string"
          }
        },
        "required": [
          "dev",
          "fstype"
        ]
      }
    },
    {
      "find": {
        "type": "object",
        "description": "return a list of files based on specific criteria",
        "properties": {
          "age": {
            "description": "Select files whose age is equal to or greater than the specified time. Use a negative age to find files equal to or less than the specified time. You can choose seconds, minutes, hours, days, or weeks by specifying the first letter of any of those words (e.g., \"1w\").",
            "type": "string"
          },
          "age_stamp": {
            "description": "Choose the file property against which we compare age. Default is mtime.",
            "type": "string"
          },
          "contains": {
            "description": "One or more regex patterns which should be matched against the file content",
            "type": "string"
          },
          "file_type": {
            "description": "Type of file to select",
            "type": "string"
          },
          "follow": {
            "description": "Set this to true to follow symlinks in path for systems with python 2.6+",
            "type": "string"
          },
          "get_checksum": {
            "description": "Set this to true to retrieve a file's sha1 checksum",
            "type": "string"
          },
          "hidden": {
            "description": "Set this to true to include hidden files, otherwise they'll be ignored.",
            "type": "string"
          },
          "paths": {
            "description": "List of paths to the file or directory to search. All paths must be fully qualified.",
            "type": "string"
          },
          "patterns": {
            "description": "One or more (shell or regex) patterns, which type is controlled by `use_regex' option. The patterns restrict the list of files to be returned to those whose basenames match at least one of the patterns specified. Multiple patterns can be specified using a list.",
            "type": "string"
          },
          "recurse": {
            "description": "If target is a directory, recursively descend into the directory looking for files.",
            "type": "string"
          },
          "size": {
            "description": "Select files whose size is equal to or greater than the specified size. Use a negative size to find files equal to or less than the specified size. Unqualified values are in bytes, but b, k, m, g, and t can be appended to specify bytes, kilobytes, megabytes, gigabytes, and terabytes, respectively. Size is not evaluated for directories.",
            "type": "string"
          },
          "use_regex": {
            "description": "If false the patterns are file globs (shell) if true they are python regexes",
            "type": "string"
          }
        },
        "required": "paths"
      }
    },
    {
      "firewalld": {
        "type": "object",
        "description": "Manage arbitrary ports/services with firewalld",
        "properties": {
          "immediate": {
            "description": "Should this configuration be applied immediately, if set as permanent",
            "type": "string"
          },
          "interface": {
            "description": "The interface you would like to add/remove to/from a zone in firewalld",
            "type": "string"
          },
          "masquerade": {
            "description": "The masquerade setting you would like to enable/disable to/from zones within firewalld",
            "type": "string"
          },
          "permanent": {
            "description": "Should this configuration be in the running firewalld configuration or persist across reboots.",
            "type": "string"
          },
          "port": {
            "description": "Name of a port or port range to add/remove to/from firewalld. Must be in the form PORT/PROTOCOL or PORT- PORT/PROTOCOL for port ranges.",
            "type": "string"
          },
          "rich_rule": {
            "description": "Rich rule to add/remove to/from firewalld.",
            "type": "string"
          },
          "service": {
            "description": "Name of a service to add/remove to/from firewalld - service must be listed in /etc/services.",
            "type": "string"
          },
          "source": {
            "description": "The source/network you would like to add/remove to/from firewalld",
            "type": "string"
          },
          "state": {
            "description": "Should this port accept(enabled) or reject(disabled) connections.",
            "type": "string"
          },
          "timeout": {
            "description": "The amount of time the rule should be in effect for when non- permanent.",
            "type": "string"
          },
          "zone": {
            "description": "The firewalld zone to add/remove to/from (NOTE: default zone can be configured per system but \"public\" is default from upstream. Available choices can be extended based on per- system configs, listed here are \"out of the box\" defaults).",
            "type": "string"
          }
        },
        "required": "state"
      }
    },
    {
      "flowadm": {
        "type": "object",
        "description": "Manage bandwidth resource control and priority for protocols, services and zones.",
        "properties": {
          "dsfield": {
            "description": "-   I d e n t i f i e s   t h e   8 - b i t   d i f f e r e n t i a t e d   s e r v i c e s   f i e l d   ( a s   d e f i n e d   i n   R F C   2 4 7 4 ) . T h e   o p t i o n a l   d s f i e l d _ m a s k   i s   u s e d   t o s t a t e   t h e b i t s   o f   i n t e r e s t   i n   t h e   d i f f e r e n t i a t e d   s e r v i c e s   f i e l d w h e n   c o m p a r i n g   w i t h   t h e   d s f i e l d   v a l u e .   B o t h   v a l u e s   m u s t   b e   i n   h e x a d e c i m a l .",
            "type": "string"
          },
          "link": {
            "description": "Specifiies a link to configure flow on.",
            "type": "string"
          },
          "local_ip": {
            "description": "Identifies a network flow by the local IP address.",
            "type": "string"
          },
          "local_port": {
            "description": "Identifies a service specified by the local port.",
            "type": "string"
          },
          "maxbw": {
            "description": "-   S e t s   t h e   f u l l   d u p l e x   b a n d w i d t h f o r   t h e   f l o w .   T h e b a n d w i d t h i s   s p e c i f i e d   a s   a n i n t e g e r   w i t h   o n e   o f   t h e   s c a l e   s u f f i x e s ( K ,   M , o r   G   f o r K b p s ,   M b p s ,   a n d   G b p s ) .   I f   n o   u n i t s   a r e   s p e c i f i e d ,   t h e i n p u t   v a l u e   w i l l   b e   r e a d   a s M b p s .",
            "type": "string"
          },
          "name": {
            "description": "-   A   f l o w   i s   d e f i n e d   a s   a s e t   o f   a t t r i b u t e s b a s e d   o n L a y e r   3   a n d   L a y e r 4   h e a d e r s ,   w h i c h   c a n   b e   u s e d   t o   i d e n t i f y   a   p r o t o c o l ,   s e r v i c e ,   o r   a   z o n e .",
            "type": "string"
          },
          "priority": {
            "description": "Sets the relative priority for the flow.",
            "type": "string"
          },
          "remove_ip": {
            "description": "Identifies a network flow by the remote IP address.",
            "type": "string"
          },
          "state": {
            "description": "Create/delete/enable/disable an IP address on the network interface.",
            "type": "string"
          },
          "temporary": {
            "description": "Specifies that the configured flow is temporary. Temporary flows do not persist across reboots.",
            "type": "string"
          },
          "transport": {
            "description": "-   S p e c i f i e s   a   L a y e r   4   p r o t o c o l   t o b e   u s e d . I t   i s   t y p i c a l l y   u s e d   i n   c o m b i n a t i o n w i t h   I ( l o c a l _ p o r t ) t o   i d e n t i f y   t h e   s e r v i c e   t h a t   n e e d s   s p e c i a l   a t t e n t i o n .",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "flowdock": {
        "type": "object",
        "description": "Send a message to a flowdock",
        "properties": {
          "external_user_name": {
            "description": "(chat only - required) Name of the \"user\" sending the message",
            "type": "string"
          },
          "from_address": {
            "description": "(inbox only - required) Email address of the message sender",
            "type": "string"
          },
          "from_name": {
            "description": "(inbox only) Name of the message sender",
            "type": "string"
          },
          "link": {
            "description": "(inbox only) Link associated with the message. This will be used to link the message subject in Team Inbox.",
            "type": "string"
          },
          "msg": {
            "description": "Content of the message",
            "type": "string"
          },
          "project": {
            "description": "(inbox only) Human readable identifier for more detailed message categorization",
            "type": "string"
          },
          "reply_to": {
            "description": "(inbox only) Email address for replies",
            "type": "string"
          },
          "source": {
            "description": "(inbox only - required) Human readable identifier of the application that uses the Flowdock API",
            "type": "string"
          },
          "subject": {
            "description": "(inbox only - required) Subject line of the message",
            "type": "string"
          },
          "tags": {
            "description": "tags of the message, separated by commas",
            "type": "string"
          },
          "token": {
            "description": "API token.",
            "type": "string"
          },
          "type": {
            "description": "Whether to post to 'inbox' or 'chat'",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": [
          "msg",
          "token",
          "type"
        ]
      }
    },
    {
      "gc_storage": {
        "type": "object",
        "description": "This module manages objects/buckets in Google Cloud Storage.",
        "properties": {
          "bucket": {
            "description": "Bucket name.",
            "type": "string"
          },
          "dest": {
            "description": "The destination file path when downloading an object/key with a GET operation.",
            "type": "string"
          },
          "expiration": {
            "description": "Time limit (in seconds) for the URL generated and returned by GCA when performing a mode=put or mode=get_url operation. This url is only available when public-read is the acl for the object.",
            "type": "string"
          },
          "force": {
            "description": "Forces an overwrite either locally on the filesystem or remotely with the object/key. Used with PUT and GET operations.",
            "type": "string"
          },
          "gs_access_key": {
            "description": "GS access key. If not set then the value of the GS_ACCESS_KEY_ID environment variable is used.",
            "type": "string"
          },
          "gs_secret_key": {
            "description": "GS secret key. If not set then the value of the GS_SECRET_ACCESS_ KEY environment variable is used.",
            "type": "string"
          },
          "headers": {
            "description": "Headers to attach to object.",
            "type": "string"
          },
          "mode": {
            "description": "Switches the module behaviour between upload, download, get_url (return download url) , get_str (download object as string), create (bucket) and delete (bucket).",
            "type": "string"
          },
          "object": {
            "description": "Keyname of the object inside the bucket. Can be also be used to create \"virtual directories\" (see examples).",
            "type": "string"
          },
          "permission": {
            "description": "This option let's the user set the canned permissions on the object/bucket that are created. The permissions that can be set are 'private', 'public-read', 'authenticated- read'.",
            "type": "string"
          },
          "src": {
            "description": "The source file path when performing a PUT operation.",
            "type": "string"
          }
        },
        "required": [
          "bucket",
          "gs_access_key",
          "gs_secret_key",
          "mode"
        ]
      }
    },
    {
      "gcdns_record": {
        "type": "object",
        "description": "Creates or removes resource records in Google Cloud DNS",
        "properties": {
          "credentials_file": {
            "description": "The path to the JSON file associated with the service account email.",
            "type": "string"
          },
          "overwrite": {
            "description": "Whether an attempt to overwrite an existing record should succeed or fail. The behavior of this option depends on `state'. If `state' is `present' and `overwrite' is `True', this module will replace an existing resource record of the same name with the provided `record_data'. If `state' is `present' and `overwrite' is `False', this module will fail if there is an existing resource record with the same name and type, but different resource data. If `state' is `absent' and `overwrite' is `True', this module will remove the given resource record unconditionally. If `state' is `absent' and `overwrite' is `False', this module will fail if the provided record_data do not match exactly with the existing resource record's record_data.",
            "type": "string"
          },
          "pem_file": {
            "description": "The path to the PEM file associated with the service account email. This option is deprecated and may be removed in a future release. Use `credentials_ file' instead.",
            "type": "string"
          },
          "project_id": {
            "description": "The Google Cloud Platform project ID to use.",
            "type": "string"
          },
          "record": {
            "description": "The fully-qualified domain name of the resource record.",
            "type": "string"
          },
          "record_data": {
            "description": "The record_data to use for the resource record. `record_data' must be specified if `state' is `present' or `overwrite' is `True', or the module will fail. Valid record_data vary based on the record's `type'. In addition, resource records that contain a DNS domain name in the value field (e.g., CNAME, PTR, SRV, .etc) MUST include a trailing dot in the value. Individual string record_data for TXT records must be enclosed in double quotes. For resource records that have the same name but different record_data (e.g., multiple A records), they must be defined as multiple list entries in a single record.",
            "type": "string"
          },
          "service_account_email": {
            "description": "The e-mail address for a service account with access to Google Cloud DNS.",
            "type": "string"
          },
          "state": {
            "description": "Whether the given resource record should or should not be present.",
            "type": "string"
          },
          "ttl": {
            "description": "The amount of time in seconds that a resource record will remain cached by a caching resolver.",
            "type": "string"
          },
          "type": {
            "description": "The type of resource record to add.",
            "type": "string"
          },
          "zone": {
            "description": "The DNS domain name of the zone (e.g., example.com). One of either `zone' or `zone_id' must be specified as an option, or the module will fail. If both `zone' and `zone_id' are specifed, `zone_id' will be used.",
            "type": "string"
          },
          "zone_id": {
            "description": "The Google Cloud ID of the zone (e.g., example- com). One of either `zone' or `zone_id' must be specified as an option, or the module will fail. These usually take the form of domain names with the dots replaced with dashes. A zone ID will never have any dots in it. `zone_id' can be faster than `zone' in projects with a large number of zones. If both `zone' and `zone_id' are specifed, `zone_id' will be used.",
            "type": "string"
          }
        },
        "required": [
          "record",
          "type"
        ]
      }
    },
    {
      "gcdns_zone": {
        "type": "object",
        "description": "Creates or removes zones in Google Cloud DNS",
        "properties": {
          "credentials_file": {
            "description": "The path to the JSON file associated with the service account email.",
            "type": "string"
          },
          "description": {
            "description": "An arbitrary text string to use for the zone description.",
            "type": "string"
          },
          "pem_file": {
            "description": "The path to the PEM file associated with the service account email. This option is deprecated and may be removed in a future release. Use `credentials_ file' instead.",
            "type": "string"
          },
          "project_id": {
            "description": "The Google Cloud Platform project ID to use.",
            "type": "string"
          },
          "service_account_email": {
            "description": "The e-mail address for a service account with access to Google Cloud DNS.",
            "type": "string"
          },
          "state": {
            "description": "Whether the given zone should or should not be present.",
            "type": "string"
          },
          "zone": {
            "description": "The DNS domain name of the zone. This is NOT the Google Cloud DNS zone ID (e.g., example-com). If you attempt to specify a zone ID, this module will attempt to create a TLD and will fail.",
            "type": "string"
          }
        },
        "required": "zone"
      }
    },
    {
      "gce": {
        "type": "object",
        "description": "create or terminate GCE instances",
        "properties": {
          "credentials_file": {
            "description": "path to the JSON file associated with the service account email",
            "type": "string"
          },
          "disk_auto_delete": {
            "description": "if set boot disk will be removed after instance destruction",
            "type": "string"
          },
          "disks": {
            "description": "a list of persistent disks to attach to the instance; a string value gives the name of the disk; alternatively, a dictionary value can define 'name' and 'mode' ('READ_ONLY' or 'READ_WRITE'). The first entry will be the boot disk (which must be READ_WRITE).",
            "type": "string"
          },
          "external_ip": {
            "description": "type of external ip, ephemeral by default; alternatively, a list of fixed gce ips or ip names can be given (if there is not enough specified ip, 'ephemeral' will be used). Specify 'none' if no external ip is desired.",
            "type": "string"
          },
          "image": {
            "description": "image string to use for the instance",
            "type": "string"
          },
          "instance_names": {
            "description": "a comma-separated list of instance names to create or destroy",
            "type": "string"
          },
          "ip_forward": {
            "description": "set to true if the instance can forward ip packets (useful for gateways)",
            "type": "string"
          },
          "machine_type": {
            "description": "machine type to use for the instance, use 'n1-standard-1' by default",
            "type": "string"
          },
          "metadata": {
            "description": "a hash/dictionary of custom data for the instance; '{\"key\":\"value\", ...}'",
            "type": "string"
          },
          "name": {
            "description": "identifier when working with a single instance",
            "type": "string"
          },
          "network": {
            "description": "name of the network, 'default' will be used if not specified",
            "type": "string"
          },
          "pem_file": {
            "description": "path to the pem file associated with the service account email This option is deprecated. Use ' credentials_file' .",
            "type": "string"
          },
          "persistent_boot_disk": {
            "description": "if set, create the instance with a persistent boot disk",
            "type": "string"
          },
          "preemptible": {
            "description": "if set to true, instances will be preemptible and time-limited. (requires libcloud >= 0.20.0)",
            "type": "string"
          },
          "project_id": {
            "description": "your GCE project ID",
            "type": "string"
          },
          "service_account_email": {
            "description": "service account email",
            "type": "string"
          },
          "service_account_permissions": {
            "description": "service account permissions (see https://cloud.g oogle.com/sdk/gcl oud/reference/com pute/instances/cr eate, --scopes section for detailed information)",
            "type": "string"
          },
          "state": {
            "description": "desired state of the resource",
            "type": "string"
          },
          "subnetwork": {
            "description": "name of the subnetwork in which the instance should be created",
            "type": "string"
          },
          "tags": {
            "description": "a comma-separated list of tags to associate with the instance",
            "type": "string"
          },
          "zone": {
            "description": "the GCE zone to use",
            "type": "string"
          }
        },
        "required": "zone"
      }
    },
    {
      "gce_img": {
        "type": "object",
        "description": "utilize GCE image resources",
        "properties": {
          "description": {
            "description": "an optional description",
            "type": "string"
          },
          "family": {
            "description": "an optional family name",
            "type": "string"
          },
          "name": {
            "description": "the name of the image to create or delete",
            "type": "string"
          },
          "pem_file": {
            "description": "path to the pem file associated with the service account email",
            "type": "string"
          },
          "project_id": {
            "description": "your GCE project ID",
            "type": "string"
          },
          "service_account_email": {
            "description": "service account email",
            "type": "string"
          },
          "source": {
            "description": "the source disk or the Google Cloud Storage URI to create the image from",
            "type": "string"
          },
          "state": {
            "description": "desired state of the image",
            "type": "string"
          },
          "timeout": {
            "description": "timeout for the operation",
            "type": "string"
          },
          "zone": {
            "description": "the zone of the disk specified by source",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "gce_lb": {
        "type": "object",
        "description": "create/destroy GCE load-balancer resources",
        "properties": {
          "credentials_file": {
            "description": "path to the JSON file associated with the service account email",
            "type": "string"
          },
          "external_ip": {
            "description": "the external static IPv4 (or auto-assigned) address for the LB",
            "type": "string"
          },
          "httphealthcheck_healthy_count": {
            "description": "number of consecutive successful checks before marking a node healthy",
            "type": "string"
          },
          "httphealthcheck_host": {
            "description": "host header to pass through on HTTP check requests",
            "type": "string"
          },
          "httphealthcheck_interval": {
            "description": "the duration in seconds between each health check request",
            "type": "string"
          },
          "httphealthcheck_name": {
            "description": "the name identifier for the HTTP health check",
            "type": "string"
          },
          "httphealthcheck_path": {
            "description": "the url path to use for HTTP health checking",
            "type": "string"
          },
          "httphealthcheck_port": {
            "description": "the TCP port to use for HTTP health checking",
            "type": "string"
          },
          "httphealthcheck_timeout": {
            "description": "the timeout in seconds before a request is considered a failed check",
            "type": "string"
          },
          "httphealthcheck_unhealthy_count": {
            "description": "number of consecutive failed checks before marking a node unhealthy",
            "type": "string"
          },
          "members": {
            "description": "a list of zone/nodename pairs, e.g ['us- central1-a/www-a' , ...]",
            "type": "string"
          },
          "name": {
            "description": "name of the load-balancer resource",
            "type": "string"
          },
          "pem_file": {
            "description": "path to the pem file associated with the service account email This option is deprecated. Use ' credentials_file' .",
            "type": "string"
          },
          "port_range": {
            "description": "the port (range) to forward, e.g. 80 or 8000-8888 defaults to all ports",
            "type": "string"
          },
          "project_id": {
            "description": "your GCE project ID",
            "type": "string"
          },
          "protocol": {
            "description": "the protocol used for the load-balancer packet forwarding, tcp or udp",
            "type": "string"
          },
          "region": {
            "description": "the GCE region where the load-balancer is defined",
            "type": "string"
          },
          "service_account_email": {
            "description": "service account email",
            "type": "string"
          },
          "state": {
            "description": "desired state of the LB",
            "type": "string"
          }
        }
      }
    },
    {
      "gce_mig": {
        "type": "object",
        "description": "Create, Update or Destroy a Managed Instance Group (MIG).",
        "properties": {
          "autoscaling": {
            "description": "A dictionary of configuration for the autoscaler. 'enabled (bool)', 'name (str)' and  policy.max_instan ces (int) are required fields if autoscaling is used. See https:/ /cloud.google.com /compute/docs/ref erence/beta/autos calers for more information on Autoscaling.",
            "type": "string"
          },
          "credentials_file": {
            "description": "Path to the JSON file associated with the service account email",
            "type": "string"
          },
          "name": {
            "description": "Name of the Managed Instance Group.",
            "type": "string"
          },
          "project_id": {
            "description": "GCE project ID",
            "type": "string"
          },
          "service_account_email": {
            "description": "service account email",
            "type": "string"
          },
          "size": {
            "description": "Size of Managed Instance Group.  If MIG already exists, it will be resized to the number provided here.  Required for creating MIGs.",
            "type": "string"
          },
          "state": {
            "description": "desired state of the resource",
            "type": "string"
          },
          "template": {
            "description": "Instance Template to be used in creating the VMs.  See https:/ /cloud.google.com /compute/docs /instance- templates to learn more about Instance Templates. Required for creating MIGs.",
            "type": "string"
          },
          "zone": {
            "description": "The GCE zone to use for this Managed Instance Group.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "zone"
        ]
      }
    },
    {
      "gce_net": {
        "type": "object",
        "description": "create/destroy GCE networks and firewall rules",
        "properties": {
          "allowed": {
            "description": "the protocol:ports to allow ('tcp:80' or 'tcp:80,443' or ' tcp:80-800;udp:1- 25') this parameter is mandatory when creating or updating a firewall rule",
            "type": "string"
          },
          "credentials_file": {
            "description": "path to the JSON file associated with the service account email",
            "type": "string"
          },
          "fwname": {
            "description": "name of the firewall rule",
            "type": "string"
          },
          "ipv4_range": {
            "description": "the IPv4 address range in CIDR notation for the network this parameter is not mandatory when you specified existing network in name parameter, but when you create new network, this parameter is mandatory",
            "type": "string"
          },
          "mode": {
            "description": "network mode for Google Cloud \"legacy\" indicates a network with an IP address range \"auto\" automatically generates subnetworks in different regions \"custom\" uses networks to group subnets of user specified IP address ranges ht tps://cloud.googl e.com/compute/doc s/networking#netw ork_types",
            "type": "string"
          },
          "name": {
            "description": "name of the network",
            "type": "string"
          },
          "pem_file": {
            "description": "path to the pem file associated with the service account email This option is deprecated. Use ' credentials_file' .",
            "type": "string"
          },
          "project_id": {
            "description": "your GCE project ID",
            "type": "string"
          },
          "service_account_email": {
            "description": "service account email",
            "type": "string"
          },
          "src_range": {
            "description": "the source IPv4 address range in CIDR notation",
            "type": "string"
          },
          "src_tags": {
            "description": "the source instance tags for creating a firewall rule",
            "type": "string"
          },
          "state": {
            "description": "desired state of the network or firewall",
            "type": "string"
          },
          "subnet_desc": {
            "description": "description of subnet to create",
            "type": "string"
          },
          "subnet_name": {
            "description": "name of subnet to create",
            "type": "string"
          },
          "subnet_region": {
            "description": "region of subnet to create",
            "type": "string"
          },
          "target_tags": {
            "description": "the target instance tags for creating a firewall rule",
            "type": "string"
          }
        }
      }
    },
    {
      "gce_pd": {
        "type": "object",
        "description": "utilize GCE persistent disk resources",
        "properties": {
          "credentials_file": {
            "description": "path to the JSON file associated with the service account email",
            "type": "string"
          },
          "detach_only": {
            "description": "do not destroy the disk, merely detach it from an instance",
            "type": "string"
          },
          "disk_type": {
            "description": "type of disk provisioned",
            "type": "string"
          },
          "image": {
            "description": "the source image to use for the disk",
            "type": "string"
          },
          "instance_name": {
            "description": "instance name if you wish to attach or detach the disk",
            "type": "string"
          },
          "mode": {
            "description": "GCE mount mode of disk, READ_ONLY (default) or READ_WRITE",
            "type": "string"
          },
          "name": {
            "description": "name of the disk",
            "type": "string"
          },
          "pem_file": {
            "description": "path to the pem file associated with the service account email This option is deprecated. Use ' credentials_file' .",
            "type": "string"
          },
          "project_id": {
            "description": "your GCE project ID",
            "type": "string"
          },
          "service_account_email": {
            "description": "service account email",
            "type": "string"
          },
          "size_gb": {
            "description": "whole integer size of disk (in GB) to create, default is 10 GB",
            "type": "string"
          },
          "snapshot": {
            "description": "the source snapshot to use for the disk",
            "type": "string"
          },
          "state": {
            "description": "desired state of the persistent disk",
            "type": "string"
          },
          "zone": {
            "description": "zone in which to create the disk",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "gce_tag": {
        "type": "object",
        "description": "add or remove tag(s) to/from GCE instance",
        "properties": {
          "instance_name": {
            "description": "the name of the GCE instance to add/remove tags",
            "type": "string"
          },
          "pem_file": {
            "description": "path to the pem file associated with the service account email",
            "type": "string"
          },
          "project_id": {
            "description": "your GCE project ID",
            "type": "string"
          },
          "service_account_email": {
            "description": "service account email",
            "type": "string"
          },
          "state": {
            "description": "desired state of the tags",
            "type": "string"
          },
          "tags": {
            "description": "comma-separated list of tags to add or remove",
            "type": "string"
          },
          "zone": {
            "description": "the zone of the disk specified by source",
            "type": "string"
          }
        },
        "required": [
          "instance_name",
          "tags"
        ]
      }
    },
    {
      "gem": {
        "type": "object",
        "description": "Manage Ruby gems",
        "properties": {
          "build_flags": {
            "description": "Allow adding build flags for gem compilation",
            "type": "string"
          },
          "env_shebang": {
            "description": "Rewrite the shebang line on installed scripts to use /usr/bin/env.",
            "type": "string"
          },
          "executable": {
            "description": "Override the path to the gem executable",
            "type": "string"
          },
          "gem_source": {
            "description": "The path to a local gem used as installation source.",
            "type": "string"
          },
          "include_dependencies": {
            "description": "Whether to include dependencies or not.",
            "type": "string"
          },
          "include_doc": {
            "description": "Install with or without docs.",
            "type": "string"
          },
          "name": {
            "description": "The name of the gem to be managed.",
            "type": "string"
          },
          "pre_release": {
            "description": "Allow installation of pre-release versions of the gem.",
            "type": "string"
          },
          "repository": {
            "description": "The repository from which the gem will be installed",
            "type": "string"
          },
          "state": {
            "description": "The desired state of the gem. `latest' ensures that the latest version is installed.",
            "type": "string"
          },
          "user_install": {
            "description": "Install gem in user's local gems cache or for all users",
            "type": "string"
          },
          "version": {
            "description": "Version of the gem to be installed/removed.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "get_url": {
        "type": "object",
        "description": "Downloads files from HTTP, HTTPS, or FTP to node",
        "properties": {
          "backup": {
            "description": "Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.",
            "type": "string"
          },
          "checksum": {
            "description": "If a checksum is passed to this parameter, the digest of the destination file will be calculated after it is downloaded to ensure its integrity and verify that the transfer completed successfully. Format: <algorith m>:<checksum>, e.g.: checksum=\"s ha256:D98291AC[.. .]B6DC7B97\" If you worry about portability, only the sha1 algorithm is available on all platforms and python versions. The third party hashlib library can be installed for access to additional algorithms. Additionally, if a checksum is passed to this parameter, and the file exist under the `dest' location, the des tination_checksum would be calculated, and if checksum equals destinatio n_checksum, the file download would be skipped (unless `force' is true).",
            "type": "string"
          },
          "dest": {
            "description": "absolute path of where to download the file to. If `dest' is a directory, either the server provided filename or, if none provided, the base name of the URL on the remote server will be used. If a directory, `force' has no effect. If `dest' is a directory, the file will always be downloaded (regardless of the force option), but replaced only if the contents changed.",
            "type": "string"
          },
          "force": {
            "description": "If `yes' and `dest' is not a directory, will download the file every time and replace the file if the contents change. If `no', the file will only be downloaded if the destination does not exist. Generally should be `yes' only for small local files. Prior to 0.6, this module behaved as if `yes' was the default.",
            "type": "string"
          },
          "force_basic_auth": {
            "description": "httplib2, the library used by the uri module only sends authentication information when a webservice responds to an initial request with a 401 status. Since some basic auth services do not properly send a 401, logins will fail. This option forces the sending of the Basic authentication header upon initial request.",
            "type": "string"
          },
          "group": {
            "description": "name of the group that should own the file/directory, as would be fed to `chown'",
            "type": "string"
          },
          "headers": {
            "description": "Add custom HTTP headers to a request in the format \"key:value ,key:value\"",
            "type": "string"
          },
          "mode": {
            "description": "mode the file or directory should be. For those used to `/usr/bin/chmod' remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, `u+rwx' or `u=rw,g=r,o=r').",
            "type": "string"
          },
          "others": {
            "description": "all arguments accepted by the [file] module also work here",
            "type": "string"
          },
          "owner": {
            "description": "name of the user that should own the file/directory, as would be fed to `chown'",
            "type": "string"
          },
          "selevel": {
            "description": "level part of the SELinux file context. This is the MLS/MCS attribute, sometimes known as the `range'. `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "serole": {
            "description": "role part of SELinux file context, `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "setype": {
            "description": "type part of SELinux file context, `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "seuser": {
            "description": "user part of SELinux file context. Will default to system policy, if applicable. If set to `_default', it will use the `user' portion of the policy if available",
            "type": "string"
          },
          "sha256sum": {
            "description": "If a SHA-256 checksum is passed to this parameter, the digest of the destination file will be calculated after it is downloaded to ensure its integrity and verify that the transfer completed successfully. This option is deprecated. Use 'checksum'.",
            "type": "string"
          },
          "timeout": {
            "description": "Timeout in seconds for URL request",
            "type": "string"
          },
          "tmp_dest": {
            "description": "absolute path of where temporary file is downloaded to. Defaults to TMPDIR, TEMP or TMP env variables or a platform specific value ht tps://docs.python .org/2/library/te mpfile.html#tempf ile.tempdir",
            "type": "string"
          },
          "unsafe_writes": {
            "description": "Normally this module uses atomic operations to prevent data corruption or inconsistent reads from the target files, sometimes systems are configured or just broken in ways that prevent this. One example are docker mounted files, they cannot be updated atomically and can only be done in an unsafe manner. This boolean option allows ansible to fall back to unsafe methods of updating files for those cases in which you do not have any other choice. Be aware that this is subject to race conditions and can lead to data corruption.",
            "type": "string"
          },
          "url": {
            "description": "HTTP, HTTPS, or FTP URL in the form (http|https| ftp)://[user[:pas s]]@host.domain[: port]/path",
            "type": "string"
          },
          "url_password": {
            "description": "The password for use in HTTP basic authentication. If the `url_username' parameter is not specified, the `url_password' parameter will not be used.",
            "type": "string"
          },
          "url_username": {
            "description": "The username for use in HTTP basic authentication. This parameter can be used without `url_password' for sites that allow empty passwords.",
            "type": "string"
          },
          "use_proxy": {
            "description": "if `no', it will not use a proxy, even if one is defined in an environment variable on the target hosts.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": [
          "dest",
          "url"
        ]
      }
    },
    {
      "getent": {
        "type": "object",
        "description": "a wrapper to the unix getent utility",
        "properties": {
          "database": {
            "description": "the name of a getent database supported by the target system (passwd, group, hosts, etc).",
            "type": "string"
          },
          "fail_key": {
            "description": "If a supplied key is missing this will make the task fail if True",
            "type": "string"
          },
          "key": {
            "description": "key from which to return values from the specified database, otherwise the full contents are returned.",
            "type": "string"
          },
          "split": {
            "description": "character used to split the database values into lists/arrays such as ':' or '  ', otherwise  it will try to pick one depending on the database",
            "type": "string"
          }
        },
        "required": "database"
      }
    },
    {
      "git": {
        "type": "object",
        "description": "Deploy software (or files) from git checkouts",
        "properties": {
          "accept_hostkey": {
            "description": "if `yes', adds the hostkey for the repo url if not already added. If ssh_opts contains \"-o StrictHostKey Checking=no\", this parameter is ignored.",
            "type": "string"
          },
          "bare": {
            "description": "if `yes', repository will be created as a bare repo, otherwise it will be a standard repo with a workspace.",
            "type": "string"
          },
          "clone": {
            "description": "If `no', do not clone the repository if it does not exist locally",
            "type": "string"
          },
          "depth": {
            "description": "Create a shallow clone with a history truncated to the specified number or revisions. The minimum possible value is `1', otherwise ignored. Needs `git>=1.9.1' to work correctly.",
            "type": "string"
          },
          "dest": {
            "description": "Absolute path of where the repository should be checked out to. This parameter is required, unless `clone' is set to `no' This change was made in version 1.8.3. Prior to this version, the `dest' parameter was always required.",
            "type": "string"
          },
          "executable": {
            "description": "Path to git executable to use. If not supplied, the normal mechanism for resolving binary paths will be used.",
            "type": "string"
          },
          "force": {
            "description": "If `yes', any modified files in the working repository will be discarded. Prior to 0.7, this was always 'yes' and could not be disabled. Prior to 1.9, the default was `yes`",
            "type": "string"
          },
          "key_file": {
            "description": "Specify an optional private key file to use for the checkout.",
            "type": "string"
          },
          "recursive": {
            "description": "if `no', repository will be cloned without the --recursive option, skipping sub-modules.",
            "type": "string"
          },
          "reference": {
            "description": "Reference repository (see \"git clone --reference ...\")",
            "type": "string"
          },
          "refspec": {
            "description": "Add an additional refspec to be fetched. If version is set to a `SHA-1' not reachable from any branch or tag, this option may be necessary to specify the ref containing the `SHA-1'. Uses the same syntax as the 'git fetch' command. An example value could be \"refs/me ta/config\".",
            "type": "string"
          },
          "remote": {
            "description": "Name of the remote.",
            "type": "string"
          },
          "repo": {
            "description": "git, SSH, or HTTP(S) protocol address of the git repository.",
            "type": "string"
          },
          "ssh_opts": {
            "description": "Creates a wrapper script and exports the path as GIT_SSH which git then automatically uses to override ssh arguments. An example value could be \"-o Stri ctHostKeyChecking =no\"",
            "type": "string"
          },
          "track_submodules": {
            "description": "if `yes', submodules will track the latest commit on their master branch (or other branch specified in .gitmodules).  If `no', submodules will be kept at the revision specified by the main project. This is equivalent to specifying the --remote flag to git submodule update.",
            "type": "string"
          },
          "umask": {
            "description": "The umask to set before doing any checkouts, or any other repository maintenance.",
            "type": "string"
          },
          "update": {
            "description": "If `no', do not retrieve new revisions from the origin repository",
            "type": "string"
          },
          "verify_commit": {
            "description": "if `yes', when cloning or checking out a `version' verify the signature of a GPG signed commit. This requires `git' version>=2.1.0 to be installed. The commit MUST be signed and the public key MUST be trusted in the GPG trustdb.",
            "type": "string"
          },
          "version": {
            "description": "What version of the repository to check out. This can be the the literal string `HEAD', a branch name, a tag name. It can also be a `SHA-1' hash, in which case `refspec' needs to be specified if the given revision is not already available.",
            "type": "string"
          }
        },
        "required": [
          "dest",
          "repo"
        ]
      }
    },
    {
      "git_config": {
        "type": "object",
        "description": "Read and write git configuration",
        "properties": {
          "list_all": {
            "description": "List all settings (optionally limited to a given `scope')",
            "type": "string"
          },
          "name": {
            "description": "The name of the setting. If no value is supplied, the value will be read from the config if it has been set.",
            "type": "string"
          },
          "repo": {
            "description": "Path to a git repository for reading and writing values from a specific repo.",
            "type": "string"
          },
          "scope": {
            "description": "Specify which scope to read/set values from. This is required when setting config values. If this is set to local, you must also specify the repo parameter. It defaults to system only when not using `list_all'=yes.",
            "type": "string"
          },
          "value": {
            "description": "When specifying the name of a single setting, supply a value to set that setting to the given value.",
            "type": "string"
          }
        }
      }
    },
    {
      "github_hooks": {
        "type": "object",
        "description": "Manages github service hooks.",
        "properties": {
          "action": {
            "description": "This tells the githooks module what you want it to do.",
            "type": "string"
          },
          "content_type": {
            "description": "Content type to use for requests made to the webhook",
            "type": "string"
          },
          "hookurl": {
            "description": "When creating a new hook, this is the url that you want github to post to. It is only required when creating a new hook.",
            "type": "string"
          },
          "oauthkey": {
            "description": "The oauth key provided by github. It can be found/generated on github under \"Edit Your Profile\" >> \"Applications\" >> \"Personal Access Tokens\"",
            "type": "string"
          },
          "repo": {
            "description": "This is the API url for the repository you want to manage hooks for. It should be in the form of: h ttps://api.github .com/repos/user:/ repo:. Note this is different than the normal repo url.",
            "type": "string"
          },
          "user": {
            "description": "Github username.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates for the target repo will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": [
          "action",
          "oauthkey",
          "repo",
          "user"
        ]
      }
    },
    {
      "github_key": {
        "type": "object",
        "description": "Manage GitHub access keys.",
        "properties": {
          "force": {
            "description": "The default is `yes', which will replace the existing remote key if it's different than `pubkey'. If `no', the key will only be set if no key with the given `name' exists.",
            "type": "string"
          },
          "name": {
            "description": "SSH key name",
            "type": "string"
          },
          "pubkey": {
            "description": "SSH public key value. Required when `state=present'.",
            "type": "string"
          },
          "state": {
            "description": "Whether to remove a key, ensure that it exists, or update its value.",
            "type": "string"
          },
          "token": {
            "description": "GitHub Access Token with permission to list and create public keys.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "token"
        ]
      }
    },
    {
      "github_release": {
        "type": "object",
        "description": "Interact with GitHub Releases",
        "properties": {
          "action": {
            "description": "Action to perform",
            "type": "string"
          },
          "repo": {
            "description": "Repository name",
            "type": "string"
          },
          "token": {
            "description": "Github Personal Access Token for authenticating",
            "type": "string"
          },
          "user": {
            "description": "The GitHub account that owns the repository",
            "type": "string"
          }
        },
        "required": [
          "action",
          "repo",
          "token",
          "user"
        ]
      }
    },
    {
      "gitlab_group": {
        "type": "object",
        "description": "Creates/updates/deletes Gitlab Groups",
        "properties": {
          "login_password": {
            "description": "Gitlab password for login_user",
            "type": "string"
          },
          "login_token": {
            "description": "Gitlab token for logging in.",
            "type": "string"
          },
          "login_user": {
            "description": "Gitlab user name.",
            "type": "string"
          },
          "name": {
            "description": "Name of the group you want to create.",
            "type": "string"
          },
          "path": {
            "description": "The path of the group you want to create, this will be server_ur l/group_path If not supplied, the group_name will be used.",
            "type": "string"
          },
          "server_url": {
            "description": "Url of Gitlab server, with protocol (http or https).",
            "type": "string"
          },
          "state": {
            "description": "create or delete group. Possible values are present and absent.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When using https if SSL certificate needs to be verified.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "server_url"
        ]
      }
    },
    {
      "gitlab_project": {
        "type": "object",
        "description": "Creates/updates/deletes Gitlab Projects",
        "properties": {
          "description": {
            "description": "An description for the project.",
            "type": "string"
          },
          "group": {
            "description": "The name of the group of which this projects belongs to. When not provided, project will belong to user which is configured in 'login_user' or 'login_token' When provided with username, project will be created for this user. 'login_user' or 'login_token' needs admin rights.",
            "type": "string"
          },
          "import_url": {
            "description": "Git repository which will me imported into gitlab. Gitlab server needs read access to this git repository.",
            "type": "string"
          },
          "issues_enabled": {
            "description": "Whether you want to create issues or not. Possible values are true and false.",
            "type": "string"
          },
          "login_password": {
            "description": "Gitlab password for login_user",
            "type": "string"
          },
          "login_token": {
            "description": "Gitlab token for logging in.",
            "type": "string"
          },
          "login_user": {
            "description": "Gitlab user name.",
            "type": "string"
          },
          "merge_requests_enabled": {
            "description": "If merge requests can be made or not. Possible values are true and false.",
            "type": "string"
          },
          "name": {
            "description": "The name of the project",
            "type": "string"
          },
          "path": {
            "description": "The path of the project you want to create, this will be server_ur l/<group>/path If not supplied, name will be used.",
            "type": "string"
          },
          "public": {
            "description": "If the project is public available or not. Setting this to true is same as setting visibility_level to 20. Possible values are true and false.",
            "type": "string"
          },
          "server_url": {
            "description": "Url of Gitlab server, with protocol (http or https).",
            "type": "string"
          },
          "snippets_enabled": {
            "description": "If creating snippets should be available or not. Possible values are true and false.",
            "type": "string"
          },
          "state": {
            "description": "create or delete project. Possible values are present and absent.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When using https if SSL certificate needs to be verified.",
            "type": "string"
          },
          "visibility_level": {
            "description": "Private. visibility_level is 0. Project access must be granted explicitly for each user. Internal. visibility_level is 10. The project can be cloned by any logged in user. Public. visibility_level is 20. The project can be cloned without any authentication. Possible values are 0, 10 and 20.",
            "type": "string"
          },
          "wiki_enabled": {
            "description": "If an wiki for this project should be available or not. Possible values are true and false.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "server_url"
        ]
      }
    },
    {
      "gitlab_user": {
        "type": "object",
        "description": "Creates/updates/deletes Gitlab Users",
        "properties": {
          "access_level": {
            "description": "The access level to the group. One of the following can be used. guest reporter developer master owner",
            "type": "string"
          },
          "email": {
            "description": "The email that belongs to the user.",
            "type": "string"
          },
          "group": {
            "description": "Add user as an member to this group.",
            "type": "string"
          },
          "login_password": {
            "description": "Gitlab password for login_user",
            "type": "string"
          },
          "login_token": {
            "description": "Gitlab token for logging in.",
            "type": "string"
          },
          "login_user": {
            "description": "Gitlab user name.",
            "type": "string"
          },
          "name": {
            "description": "Name of the user you want to create",
            "type": "string"
          },
          "password": {
            "description": "The password of the user.",
            "type": "string"
          },
          "server_url": {
            "description": "Url of Gitlab server, with protocol (http or https).",
            "type": "string"
          },
          "sshkey_file": {
            "description": "The ssh key itself.",
            "type": "string"
          },
          "sshkey_name": {
            "description": "The name of the sshkey",
            "type": "string"
          },
          "state": {
            "description": "create or delete group. Possible values are present and absent.",
            "type": "string"
          },
          "username": {
            "description": "The username of the user.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When using https if SSL certificate needs to be verified.",
            "type": "string"
          }
        },
        "required": [
          "email",
          "name",
          "password",
          "server_url",
          "username"
        ]
      }
    },
    {
      "gluster_volume": {
        "type": "object",
        "description": "Manage GlusterFS volumes",
        "properties": {
          "bricks": {
            "description": "Brick paths on servers. Multiple brick paths can be separated by commas",
            "type": "string"
          },
          "cluster": {
            "description": "List of hosts to use for probing and brick setup",
            "type": "string"
          },
          "directory": {
            "description": "Directory for limit-usage",
            "type": "string"
          },
          "disperses": {
            "description": "Disperse count for volume",
            "type": "string"
          },
          "force": {
            "description": "If brick is being created in the root partition, module will fail. Set force to true to override this behaviour",
            "type": "string"
          },
          "host": {
            "description": "Override local hostname (for peer probing purposes)",
            "type": "string"
          },
          "name": {
            "description": "The volume name",
            "type": "string"
          },
          "options": {
            "description": "A dictionary/hash with options/settings for the volume",
            "type": "string"
          },
          "quota": {
            "description": "Quota value for limit-usage (be sure to use 10.0MB instead of 10MB, see quota list)",
            "type": "string"
          },
          "rebalance": {
            "description": "Controls whether the cluster is rebalanced after changes",
            "type": "string"
          },
          "redundancies": {
            "description": "Redundancy count for volume",
            "type": "string"
          },
          "replicas": {
            "description": "Replica count for volume",
            "type": "string"
          },
          "start_on_create": {
            "description": "Controls whether the volume is started after creation or not, defaults to yes",
            "type": "string"
          },
          "state": {
            "description": "Use present/absent ensure if a volume exists or not, use started/stopped to control it's availability.",
            "type": "string"
          },
          "stripes": {
            "description": "Stripe count for volume",
            "type": "string"
          },
          "transport": {
            "description": "Transport type for volume",
            "type": "string"
          }
        },
        "required": [
          "name",
          "state"
        ]
      }
    },
    {
      "group": {
        "type": "object",
        "description": "Add or remove groups",
        "properties": {
          "gid": {
            "description": "Optional `GID' to set for the group.",
            "type": "string"
          },
          "name": {
            "description": "Name of the group to manage.",
            "type": "string"
          },
          "state": {
            "description": "Whether the group should be present or not on the remote host.",
            "type": "string"
          },
          "system": {
            "description": "If `yes', indicates that the group created is a system group.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "group_by": {
        "type": "object",
        "description": "Create Ansible groups based on facts",
        "properties": {
          "key": {
            "description": "The variables whose values will be used as groups",
            "type": "string"
          }
        },
        "required": "key"
      }
    },
    {
      "grove": {
        "type": "object",
        "description": "Sends a notification to a grove.io channel",
        "properties": {
          "channel_token": {
            "description": "Token of the channel to post to.",
            "type": "string"
          },
          "icon_url": {
            "description": "Icon for the service",
            "type": "string"
          },
          "message": {
            "description": "Message content",
            "type": "string"
          },
          "service": {
            "description": "Name of the service (displayed as the \"user\" in the message)",
            "type": "string"
          },
          "url": {
            "description": "Service URL for the web client",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": [
          "channel_token",
          "message"
        ]
      }
    },
    {
      "hall": {
        "type": "object",
        "description": "Send notification to Hall",
        "properties": {
          "msg": {
            "description": "The message you wish to deliver as a notifcation",
            "type": "string"
          },
          "picture": {
            "description": "The full URL to the image you wish to use for the Icon of the message. Defaults to http://cdn2.hu bspot.net/hub/330 046/file-76907821 0-png/Official_Lo gos/ansible_logo_ black_square_smal l.png?t=142107612 8627",
            "type": "string"
          },
          "room_token": {
            "description": "Room token provided to you by setting up the Ansible room integation on https://hall.com",
            "type": "string"
          },
          "title": {
            "description": "The title of the message",
            "type": "string"
          }
        },
        "required": [
          "msg",
          "room_token",
          "title"
        ]
      }
    },
    {
      "haproxy": {
        "type": "object",
        "description": "Enable, disable, and set weights for HAProxy backend servers using socket commands.",
        "properties": {
          "backend": {
            "description": "Name of the HAProxy backend pool.",
            "type": "string"
          },
          "fail_on_not_found": {
            "description": "Fail whenever trying to enable/disable a backend host that does not exist",
            "type": "string"
          },
          "host": {
            "description": "Name of the backend host to change.",
            "type": "string"
          },
          "shutdown_sessions": {
            "description": "When disabling a server, immediately terminate all the sessions attached to the specified server. This can be used to terminate long-running sessions after a server is put into maintenance mode.",
            "type": "string"
          },
          "socket": {
            "description": "Path to the HAProxy socket file.",
            "type": "string"
          },
          "state": {
            "description": "Desired state of the provided backend host.",
            "type": "string"
          },
          "wait": {
            "description": "Wait until the server reports a status of 'UP' when `state=enabled`, or status of 'MAINT' when `state=disabled`.",
            "type": "string"
          },
          "wait_interval": {
            "description": "Number of seconds to wait between retries.",
            "type": "string"
          },
          "wait_retries": {
            "description": "Number of times to check for status after changing the state.",
            "type": "string"
          },
          "weight": {
            "description": "The value passed in argument. If the value ends with the `%` sign, then the new weight will be relative to the initially configured weight. Relative weights are only permitted between 0 and 100% and absolute weights are permitted between 0 and 256.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "state"
        ]
      }
    },
    {
      "hg": {
        "type": "object",
        "description": "Manages Mercurial (hg) repositories.",
        "properties": {
          "clone": {
            "description": "If `no', do not clone the repository if it does not exist locally.",
            "type": "string"
          },
          "dest": {
            "description": "Absolute path of where the repository should be cloned to. This parameter is required, unless clone and update are set to no",
            "type": "string"
          },
          "executable": {
            "description": "Path to hg executable to use. If not supplied, the normal mechanism for resolving binary paths will be used.",
            "type": "string"
          },
          "force": {
            "description": "Discards uncommitted changes. Runs `hg update -C'.  Prior to 1.9, the default was `yes`.",
            "type": "string"
          },
          "purge": {
            "description": "Deletes untracked files. Runs `hg purge'.",
            "type": "string"
          },
          "repo": {
            "description": "The repository address.",
            "type": "string"
          },
          "revision": {
            "description": "Equivalent `-r' option in hg command which could be the changeset, revision number, branch name or even tag.",
            "type": "string"
          },
          "update": {
            "description": "If `no', do not retrieve new revisions from the origin repository",
            "type": "string"
          }
        },
        "required": [
          "dest",
          "repo"
        ]
      }
    },
    {
      "hipchat": {
        "type": "object",
        "description": "Send a message to hipchat.",
        "properties": {
          "api": {
            "description": "API url if using a self-hosted hipchat server. For hipchat api version 2 use `/v2' path in URI",
            "type": "string"
          },
          "color": {
            "description": "Background color for the message. Default is yellow.",
            "type": "string"
          },
          "from": {
            "description": "Name the message will appear be sent from. max 15 characters. Over 15, will be shorten.",
            "type": "string"
          },
          "msg": {
            "description": "The message body.",
            "type": "string"
          },
          "msg_format": {
            "description": "message format. html or text. Default is text.",
            "type": "string"
          },
          "notify": {
            "description": "notify or not (change the tab color, play a sound, etc)",
            "type": "string"
          },
          "room": {
            "description": "ID or name of the room.",
            "type": "string"
          },
          "token": {
            "description": "API token.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": [
          "msg",
          "room",
          "token"
        ]
      }
    },
    {
      "homebrew": {
        "type": "object",
        "description": "Package manager for Homebrew",
        "properties": {
          "install_options": {
            "description": "options flags to install a package",
            "type": "string"
          },
          "name": {
            "description": "name of package to install/remove",
            "type": "string"
          },
          "path": {
            "description": "':' separated list of paths to search for 'brew' executable. Since A package (`formula' in homebrew parlance) location is prefixed relative to the actual path of `brew' command, providing an alternative `brew' path enables managing different set of packages in an alternative location in the system.",
            "type": "string"
          },
          "state": {
            "description": "state of the package",
            "type": "string"
          },
          "update_homebrew": {
            "description": "update homebrew itself first",
            "type": "string"
          },
          "upgrade_all": {
            "description": "upgrade all homebrew packages",
            "type": "string"
          }
        }
      }
    },
    {
      "homebrew_cask": {
        "type": "object",
        "description": "Install/uninstall homebrew casks.",
        "properties": {
          "install_options": {
            "description": "options flags to install a package",
            "type": "string"
          },
          "name": {
            "description": "name of cask to install/remove",
            "type": "string"
          },
          "path": {
            "description": "':' separated list of paths to search for 'brew' executable.",
            "type": "string"
          },
          "state": {
            "description": "state of the cask",
            "type": "string"
          },
          "update_homebrew": {
            "description": "update homebrew itself first. Note that `brew cask update' is a synonym for `brew update'.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "homebrew_tap": {
        "type": "object",
        "description": "Tap a Homebrew repository.",
        "properties": {
          "name": {
            "description": "The GitHub user/organization repository to tap.",
            "type": "string"
          },
          "state": {
            "description": "state of the repository.",
            "type": "string"
          },
          "url": {
            "description": "The optional git URL of the repository to tap. The URL is not assumed to be on GitHub, and the protocol doesn't have to be HTTP. Any location and protocol that git can handle is fine.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "honeybadger_deployment": {
        "type": "object",
        "description": "Notify Honeybadger.io about app deployments",
        "properties": {
          "environment": {
            "description": "The environment name, typically 'production', 'staging', etc.",
            "type": "string"
          },
          "repo": {
            "description": "URL of the project repository",
            "type": "string"
          },
          "revision": {
            "description": "A hash, number, tag, or other identifier showing what revision was deployed",
            "type": "string"
          },
          "token": {
            "description": "API token.",
            "type": "string"
          },
          "url": {
            "description": "Optional URL to submit the notification to.",
            "type": "string"
          },
          "user": {
            "description": "The username of the person doing the deployment",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates for the target url will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": [
          "environment",
          "token"
        ]
      }
    },
    {
      "hostname": {
        "type": "object",
        "description": "Manage hostname",
        "properties": {
          "name": {
            "description": "Name of the host",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "htpasswd": {
        "type": "object",
        "description": "manage user files for basic authentication",
        "properties": {
          "create": {
            "description": "Used with `state=present'. If specified, the file will be created if it does not already exist. If set to \"no\", will fail if the file does not exist",
            "type": "string"
          },
          "crypt_scheme": {
            "description": "Encryption scheme to be used.  As well as the four choices listed here, you can also use any other hash supported by passlib, such as md5_crypt and sha256_crypt, which are linux passwd hashes. If you do so the password file will not be compatible with Apache or Nginx",
            "type": "string"
          },
          "name": {
            "description": "User name to add or remove",
            "type": "string"
          },
          "password": {
            "description": "Password associated with user. Must be specified if user does not exist yet.",
            "type": "string"
          },
          "path": {
            "description": "Path to the file that contains the usernames and passwords",
            "type": "string"
          },
          "state": {
            "description": "Whether the user entry should be present or not",
            "type": "string"
          }
        },
        "required": [
          "name",
          "path"
        ]
      }
    },
    {
      "iam": {
        "type": "object",
        "description": "Manage IAM users, groups, roles and keys",
        "properties": {
          "access_key_ids": {
            "description": "A list of the keys that you want impacted by the access_key_state parameter.",
            "type": "string"
          },
          "access_key_state": {
            "description": "When type is user, it creates, removes, deactivates or activates a user's access key(s). Note that actions apply only to keys specified.",
            "type": "string"
          },
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "groups": {
            "description": "A list of groups the user should belong to. When update, will gracefully remove groups not listed.",
            "type": "string"
          },
          "iam_type": {
            "description": "Type of IAM resource",
            "type": "string"
          },
          "key_count": {
            "description": "When access_key_state is create it will ensure this quantity of keys are present. Defaults to 1.",
            "type": "string"
          },
          "name": {
            "description": "Name of IAM resource to create or identify",
            "type": "string"
          },
          "new_name": {
            "description": "When state is update, will replace name with new_name on IAM resource",
            "type": "string"
          },
          "new_path": {
            "description": "When state is update, will replace the path with new_path on the IAM resource",
            "type": "string"
          },
          "password": {
            "description": "When type is user and state is present, define the users login password. Also works with update. Note that always returns changed.",
            "type": "string"
          },
          "path": {
            "description": "When creating or updating, specify the desired path of the resource. If state is present, it will replace the current path to match what is passed in when they do not match.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "Whether to create, delete or update the IAM resource. Note, roles cannot be updated.",
            "type": "string"
          },
          "trust_policy": {
            "description": "The inline (JSON or YAML) trust policy document that grants an entity permission to assume the role. Mutually exclusive with `t rust_policy_filep ath'.",
            "type": "string"
          },
          "trust_policy_filepath": {
            "description": "The path to the trust policy document that grants an entity permission to assume the role. Mutually exclusive with `trust_policy'.",
            "type": "string"
          },
          "update_password": {
            "description": "`always' will update passwords if they differ. `on_create' will only set the password for newly created users.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        },
        "required": [
          "iam_type",
          "name",
          "state"
        ]
      }
    },
    {
      "iam_cert": {
        "type": "object",
        "description": "Manage server certificates for use on ELBs and CloudFront",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "cert": {
            "description": "The path to the certificate body in PEM encoded format.",
            "type": "string"
          },
          "cert_chain": {
            "description": "The path to the CA certificate chain in PEM encoded format.",
            "type": "string"
          },
          "dup_ok": {
            "description": "By default the module will not upload a certificate that is already uploaded into AWS. If set to True, it will upload the certificate as long as the name is unique.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "key": {
            "description": "The path to the private key of the certificate in PEM encoded format.",
            "type": "string"
          },
          "name": {
            "description": "Name of certificate to add, update or remove.",
            "type": "string"
          },
          "new_name": {
            "description": "When present, this will update the name of the cert with the value passed here.",
            "type": "string"
          },
          "new_path": {
            "description": "When present, this will update the path of the cert with the value passed here.",
            "type": "string"
          },
          "path": {
            "description": "When creating or updating, specify the desired path of the certificate",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "Whether to create, delete certificate. When present is specified it will attempt to make an update if new_path or new_name is specified.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "state"
        ]
      }
    },
    {
      "iam_mfa_device_facts": {
        "type": "object",
        "description": "List the MFA (Multi-Factor Authentication) devices registered for a user",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "user_name": {
            "description": "The name of the user whose MFA devices will be listed",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        }
      }
    },
    {
      "iam_policy": {
        "type": "object",
        "description": "Manage IAM policies for users, groups, and roles",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "iam_name": {
            "description": "Name of IAM resource you wish to target for policy actions. In other words, the user name, group name or role name.",
            "type": "string"
          },
          "iam_type": {
            "description": "Type of IAM resource",
            "type": "string"
          },
          "policy_document": {
            "description": "The path to the properly json formatted policy file (mutually exclusive with `policy_json')",
            "type": "string"
          },
          "policy_json": {
            "description": "A properly json formatted policy as string (mutually exclusive with `p olicy_document', see https://githu b.com/ansible/ans ible/issues/7005# issuecomment-4289 4813 on how to use it properly)",
            "type": "string"
          },
          "policy_name": {
            "description": "The name label for the policy to create or remove.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "skip_duplicates": {
            "description": "By default the module looks for any policies that match the document you pass in, if there is a match it will not make a new policy object with the same rules. You can override this by specifying false which would allow for two policy objects with different names but same rules.",
            "type": "string"
          },
          "state": {
            "description": "Whether to create or delete the IAM policy.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        },
        "required": [
          "iam_name",
          "iam_type",
          "policy_name",
          "state"
        ]
      }
    },
    {
      "iam_server_certificate_facts": {
        "type": "object",
        "description": "Retrieve the facts of a server certificate",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "name": {
            "description": "The name of the server certificate you are retrieving attributes for.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "include": {
        "type": "object",
        "description": "include a play or task list.",
        "properties": {
          "free-form": {
            "description": "This module allows you to specify the name of the file directly w/o any other options.",
            "type": "string"
          }
        }
      }
    },
    {
      "include_role": {
        "type": "object",
        "description": "Load and execute a role",
        "properties": {
          "allow_duplicates": {
            "description": "Overrides the role's metadata setting to allow using a role more than once with the same parameters.",
            "type": "string"
          },
          "defaults_from": {
            "description": "File to load from a Role's defaults/ directory.",
            "type": "string"
          },
          "name": {
            "description": "The name of the role to be executed.",
            "type": "string"
          },
          "private": {
            "description": "If True the variables from defaults/ and vars/ in a role will not be made available to the rest of the play.",
            "type": "string"
          },
          "tasks_from": {
            "description": "File to load from a Role's tasks/ directory.",
            "type": "string"
          },
          "vars_from": {
            "description": "File to load from a Role's vars/ directory.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "include_vars": {
        "type": "object",
        "description": "Load variables from files, dynamically within a task.",
        "properties": {
          "depth": {
            "description": "By default, this module will recursively go through each sub directory and load up the variables. By explicitly setting the depth, this module will only go as deep as the depth.",
            "type": "string"
          },
          "dir": {
            "description": "The directory name from which the variables should be loaded. If the path is relative, it will look for the file in vars/ subdirectory of a role or relative to playbook.",
            "type": "string"
          },
          "file": {
            "description": "The file name from which variables should be loaded. If the path is relative, it will look for the file in vars/ subdirectory of a role or relative to playbook.",
            "type": "string"
          },
          "files_matching": {
            "description": "Limit the variables that are loaded within any directory to this regular expression.",
            "type": "string"
          },
          "free-form": {
            "description": "This module allows you to specify the 'file' option directly w/o any other options.",
            "type": "string"
          },
          "ignore_files": {
            "description": "List of file names to ignore. The defaults can not be overridden, but can be extended.",
            "type": "string"
          },
          "name": {
            "description": "The name of a variable into which assign the included vars, if omitted (null) they will be made top level vars.",
            "type": "string"
          }
        }
      }
    },
    {
      "influxdb_database": {
        "type": "object",
        "description": "Manage InfluxDB databases",
        "properties": {
          "database_name": {
            "description": "Name of the database that will be created/destroyed",
            "type": "string"
          },
          "hostname": {
            "description": "The hostname or IP address on which InfluxDB server is listening",
            "type": "string"
          },
          "password": {
            "description": "Password that will be used to authenticate against InfluxDB server",
            "type": "string"
          },
          "port": {
            "description": "The port on which InfluxDB server is listening",
            "type": "string"
          },
          "state": {
            "description": "Determines if the database should be created or destroyed",
            "type": "string"
          },
          "username": {
            "description": "Username that will be used to authenticate against InfluxDB server",
            "type": "string"
          }
        },
        "required": [
          "database_name",
          "hostname"
        ]
      }
    },
    {
      "influxdb_retention_policy": {
        "type": "object",
        "description": "Manage InfluxDB retention policies",
        "properties": {
          "database_name": {
            "description": "Name of the database where retention policy will be created",
            "type": "string"
          },
          "default": {
            "description": "Sets the retention policy as default retention policy",
            "type": "string"
          },
          "duration": {
            "description": "Determines how long InfluxDB should keep the data",
            "type": "string"
          },
          "hostname": {
            "description": "The hostname or IP address on which InfluxDB server is listening",
            "type": "string"
          },
          "password": {
            "description": "Password that will be used to authenticate against InfluxDB server",
            "type": "string"
          },
          "policy_name": {
            "description": "Name of the retention policy",
            "type": "string"
          },
          "port": {
            "description": "The port on which InfluxDB server is listening",
            "type": "string"
          },
          "replication": {
            "description": "Determines how many independent copies of each point are stored in the cluster",
            "type": "string"
          },
          "username": {
            "description": "Username that will be used to authenticate against InfluxDB server",
            "type": "string"
          }
        },
        "required": [
          "database_name",
          "default",
          "duration",
          "hostname",
          "policy_name",
          "replication"
        ]
      }
    },
    {
      "ini_file": {
        "type": "object",
        "description": "Tweak settings in INI files",
        "properties": {
          "backup": {
            "description": "Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.",
            "type": "string"
          },
          "create": {
            "description": "If set to 'no', the module will fail if the file does not already exist. By default it will create the file if it is missing.",
            "type": "string"
          },
          "dest": {
            "description": "Path to the INI-style file; this file is created if required",
            "type": "string"
          },
          "group": {
            "description": "name of the group that should own the file/directory, as would be fed to `chown'",
            "type": "string"
          },
          "mode": {
            "description": "mode the file or directory should be. For those used to `/usr/bin/chmod' remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, `u+rwx' or `u=rw,g=r,o=r').",
            "type": "string"
          },
          "no_extra_spaces": {
            "description": "do not insert spaces before and after '=' symbol",
            "type": "string"
          },
          "option": {
            "description": "if set (required for changing a `value'), this is the name of the option. May be omitted if adding/removing a whole `section'.",
            "type": "string"
          },
          "others": {
            "description": "all arguments accepted by the [file] module also work here",
            "type": "string"
          },
          "owner": {
            "description": "name of the user that should own the file/directory, as would be fed to `chown'",
            "type": "string"
          },
          "section": {
            "description": "Section name in INI file. This is added if `state=present' automatically when a single value is being set.",
            "type": "string"
          },
          "selevel": {
            "description": "level part of the SELinux file context. This is the MLS/MCS attribute, sometimes known as the `range'. `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "serole": {
            "description": "role part of SELinux file context, `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "setype": {
            "description": "type part of SELinux file context, `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "seuser": {
            "description": "user part of SELinux file context. Will default to system policy, if applicable. If set to `_default', it will use the `user' portion of the policy if available",
            "type": "string"
          },
          "state": {
            "description": "If set to `absent' the option or section will be removed if present instead of created.",
            "type": "string"
          },
          "unsafe_writes": {
            "description": "Normally this module uses atomic operations to prevent data corruption or inconsistent reads from the target files, sometimes systems are configured or just broken in ways that prevent this. One example are docker mounted files, they cannot be updated atomically and can only be done in an unsafe manner. This boolean option allows ansible to fall back to unsafe methods of updating files for those cases in which you do not have any other choice. Be aware that this is subject to race conditions and can lead to data corruption.",
            "type": "string"
          },
          "value": {
            "description": "the string value to be associated with an `option'. May be omitted when removing an `option'.",
            "type": "string"
          }
        },
        "required": [
          "dest",
          "section"
        ]
      }
    },
    {
      "ios_command": {
        "type": "object",
        "description": "Run commands on remote devices running Cisco IOS",
        "properties": {
          "auth_pass": {
            "description": "Specifies the password to use if required to enter privileged mode on the remote device. If `authorize' is false, then this argument does nothing. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_AUTH_PASS will be used instead.",
            "type": "string"
          },
          "authorize": {
            "description": "Instructs the module to enter privileged mode on the remote device before sending any commands.  If not specified, the device will attempt to execute all commands in non- privileged mode. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_AUTHORIZE will be used instead.",
            "type": "string"
          },
          "commands": {
            "description": "List of commands to send to the remote ios device over the configured provider. The resulting output from the command is returned. If the `wait_for' argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "interval": {
            "description": "Configures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.",
            "type": "string"
          },
          "match": {
            "description": "The `match' argument is used in conjunction with the `wait_for' argument to specify the match policy.  Valid values are `all' or `any'.  If the value is set to `all' then all conditionals in the wait_for must be satisfied.  If the value is set to `any' then only one of the values must be satisfied.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.   The value of `password' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_PASSWORD will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when buiding the connection to the remote. device.",
            "type": "string"
          },
          "provider": {
            "description": "Convience method that allows all [ios] arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "retries": {
            "description": "Specifies the number of retries a command should by tried before it is considered failed. The command is run on the target device every retry and evaluated against the `wait_for' conditions.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. The value of `ssh_keyfile' is the path to the key used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_SSH_KEYFILE will be used instead.",
            "type": "string"
          },
          "timeout": {
            "description": "Specifies idle timeout for the connection. Useful if the console freezes before continuing. For example when saving configurations.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_USERNAME will be used instead.",
            "type": "string"
          },
          "wait_for": {
            "description": "List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.",
            "type": "string"
          }
        },
        "required": [
          "commands",
          "host"
        ]
      }
    },
    {
      "ios_config": {
        "type": "object",
        "description": "Manage Cisco IOS configuration sections",
        "properties": {
          "after": {
            "description": "The ordered set of commands to append to the end of the command stack if a change needs to be made. Just like with `before' this allows the playbook designer to append a set of commands to be executed after the command set.",
            "type": "string"
          },
          "auth_pass": {
            "description": "Specifies the password to use if required to enter privileged mode on the remote device. If `authorize' is false, then this argument does nothing. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_AUTH_PASS will be used instead.",
            "type": "string"
          },
          "authorize": {
            "description": "Instructs the module to enter privileged mode on the remote device before sending any commands.  If not specified, the device will attempt to execute all commands in non- privileged mode. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_AUTHORIZE will be used instead.",
            "type": "string"
          },
          "backup": {
            "description": "This argument will cause the module to create a full backup of the current `running-config' from the remote device before any changes are made. The backup file is written to the `backup' folder in the playbook root directory. If the directory does not exist, it is created.",
            "type": "string"
          },
          "before": {
            "description": "The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.",
            "type": "string"
          },
          "config": {
            "description": "The `config' argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node.",
            "type": "string"
          },
          "defaults": {
            "description": "This argument specifies whether or not to collect all defaults when getting the remote device running config. When enabled, the module will get the current config by issuing the command `show running-config all'.",
            "type": "string"
          },
          "force": {
            "description": "The force argument instructs the module to not consider the current devices running-config. When set to true, this will cause the module to push the contents of `src' into the device without first checking if already configured. Note this argument should be considered deprecated.  To achieve the equivalent, set the `match=none' which is idempotent.  This argument will be removed in a future release.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "lines": {
            "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config. Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.",
            "type": "string"
          },
          "match": {
            "description": "Instructs the module on the way to perform the matching of the set of commands against the current device config.  If match is set to `line', commands are matched line by line.  If match is set to `strict', command lines are matched with respect to position.  If match is set to `exact', command lines must be an equal match. Finally, if match is set to `none', the module will not attempt to compare the source configuration with the running configuration on the remote device.",
            "type": "string"
          },
          "parents": {
            "description": "The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.   The value of `password' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_PASSWORD will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when buiding the connection to the remote. device.",
            "type": "string"
          },
          "provider": {
            "description": "Convience method that allows all [ios] arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "replace": {
            "description": "Instructs the module on the way to perform the configuration on the device.  If the replace argument is set to `line' then the modified lines are pushed to the device in configuration mode.  If the replace argument is set to `block' then the entire command block is pushed to the device in configuration mode if any line is not correct.",
            "type": "string"
          },
          "save": {
            "description": "The `save' argument instructs the module to save the running- config to the startup-config at the conclusion of the module running.  If check mode is specified, this argument is ignored.",
            "type": "string"
          },
          "src": {
            "description": "Specifies the source path to the file that contains the configuration or configuration template to load. The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with `lines'.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. The value of `ssh_keyfile' is the path to the key used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_SSH_KEYFILE will be used instead.",
            "type": "string"
          },
          "timeout": {
            "description": "Specifies idle timeout for the connection. Useful if the console freezes before continuing. For example when saving configurations.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_USERNAME will be used instead.",
            "type": "string"
          }
        },
        "required": "host"
      }
    },
    {
      "ios_facts": {
        "type": "object",
        "description": "Collect facts from remote devices running IOS",
        "properties": {
          "auth_pass": {
            "description": "Specifies the password to use if required to enter privileged mode on the remote device. If `authorize' is false, then this argument does nothing. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_AUTH_PASS will be used instead.",
            "type": "string"
          },
          "authorize": {
            "description": "Instructs the module to enter privileged mode on the remote device before sending any commands.  If not specified, the device will attempt to execute all commands in non- privileged mode. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_AUTHORIZE will be used instead.",
            "type": "string"
          },
          "gather_subset": {
            "description": "When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  Can specify a list of values to include a larger subset. Values can also be used with an initial `[!]' to specify that a specific subset should not be collected.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.   The value of `password' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_PASSWORD will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when buiding the connection to the remote. device.",
            "type": "string"
          },
          "provider": {
            "description": "Convience method that allows all [ios] arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. The value of `ssh_keyfile' is the path to the key used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_SSH_KEYFILE will be used instead.",
            "type": "string"
          },
          "timeout": {
            "description": "Specifies idle timeout for the connection. Useful if the console freezes before continuing. For example when saving configurations.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_USERNAME will be used instead.",
            "type": "string"
          }
        },
        "required": "host"
      }
    },
    {
      "iosxr_command": {
        "type": "object",
        "description": "Run commands on remote devices running Cisco iosxr",
        "properties": {
          "commands": {
            "description": "List of commands to send to the remote iosxr device over the configured provider. The resulting output from the command is returned. If the `wait_for' argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "interval": {
            "description": "Configures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.",
            "type": "string"
          },
          "match": {
            "description": "The `match' argument is used in conjunction with the `wait_for' argument to specify the match policy.  Valid values are `all' or `any'.  If the value is set to `all' then all conditionals in the wait_for must be satisfied.  If the value is set to `any' then only one of the values must be satisfied.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.   The value of `password' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device.",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `iosxr' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "retries": {
            "description": "Specifies the number of retries a command should by tried before it is considered failed. The command is run on the target device every retry and evaluated against the `wait_for' conditions.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. The value of `ssh_keyfile' is the path to the key used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          },
          "wait_for": {
            "description": "List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.",
            "type": "string"
          }
        },
        "required": [
          "commands",
          "host"
        ]
      }
    },
    {
      "iosxr_config": {
        "type": "object",
        "description": "Manage Cisco IOS XR configuration sections",
        "properties": {
          "after": {
            "description": "The ordered set of commands to append to the end of the command stack if a change needs to be made. Just like with `before' this allows the playbook designer to append a set of commands to be executed after the command set.",
            "type": "string"
          },
          "backup": {
            "description": "This argument will cause the module to create a full backup of the current `running-config' from the remote device before any changes are made. The backup file is written to the `backup' folder in the playbook root directory. If the directory does not exist, it is created.",
            "type": "string"
          },
          "before": {
            "description": "The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.",
            "type": "string"
          },
          "comment": {
            "description": "Allows a commit description to be specified to be included when the configuration is committed.  If the configuration is not changed or committed, this argument is ignored.",
            "type": "string"
          },
          "config": {
            "description": "The module, by default, will connect to the remote device and retrieve the current running- config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The `config' argument allows the implementer to pass in the configuration to use as the base config for comparison.",
            "type": "string"
          },
          "force": {
            "description": "The force argument instructs the module to not consider the current devices running-config. When set to true, this will cause the module to push the contents of `src' into the device without first checking if already configured. Note this argument should be considered deprecated.  To achieve the equivalent, set the `match=none' which is idempotent.  This argument will be removed in a future release.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "lines": {
            "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config. Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.",
            "type": "string"
          },
          "match": {
            "description": "Instructs the module on the way to perform the matching of the set of commands against the current device config.  If match is set to `line', commands are matched line by line.  If match is set to `strict', command lines are matched with respect to position.  If match is set to `exact', command lines must be an equal match. Finally, if match is set to `none', the module will not attempt to compare the source configuration with the running configuration on the remote device.",
            "type": "string"
          },
          "parents": {
            "description": "The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.   The value of `password' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device.",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `iosxr' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "replace": {
            "description": "Instructs the module on the way to perform the configuration on the device.  If the replace argument is set to `line' then the modified lines are pushed to the device in configuration mode.  If the replace argument is set to `block' then the entire command block is pushed to the device in configuration mode if any line is not correct.",
            "type": "string"
          },
          "src": {
            "description": "Specifies the source path to the file that contains the configuration or configuration template to load. The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with `lines'.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. The value of `ssh_keyfile' is the path to the key used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": "host"
      }
    },
    {
      "iosxr_facts": {
        "type": "object",
        "description": "Collect facts from remote devices running IOS-XR",
        "properties": {
          "gather_subset": {
            "description": "When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  Can specify a list of values to include a larger subset. Values can also be used with an initial `[!]' to specify that a specific subset should not be collected.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.   The value of `password' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device.",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `iosxr' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. The value of `ssh_keyfile' is the path to the key used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": "host"
      }
    },
    {
      "ipadm_if": {
        "type": "object",
        "description": "Manage IP interfaces  on Solaris/illumos systems.",
        "properties": {
          "name": {
            "description": "IP interface name.",
            "type": "string"
          },
          "state": {
            "description": "Create or delete Solaris/illumos IP interfaces.",
            "type": "string"
          },
          "temporary": {
            "description": "Specifies that the IP interface is temporary. Temporary IP interfaces do not persist across reboots.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "ipadm_prop": {
        "type": "object",
        "description": "Manage protocol properties on Solaris/illumos systems.",
        "properties": {
          "property": {
            "description": "Specifies the name of property we want to manage.",
            "type": "string"
          },
          "protocol": {
            "description": "Specifies the procotol for which we want to manage properties.",
            "type": "string"
          },
          "state": {
            "description": "Set or reset the property value.",
            "type": "string"
          },
          "temporary": {
            "description": "Specifies that the property value is temporary. Temporary property values do not persist across reboots.",
            "type": "string"
          },
          "value": {
            "description": "Specifies the value we want to set for the property.",
            "type": "string"
          }
        },
        "required": [
          "property",
          "protocol"
        ]
      }
    },
    {
      "ipify_facts": {
        "type": "object",
        "description": "Retrieve the public IP of your internet gateway.",
        "properties": {
          "api_url": {
            "description": "URL of the ipify.org API service. `?format=json' will be appended per default.",
            "type": "string"
          }
        }
      }
    },
    {
      "ipmi_boot": {
        "type": "object",
        "description": "Management of order of boot devices",
        "properties": {
          "bootdev": {
            "description": "Set boot device to use on next reboot",
            "type": "string"
          },
          "name": {
            "description": "Hostname or ip address of the BMC.",
            "type": "string"
          },
          "password": {
            "description": "Password to connect to the BMC.",
            "type": "string"
          },
          "persistent": {
            "description": "If set, ask that system firmware uses this device beyond next boot. Be aware many systems do not honor this.",
            "type": "string"
          },
          "port": {
            "description": "Remote RMCP port.",
            "type": "string"
          },
          "state": {
            "description": "Whether to ensure that boot devices is desired.",
            "type": "string"
          },
          "uefiboot": {
            "description": "If set, request UEFI boot explicitly. Strictly speaking, the spec suggests that if not set, the system should BIOS boot and offers no \"don't care\" option. In practice, this flag not being set does not preclude UEFI boot on any system I've encountered.",
            "type": "string"
          },
          "user": {
            "description": "Username to use to connect to the BMC.",
            "type": "string"
          }
        },
        "required": [
          "bootdev",
          "name",
          "password",
          "user"
        ]
      }
    },
    {
      "ipmi_power": {
        "type": "object",
        "description": "Power management for machine",
        "properties": {
          "name": {
            "description": "Hostname or ip address of the BMC.",
            "type": "string"
          },
          "password": {
            "description": "Password to connect to the BMC.",
            "type": "string"
          },
          "port": {
            "description": "Remote RMCP port.",
            "type": "string"
          },
          "state": {
            "description": "Whether to ensure that the machine in desired state.",
            "type": "string"
          },
          "timeout": {
            "description": "Maximum number of seconds before interrupt request.",
            "type": "string"
          },
          "user": {
            "description": "Username to use to connect to the BMC.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "password",
          "state",
          "user"
        ]
      }
    },
    {
      "iptables": {
        "type": "object",
        "description": "Modify the systems iptables",
        "properties": {
          "action": {
            "description": "Whether the rule should be appended at the bottom or inserted at the top. If the rule already exists the chain won't be modified.",
            "type": "string"
          },
          "chain": {
            "description": "Chain to operate on. This option can either be the name of a user defined chain or any of the builtin chains: 'INPUT', 'FORWARD', 'OUTPUT', 'PREROUTING', 'POSTROUTING', 'SECMARK', 'CONNSECMARK'.",
            "type": "string"
          },
          "comment": {
            "description": "This specifies a comment that will be added to the rule",
            "type": "string"
          },
          "ctstate": {
            "description": "ctstate is a list of the connection states to match in the conntrack module. Possible states are: 'INVALID', 'NEW', 'ESTABLISHED', 'RELATED', 'UNTRACKED', 'SNAT', 'DNAT'",
            "type": "string"
          },
          "destination": {
            "description": "Destination specification. Address can be either a network name, a hostname, a network IP address (with /mask), or a plain IP address. Hostnames will be resolved once only, before the rule is submitted to the kernel. Please note that specifying any name to be resolved with a remote query such as DNS is a really bad idea. The mask can be either a network mask or a plain number, specifying the number of 1's at the left side of the network mask. Thus, a mask of 24 is equivalent to 255.255.255.0. A \"!\" argument before the address specification inverts the sense of the address.",
            "type": "string"
          },
          "destination_port": {
            "description": "Destination port or port range specification. This can either be a service name or a port number. An inclusive range can also be specified, using the format first:last. If the first port is omitted, '0' is assumed; if the last is omitted, '65535' is assumed. If the first port is greater than the second one they will be swapped.",
            "type": "string"
          },
          "flush": {
            "description": "Flushes the specified table and chain of all rules. If no chain is specified then the entire table is purged. Ignores all other parameters.",
            "type": "string"
          },
          "fragment": {
            "description": "This means that the rule only refers to second and further fragments of fragmented packets. Since there is no way to tell the source or destination ports of such a packet (or ICMP type), such a packet will not match any rules which specify them. When the \"!\" argument precedes fragment argument, the rule will only match head fragments, or unfragmented packets.",
            "type": "string"
          },
          "goto": {
            "description": "This specifies that the processing should continue in a user specified chain. Unlike the jump argument return will not continue processing in this chain but instead in the chain that called us via jump.",
            "type": "string"
          },
          "icmp_type": {
            "description": "This allows specification of the ICMP type, which can be a numeric ICMP type, type/code pair, or one of the ICMP type names shown by the command 'iptables -p icmp -h'",
            "type": "string"
          },
          "in_interface": {
            "description": "Name of an interface via which a packet was received (only for packets entering the INPUT, FORWARD and PREROUTING chains). When the \"!\" argument is used before the interface name, the sense is inverted. If the interface name ends in a \"+\", then any interface which begins with this name will match. If this option is omitted, any interface name will match.",
            "type": "string"
          },
          "ip_version": {
            "description": "Which version of the IP protocol this rule should apply to.",
            "type": "string"
          },
          "jump": {
            "description": "This specifies the target of the rule; i.e., what to do if the packet matches it. The target can be a user- defined chain (other than the one this rule is in), one of the special builtin targets which decide the fate of the packet immediately, or an extension (see EXTENSIONS below).  If this option is omitted in a rule (and the goto paramater is not used), then matching the rule will have no effect on the packet's fate, but the counters on the rule will be incremented.",
            "type": "string"
          },
          "limit": {
            "description": "Specifies the maximum average number of matches to allow per second. The number can specify units explicitly, using `/second', `/minute', `/hour' or `/day', or parts of them (so `5/second' is the same as `5/s').",
            "type": "string"
          },
          "limit_burst": {
            "description": "Specifies the maximum burst before the above limit kicks in.",
            "type": "string"
          },
          "match": {
            "description": "Specifies a match to use, that is, an extension module that tests for a specific property. The set of matches make up the condition under which a target is invoked. Matches are evaluated first to last if specified as an array and work in short-circuit fashion, i.e. if one extension yields false, evaluation will stop.",
            "type": "string"
          },
          "out_interface": {
            "description": "Name of an interface via which a packet is going to be sent (for packets entering the FORWARD, OUTPUT and POSTROUTING chains). When the \"!\" argument is used before the interface name, the sense is inverted. If the interface name ends in a \"+\", then any interface which begins with this name will match. If this option is omitted, any interface name will match.",
            "type": "string"
          },
          "policy": {
            "description": "Set the policy for the chain to the given target. Valid targets are ACCEPT, DROP, QUEUE, RETURN. Only built in chains can have policies. This parameter requires the chain parameter. Ignores all other parameters.",
            "type": "string"
          },
          "protocol": {
            "description": "The protocol of the rule or of the packet to check. The specified protocol can be one of tcp, udp, udplite, icmp, esp, ah, sctp or the special keyword \"all\", or it can be a numeric value, representing one of these protocols or a different one. A protocol name from /etc/protocols is also allowed. A \"!\" argument before the protocol inverts the test.  The number zero is equivalent to all. \"all\" will match with all protocols and is taken as default when this option is omitted.",
            "type": "string"
          },
          "reject_with": {
            "description": "Specifies the error packet type to return while rejecting.",
            "type": "string"
          },
          "set_counters": {
            "description": "This enables the administrator to initialize the packet and byte counters of a rule (during INSERT, APPEND, REPLACE operations).",
            "type": "string"
          },
          "set_dscp_mark": {
            "description": "This allows specifying a DSCP mark to be added to packets. It takes either an integer or hex value. Mutually exclusive with `s et_dscp_mark_clas s'.",
            "type": "string"
          },
          "set_dscp_mark_class": {
            "description": "This allows specifying a predefined DiffServ class which will be translated to the corresponding DSCP mark. Mutually exclusive with `set_dscp_mark'.",
            "type": "string"
          },
          "source": {
            "description": "Source specification. Address can be either a network name, a hostname, a network IP address (with /mask), or a plain IP address. Hostnames will be resolved once only, before the rule is submitted to the kernel. Please note that specifying any name to be resolved with a remote query such as DNS is a really bad idea. The mask can be either a network mask or a plain number, specifying the number of 1's at the left side of the network mask. Thus, a mask of 24 is equivalent to 255.255.255.0. A \"!\" argument before the address specification inverts the sense of the address.",
            "type": "string"
          },
          "source_port": {
            "description": "Source port or port range specification. This can either be a service name or a port number. An inclusive range can also be specified, using the format first:last. If the first port is omitted, '0' is assumed; if the last is omitted, '65535' is assumed. If the first port is greater than the second one they will be swapped.",
            "type": "string"
          },
          "state": {
            "description": "Whether the rule should be absent or present.",
            "type": "string"
          },
          "table": {
            "description": "This option specifies the packet matching table which the command should operate on. If the kernel is configured with automatic module loading, an attempt will be made to load the appropriate module for that table if it is not already there.",
            "type": "string"
          },
          "to_destination": {
            "description": "This specifies a destination address to use with DNAT: without this, the destination address is never altered.",
            "type": "string"
          },
          "to_ports": {
            "description": "This specifies a destination port or range of ports to use: without this, the destination port is never altered. This is only valid if the rule also specifies one of the following protocols: tcp, udp, dccp or sctp.",
            "type": "string"
          },
          "to_source": {
            "description": "This specifies a source address to use with SNAT: without this, the source address is never altered.",
            "type": "string"
          },
          "uid_owner": {
            "description": "Specifies the UID or username to use in match by owner rule.",
            "type": "string"
          }
        }
      }
    },
    {
      "irc": {
        "type": "object",
        "description": "Send a message to an IRC channel",
        "properties": {
          "channel": {
            "description": "Channel name.  One of nick_to or channel needs to be set.  When both are set, the message will be sent to both of them.",
            "type": "string"
          },
          "color": {
            "description": "Text color for the message. (\"none\" is a valid option in 1.6 or later, in 1.6 and prior, the default color is black, not \"none\"). Added 11 more colors in version 2.0.",
            "type": "string"
          },
          "key": {
            "description": "Channel key",
            "type": "string"
          },
          "msg": {
            "description": "The message body.",
            "type": "string"
          },
          "nick": {
            "description": "Nickname to send the message from. May be shortened, depending on server's NICKLEN setting.",
            "type": "string"
          },
          "nick_to": {
            "description": "A list of nicknames to send the message to. One of nick_to or channel needs to be set.  When both are defined, the message will be sent to both of them.",
            "type": "string"
          },
          "part": {
            "description": "Designates whether user should part from channel after sending message or not. Useful for when using a faux bot and not wanting join/parts between messages.",
            "type": "string"
          },
          "passwd": {
            "description": "Server password",
            "type": "string"
          },
          "port": {
            "description": "IRC server port number",
            "type": "string"
          },
          "server": {
            "description": "IRC server name/address",
            "type": "string"
          },
          "style": {
            "description": "Text style for the message. Note italic does not work on some clients",
            "type": "string"
          },
          "timeout": {
            "description": "Timeout to use while waiting for successful registration and join messages, this is to prevent an endless loop",
            "type": "string"
          },
          "topic": {
            "description": "Set the channel topic",
            "type": "string"
          },
          "use_ssl": {
            "description": "Designates whether TLS/SSL should be used when connecting to the IRC server",
            "type": "string"
          }
        },
        "required": [
          "channel",
          "msg"
        ]
      }
    },
    {
      "jabber": {
        "type": "object",
        "description": "Send a message to jabber user or chat room",
        "properties": {
          "encoding": {
            "description": "message encoding",
            "type": "string"
          },
          "host": {
            "description": "host to connect, overrides user info",
            "type": "string"
          },
          "msg": {
            "description": "The message body.",
            "type": "string"
          },
          "password": {
            "description": "password for user to connect",
            "type": "string"
          },
          "port": {
            "description": "port to connect to, overrides default",
            "type": "string"
          },
          "to": {
            "description": "user ID or name of the room, when using room use a slash to indicate your nick.",
            "type": "string"
          },
          "user": {
            "description": "User as which to connect",
            "type": "string"
          }
        },
        "required": [
          "msg",
          "password",
          "to",
          "user"
        ]
      }
    },
    {
      "jboss": {
        "type": "object",
        "description": "deploy applications to JBoss",
        "properties": {
          "deploy_path": {
            "description": "The location in the filesystem where the deployment scanner listens",
            "type": "string"
          },
          "deployment": {
            "description": "The name of the deployment",
            "type": "string"
          },
          "src": {
            "description": "The remote path of the application ear or war to deploy",
            "type": "string"
          },
          "state": {
            "description": "Whether the application should be deployed or undeployed",
            "type": "string"
          }
        },
        "required": "deployment"
      }
    },
    {
      "jenkins_job": {
        "type": "object",
        "description": "Manage jenkins jobs",
        "properties": {
          "config": {
            "description": "config in XML format. Required if job does not yet exist. Mututally exclusive with `enabled'. Considered if `state=present'.",
            "type": "string"
          },
          "enabled": {
            "description": "Whether the job should be enabled or disabled. Mututally exclusive with `config'. Considered if `state=present'.",
            "type": "string"
          },
          "name": {
            "description": "Name of the Jenkins job.",
            "type": "string"
          },
          "password": {
            "description": "Password to authenticate with the Jenkins server.",
            "type": "string"
          },
          "state": {
            "description": "Attribute that specifies if the job has to be created or deleted.",
            "type": "string"
          },
          "token": {
            "description": "API token used to authenticate alternatively to password.",
            "type": "string"
          },
          "url": {
            "description": "Url where the Jenkins server is accessible.",
            "type": "string"
          },
          "user": {
            "description": "User to authenticate with the Jenkins server.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "jenkins_plugin": {
        "type": "object",
        "description": "Add or remove Jenkins plugin",
        "properties": {
          "group": {
            "description": "Name of the Jenkins group on the OS.",
            "type": "string"
          },
          "jenkins_home": {
            "description": "Home directory of the Jenkins user.",
            "type": "string"
          },
          "mode": {
            "description": "File mode applied on versioned plugins.",
            "type": "string"
          },
          "name": {
            "description": "Plugin name.",
            "type": "string"
          },
          "owner": {
            "description": "Name of the Jenkins user on the OS.",
            "type": "string"
          },
          "params": {
            "description": "Option used to allow the user to overwrite any of the other options. To remove an option, set the value of the option to `null'.",
            "type": "string"
          },
          "state": {
            "description": "Desired plugin state. If the `latest' is set, the check for new version will be performed every time. This is suitable to keep the plugin up-to- date.",
            "type": "string"
          },
          "timeout": {
            "description": "Server connection timeout in secs.",
            "type": "string"
          },
          "updates_expiration": {
            "description": "Number of seconds after which a new copy of the `update- center.json' file is downloaded. This is used to avoid the need to download the plugin to calculate its checksum when `latest' is specified. Set it to `0' if no cache file should be used. In that case, the plugin file will always be downloaded to calculate its checksum when `latest' is specified.",
            "type": "string"
          },
          "updates_url": {
            "description": "URL of the Update Centre. Used as the base URL to download the plugins and the `update- center.json' JSON file.",
            "type": "string"
          },
          "url": {
            "description": "URL of the Jenkins server.",
            "type": "string"
          },
          "version": {
            "description": "Plugin version number. If this option is specified, all plugin dependencies must be installed manually. It might take longer to verify that the correct version is installed. This is especially true if a specific version number is specified.",
            "type": "string"
          },
          "with_dependencies": {
            "description": "Defines whether to install plugin dependencies.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "jira": {
        "type": "object",
        "description": "create and modify issues in a JIRA instance",
        "properties": {
          "assignee": {
            "description": "Sets the assignee on create or transition operations. Note not all transitions will allow this.",
            "type": "string"
          },
          "comment": {
            "description": "The comment text to add.",
            "type": "string"
          },
          "description": {
            "description": "The issue description, where appropriate.",
            "type": "string"
          },
          "fields": {
            "description": "This is a free-form data structure that can contain arbitrary data. This is passed directly to the JIRA REST API (possibly after merging with other required data, as when passed to create). See examples for more information, and the JIRA REST API for the structure required for various fields.",
            "type": "string"
          },
          "issue": {
            "description": "An existing issue key to operate on.",
            "type": "string"
          },
          "issuetype": {
            "description": "The issue type, for issue creation.",
            "type": "string"
          },
          "operation": {
            "description": "The operation to perform.",
            "type": "string"
          },
          "password": {
            "description": "The password to log-in with.",
            "type": "string"
          },
          "project": {
            "description": "The project for this operation. Required for issue creation.",
            "type": "string"
          },
          "status": {
            "description": "The desired status; only relevant for the transition operation.",
            "type": "string"
          },
          "summary": {
            "description": "The issue summary, where appropriate.",
            "type": "string"
          },
          "uri": {
            "description": "Base URI for the JIRA instance",
            "type": "string"
          },
          "username": {
            "description": "The username to log-in with.",
            "type": "string"
          }
        },
        "required": [
          "operation",
          "password",
          "uri",
          "username"
        ]
      }
    },
    {
      "junos_command": {
        "type": "object",
        "description": "Execute arbitrary commands on a remote device running Junos",
        "properties": {
          "commands": {
            "description": "The `commands' to send to the remote device over the Netconf transport.  The resulting output from the command is returned.  If the `wait_for' argument is provided, the module is not returned until the condition is satisfied or the number of `retries' has been exceeded.",
            "type": "string"
          },
          "format": {
            "description": "Configures the encoding scheme to use when serializing output from the device.  This handles how to properly understand the output and apply the conditionals path to the result set.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "interval": {
            "description": "Configures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditional, the interval indicates how to long to wait before trying the command again.",
            "type": "string"
          },
          "match": {
            "description": "The `match' argument is used in conjunction with the `wait_for' argument to specify the match policy.  Valid values are `all' or `any'.  If the value is set to `all' then all conditionals in the `wait_for' must be satisfied.  If the value is set to `any' then only one of the values must be satisfied.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.   The value of `password' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_PASSWORD will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. The port value will default to the well known SSH port of 22 (for `transport=cli') or port 830 (for  `transport=netcon f') device.",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `ios' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "retries": {
            "description": "Specifies the number of retries a command should by tried before it is considered failed.  The command is run on the target device every retry and evaluated against the `waitfor' conditionals.",
            "type": "string"
          },
          "rpcs": {
            "description": "The `rpcs' argument accepts a list of RPCs to be executed over a netconf session and the results from the RPC execution is return to the playbook via the modules results dictionary.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. The value of `ssh_keyfile' is the path to the key used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_SSH_KEYFILE will be used instead.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_USERNAME will be used instead.",
            "type": "string"
          },
          "wait_for": {
            "description": "Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward. If the conditional is not true by the configured retries, the task fails.  See examples.",
            "type": "string"
          }
        },
        "required": "host"
      }
    },
    {
      "junos_config": {
        "type": "object",
        "description": "Manage configuration on devices running Juniper JUNOS",
        "properties": {
          "backup": {
            "description": "This argument will cause the module to create a full backup of the current `running-config' from the remote device before any changes are made. The backup file is written to the `backup' folder in the playbook root directory. If the directory does not exist, it is created.",
            "type": "string"
          },
          "comment": {
            "description": "The `comment' argument specifies a text string to be used when committing the configuration. If the `confirm' argument is set to False, this argument is silently ignored.",
            "type": "string"
          },
          "confirm": {
            "description": "The `confirm' argument will configure a time out value for the commit to be confirmed before it is automatically rolled back.  If the `confirm' argument is set to False, this argument is silently ignored. If the value for this argument is set to 0, the commit is confirmed immediately.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "lines": {
            "description": "This argument takes a list of `set' or `delete' configuration lines to push into the remote device.  Each line must start with either `set' or `delete'. This argument is mutually exclusive with the `src' argument.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.   The value of `password' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_PASSWORD will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. The port value will default to the well known SSH port of 22 (for `transport=cli') or port 830 (for  `transport=netcon f') device.",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `ios' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "replace": {
            "description": "The `replace' argument will instruct the remote device to replace the current configuration hierarchy with the one specified in the corresponding hierarchy of the source configuration loaded from this module. Note this argument should be considered deprecated.  To achieve the equivalent, set the `update' argument to `replace'.  This argument will be removed in a future release.",
            "type": "string"
          },
          "rollback": {
            "description": "The `rollback' argument instructs the module to rollback the current configuration to the identifier specified in the argument.  If the specified rollback identifier does not exist on the remote device, the module will fail.  To rollback to the most recent commit, set the `rollback' argument to 0.",
            "type": "string"
          },
          "src": {
            "description": "The `src' argument provides a path to the configuration file to load into the remote system.  The path can either be a full system path to the configuration file if the value starts with / or relative to the root of the implemented role or playbook. This argument is mutually exclusive with the `lines' argument.",
            "type": "string"
          },
          "src_format": {
            "description": "The `src_format' argument specifies the format of the configuration found int `src'. If the `src_format' argument is not provided, the module will attempt to determine the format of the configuration file specified in `src'.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. The value of `ssh_keyfile' is the path to the key used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_SSH_KEYFILE will be used instead.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_USERNAME will be used instead.",
            "type": "string"
          },
          "zeroize": {
            "description": "The `zeroize' argument is used to completely sanitize the remote device configuration back to initial defaults.  This argument will effectively remove all current configuration statements on the remote device.",
            "type": "string"
          }
        },
        "required": "host"
      }
    },
    {
      "junos_facts": {
        "type": "object",
        "description": "Collect facts from remote device running Junos",
        "properties": {
          "config": {
            "description": "The `config' argument instructs the fact module to collect the configuration from the remote device.  The configuration is then included in return facts.  By default, the configuration is returned as text. The `config_format' can be used to return different Junos configuration formats.",
            "type": "string"
          },
          "config_format": {
            "description": "The `config_format' argument is used to specify the desired format of the configuration file.  Devices support three configuration file formats.  By default, the configuration from the device is returned as text.  The other options include set and xml.  If the xml option is chosen, the configuration file is returned as both xml and json.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.   The value of `password' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_PASSWORD will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. The port value will default to the well known SSH port of 22 (for `transport=cli') or port 830 (for  `transport=netcon f') device.",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `ios' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. The value of `ssh_keyfile' is the path to the key used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_SSH_KEYFILE will be used instead.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_USERNAME will be used instead.",
            "type": "string"
          }
        },
        "required": "host"
      }
    },
    {
      "junos_netconf": {
        "type": "object",
        "description": "Configures the Junos Netconf system service",
        "properties": {
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "netconf_port": {
            "description": "This argument specifies the port the netconf service should listen on for SSH connections.  The default port as defined in RFC 6242 is 830.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.   The value of `password' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_PASSWORD will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. The port value will default to the well known SSH port of 22 (for `transport=cli') or port 830 (for  `transport=netcon f') device.",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `ios' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. The value of `ssh_keyfile' is the path to the key used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_SSH_KEYFILE will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Specifies the state of the [junos_netconf] resource on the remote device. If the `state' argument is set to `present' the netconf service will be configured.  If the `state' argument is set to `absent' the netconf service will be removed from the configuration.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_USERNAME will be used instead.",
            "type": "string"
          }
        },
        "required": "host"
      }
    },
    {
      "junos_package": {
        "type": "object",
        "description": "Installs packages on remote devices running Junos",
        "properties": {
          "force": {
            "description": "The `force' argument instructs the module to bypass the package version check and install the packaged identified in `src' on the remote device.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "no_copy": {
            "description": "The `no_copy' argument is responsible for instructing the remote device on where to install the package from. When enabled, the package is transferred to the remote device prior to installing.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.   The value of `password' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_PASSWORD will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. The port value will default to the well known SSH port of 22 (for `transport=cli') or port 830 (for  `transport=netcon f') device.",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `ios' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "reboot": {
            "description": "In order for a package to take effect, the remote device must be restarted.  When enabled, this argument will instruct the module to reboot the device once the updated package has been installed. If disabled or the remote package does not need to be changed, the device will not be started.",
            "type": "string"
          },
          "src": {
            "description": "The `src' argument specifies the path to the source package to be installed on the remote device in the advent of a version mismatch. The `src' argument can be either a localized path or a full path to the package file to install.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. The value of `ssh_keyfile' is the path to the key used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_SSH_KEYFILE will be used instead.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_USERNAME will be used instead.",
            "type": "string"
          },
          "version": {
            "description": "The `version' argument can be used to explicitly specify the version of the package that should be installed on the remote device. If the `version' argument is not specified, then the version is extracts from the `src' filename.",
            "type": "string"
          }
        },
        "required": [
          "force",
          "host",
          "reboot",
          "src"
        ]
      }
    },
    {
      "kernel_blacklist": {
        "type": "object",
        "description": "Blacklist kernel modules",
        "properties": {
          "blacklist_file": {
            "description": "If specified, use this blacklist file instead of `/etc/modprobe.d /blacklist- ansible.conf'.",
            "type": "string"
          },
          "name": {
            "description": "Name of kernel module to black- or whitelist.",
            "type": "string"
          },
          "state": {
            "description": "Whether the module should be present in the blacklist or absent.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "kibana_plugin": {
        "type": "object",
        "description": "Manage Kibana plugins",
        "properties": {
          "force": {
            "description": "Delete and re-install the plugin. Can be useful for plugins update",
            "type": "string"
          },
          "name": {
            "description": "Name of the plugin to install",
            "type": "string"
          },
          "plugin_bin": {
            "description": "Location of the plugin binary",
            "type": "string"
          },
          "plugin_dir": {
            "description": "Your configured plugin directory specified in Kibana",
            "type": "string"
          },
          "state": {
            "description": "Desired state of a plugin.",
            "type": "string"
          },
          "timeout": {
            "description": "Timeout setting: 30s, 1m, 1h...",
            "type": "string"
          },
          "url": {
            "description": "Set exact URL to download the plugin from. For local file, prefix its absolute path with file://",
            "type": "string"
          },
          "version": {
            "description": "Version of the plugin to be installed. If plugin exists with previous version, it will NOT be updated if `force' is not set to yes",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "kinesis_stream": {
        "type": "object",
        "description": "Manage a Kinesis Stream.",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "name": {
            "description": "The name of the Kinesis Stream you are managing.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "retention_period": {
            "description": "The default retention period is 24 hours and can not be less than 24 hours. The retention period can be modified during any point in time.",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "shards": {
            "description": "The number of shards you want to have with this stream. This can not be modified after being created. This is required when state == present",
            "type": "string"
          },
          "state": {
            "description": "Create or Delete the Kinesis Stream.",
            "type": "string"
          },
          "tags": {
            "description": "A dictionary of resource tags of the form: { tag1: value1, tag2: value2 }.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "wait": {
            "description": "Wait for operation to complete before returning.",
            "type": "string"
          },
          "wait_timeout": {
            "description": "How many seconds to wait for an operation to complete before timing out.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "known_hosts": {
        "type": "object",
        "description": "Add or remove a host from the `known_hosts' file",
        "properties": {
          "key": {
            "description": "The SSH public host key, as a string (required if state=present, optional when state=absent, in which case all keys for the host are removed). The key must be in the right format for ssh (see sshd(1), section \"SSH_KNOWN_HOSTS FILE FORMAT\")",
            "type": "string"
          },
          "name": {
            "description": "The host to add or remove (must match a host specified in key)",
            "type": "string"
          },
          "path": {
            "description": "The known_hosts file to edit",
            "type": "string"
          },
          "state": {
            "description": "`present' to add the host key, `absent' to remove it.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "kubernetes": {
        "type": "object",
        "description": "Manage Kubernetes resources.",
        "properties": {
          "api_endpoint": {
            "description": "The IPv4 API endpoint of the Kubernetes cluster.",
            "type": "string"
          },
          "certificate_authority_data": {
            "description": "Certificate Authority data for Kubernetes server. Should be in either standard PEM format or base64 encoded PEM data. Note that certificate verification is broken until ansible supports a version of 'match_hostname' that can match the IP address against the CA data.",
            "type": "string"
          },
          "file_reference": {
            "description": "Specify full path to a Kubernets YAML file to send to API `endpoint'. This option is mutually exclusive with `'inline_data''.",
            "type": "string"
          },
          "inline_data": {
            "description": "The Kubernetes YAML data to send to the API `endpoint'. This option is mutually exclusive with `' file_reference''.",
            "type": "string"
          },
          "insecure": {
            "description": "Reverts the connection to using HTTP instead of HTTPS. This option should only be used when execuing the ['kubernetes'] module local to the Kubernetes cluster using the insecure local port (locahost:8080 by default).",
            "type": "string"
          },
          "state": {
            "description": "The desired action to take on the Kubernetes data.",
            "type": "string"
          },
          "url_password": {
            "description": "The HTTP Basic Auth password for the API `endpoint'. This should be set unless using the `'insecure'' option.",
            "type": "string"
          },
          "url_username": {
            "description": "The HTTP Basic Auth username for the API `endpoint'. This should be set unless using the `'insecure'' option.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Enable/disable certificate validation. Note that this is set to `false' until Ansible can support IP address based certificate hostname matching (exists in >= python3.5.0).",
            "type": "string"
          }
        },
        "required": [
          "api_endpoint",
          "inline_data",
          "state"
        ]
      }
    },
    {
      "lambda": {
        "type": "object",
        "description": "Manage AWS Lambda functions",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "description": {
            "description": "A short, user-defined function description. Lambda does not use this value. Assign a meaningful description as you see fit.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "handler": {
            "description": "The function within your code that Lambda calls to begin execution",
            "type": "string"
          },
          "memory_size": {
            "description": "The amount of memory, in MB, your Lambda function is given",
            "type": "string"
          },
          "name": {
            "description": "The name you want to assign to the function you are uploading. Cannot be changed.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "role": {
            "description": "The Amazon Resource Name (ARN) of the IAM role that Lambda assumes when it executes your function to access any other Amazon Web Services (AWS) resources. You may use the bare ARN if the role belongs to the same AWS account.",
            "type": "string"
          },
          "runtime": {
            "description": "The runtime environment for the Lambda function you are uploading. Required when creating a function. Use parameters as described in boto3 docs. Current example runtime environments are nodejs, nodejs4.3, java8 or python2.7",
            "type": "string"
          },
          "s3_bucket": {
            "description": "Amazon S3 bucket name where the .zip file containing your deployment package is stored",
            "type": "string"
          },
          "s3_key": {
            "description": "The Amazon S3 object (the deployment package) key name you want to upload",
            "type": "string"
          },
          "s3_object_version": {
            "description": "The Amazon S3 object (the deployment package) version you want to upload.",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "Create or delete Lambda function",
            "type": "string"
          },
          "timeout": {
            "description": "The function execution time at which Lambda should terminate the function.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "vpc_security_group_ids": {
            "description": "List of VPC security group IDs to associate with the Lambda function. Required when vpc_subnet_ids is used.",
            "type": "string"
          },
          "vpc_subnet_ids": {
            "description": "List of subnet IDs to run Lambda function in. Use this option if you need to access resources in your VPC. Leave empty if you don't want to run the function in a VPC.",
            "type": "string"
          },
          "zip_file": {
            "description": "A .zip file containing your deployment package",
            "type": "string"
          }
        },
        "required": [
          "name",
          "runtime"
        ]
      }
    },
    {
      "lambda_alias": {
        "type": "object",
        "description": "Creates, updates or deletes AWS Lambda function aliases.",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "description": {
            "description": "A short, user-defined function alias description.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "function_name": {
            "description": "The name of the function alias.",
            "type": "string"
          },
          "name": {
            "description": "Name of the function alias.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "Describes the desired state.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "version": {
            "description": "Version associated with the Lambda function alias. A value of 0 (or omitted parameter) sets the alias to the $LATEST version.",
            "type": "string"
          }
        },
        "required": [
          "function_name",
          "name",
          "state"
        ]
      }
    },
    {
      "lambda_event": {
        "type": "object",
        "description": "Creates, updates or deletes AWS Lambda function event mappings.",
        "properties": {
          "alias": {
            "description": "Name of the function alias. Mutually exclusive with `version'.",
            "type": "string"
          },
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "event_source": {
            "description": "Source of the event that triggers the lambda function.",
            "type": "string"
          },
          "lambda_function_arn": {
            "description": "The name or ARN of the lambda function.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "source_params": {
            "description": "Sub-parameters required for event source. `== stream event source ==' `source_arn' The Amazon Resource Name (ARN) of the Kinesis or DynamoDB stream that is the event source. `enabled' Indicates whether AWS Lambda should begin polling the event source. Default is True. `batch_size' The largest number of records that AWS Lambda will retrieve from your event source at the time of invoking your function. Default is 100. `starting _position' The position in the stream where AWS Lambda should start reading. Choices are TRIM_HORIZON or LATEST.",
            "type": "string"
          },
          "state": {
            "description": "Describes the desired state.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "version": {
            "description": "Version of the Lambda function. Mutually exclusive with `alias'.",
            "type": "string"
          }
        },
        "required": [
          "alias",
          "lambda_function_arn",
          "source_params",
          "state"
        ]
      }
    },
    {
      "lambda_facts": {
        "type": "object",
        "description": "Gathers AWS Lambda function details as Ansible facts",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "event_source_arn": {
            "description": "For query type 'mappings', this is the Amazon Resource Name (ARN) of the Amazon Kinesis or DynamoDB stream.",
            "type": "string"
          },
          "function_name": {
            "description": "The name of the lambda function for which facts are requested.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "query": {
            "description": "Specifies the resource type for which to gather facts.  Leave blank to retrieve all facts.",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        },
        "required": "query"
      }
    },
    {
      "layman": {
        "type": "object",
        "description": "Manage Gentoo overlays",
        "properties": {
          "list_url": {
            "description": "An URL of the alternative overlays list that defines the overlay to install. This list will be fetched and saved under `${overlay_ defs}'/${name}.xm l), where `overlay_defs' is readed from the Layman's configuration.",
            "type": "string"
          },
          "name": {
            "description": "The overlay id to install, synchronize, or uninstall. Use 'ALL' to sync all of the installed overlays (can be used only when `state=updated').",
            "type": "string"
          },
          "state": {
            "description": "Whether to install (`present'), sync (`updated'), or uninstall (`absent') the overlay.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be set to `no' when no other option exists. Prior to 1.9.3 the code defaulted to `no'.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "letsencrypt": {
        "type": "object",
        "description": "Create SSL certificates with Let's Encrypt",
        "properties": {
          "account_email": {
            "description": "The email address associated with this account. It will be used for certificate expiration warnings.",
            "type": "string"
          },
          "account_key": {
            "description": "File containing the the Let's Encrypt account RSA key. Can be created with `openssl rsa ...'.",
            "type": "string"
          },
          "acme_directory": {
            "description": "The ACME directory to use. This is the entry point URL to access CA server API. For safety reasons the default is set to the Let's Encrypt staging server. This will create technically correct, but untrusted certificates.",
            "type": "string"
          },
          "agreement": {
            "description": "URI to a terms of service document you agree to when using the ACME service at `acme_directory'.",
            "type": "string"
          },
          "challenge": {
            "description": "T h e   c h a l l e n g e   t o   b e   p e r f o r m e d .",
            "type": "string"
          },
          "csr": {
            "description": "File containing the CSR for the new certificate. Can be created with `openssl csr ...'. The CSR may contain multiple Subject Alternate Names, but each one will lead to an individual challenge that must be fulfilled for the CSR to be signed.",
            "type": "string"
          },
          "data": {
            "description": "The data to validate ongoing challenges. The value that must be used here will be provided by a previous use of this module.",
            "type": "string"
          },
          "dest": {
            "description": "T h e   d e s t i n a t i o n   f i l e   f o r t h e   c e r t i f i c a t e .",
            "type": "string"
          },
          "remaining_days": {
            "description": "The number of days the certificate must have left being valid before it will be renewed.",
            "type": "string"
          }
        },
        "required": [
          "account_key",
          "csr",
          "dest"
        ]
      }
    },
    {
      "librato_annotation": {
        "type": "object",
        "description": "create an annotation in librato",
        "properties": {
          "api_key": {
            "description": "Librato account api key",
            "type": "string"
          },
          "description": {
            "description": "The description contains extra meta-data about a particular annotation The description should contain specifics on the individual annotation e.g. Deployed 9b562b2 shipped new feature foo!",
            "type": "string"
          },
          "end_time": {
            "description": "The unix timestamp indicating the the time at which the event referenced by this annotation ended For events that have a duration, this is a useful way to annotate the duration of the event",
            "type": "string"
          },
          "links": {
            "description": "See examples",
            "type": "string"
          },
          "name": {
            "description": "The annotation stream name If the annotation stream does not exist, it will be created automatically",
            "type": "string"
          },
          "source": {
            "description": "A string which describes the originating source of an annotation when that annotation is tracked across multiple members of a population",
            "type": "string"
          },
          "start_time": {
            "description": "The unix timestamp indicating the the time at which the event referenced by this annotation started",
            "type": "string"
          },
          "title": {
            "description": "The title of an annotation is a string and may contain spaces The title should be a short, high- level summary of the annotation e.g. v45 Deployment",
            "type": "string"
          },
          "user": {
            "description": "Librato account username",
            "type": "string"
          }
        },
        "required": [
          "api_key",
          "links",
          "title",
          "user"
        ]
      }
    },
    {
      "lineinfile": {
        "type": "object",
        "description": "Ensure a particular line is in a file, or replace an existing line using a back-referenced regular expression.",
        "properties": {
          "backrefs": {
            "description": "Used with `state=present'. If set, line can contain backreferences (both positional and named) that will get populated if the `regexp' matches. This flag changes the operation of the module slightly; `insertbefore' and `insertafter' will be ignored, and if the `regexp' doesn't match anywhere in the file, the file will be left unchanged. If the `regexp' does match, the last matching line will be replaced by the expanded line parameter.",
            "type": "string"
          },
          "backup": {
            "description": "Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.",
            "type": "string"
          },
          "create": {
            "description": "Used with `state=present'. If specified, the file will be created if it does not already exist. By default it will fail if the file is missing.",
            "type": "string"
          },
          "dest": {
            "description": "The file to modify.",
            "type": "string"
          },
          "group": {
            "description": "name of the group that should own the file/directory, as would be fed to `chown'",
            "type": "string"
          },
          "insertafter": {
            "description": "Used with `state=present'. If specified, the line will be inserted after the last match of specified regular expression. A special value is available; `EOF' for inserting the line at the end of the file. If specified regular expression has no matches, EOF will be used instead. May not be used with `backrefs'.",
            "type": "string"
          },
          "insertbefore": {
            "description": "Used with `state=present'. If specified, the line will be inserted before the last match of specified regular expression. A value is available; `BOF' for inserting the line at the beginning of the file. If specified regular expression has no matches, the line will be inserted at the end of the file.  May not be used with `backrefs'.",
            "type": "string"
          },
          "line": {
            "description": "Required for `state=present'. The line to insert/replace into the file. If `backrefs' is set, may contain backreferences that will get expanded with the `regexp' capture groups if the regexp matches.",
            "type": "string"
          },
          "mode": {
            "description": "mode the file or directory should be. For those used to `/usr/bin/chmod' remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, `u+rwx' or `u=rw,g=r,o=r').",
            "type": "string"
          },
          "others": {
            "description": "All arguments accepted by the [file] module also work here.",
            "type": "string"
          },
          "owner": {
            "description": "name of the user that should own the file/directory, as would be fed to `chown'",
            "type": "string"
          },
          "regexp": {
            "description": "The regular expression to look for in every line of the file. For `state=present', the pattern to replace if found; only the last line found will be replaced. For `state=absent', the pattern of the line to remove.  Uses Python regular expressions; see  http://docs.pytho n.org/2/library/r e.html.",
            "type": "string"
          },
          "selevel": {
            "description": "level part of the SELinux file context. This is the MLS/MCS attribute, sometimes known as the `range'. `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "serole": {
            "description": "role part of SELinux file context, `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "setype": {
            "description": "type part of SELinux file context, `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "seuser": {
            "description": "user part of SELinux file context. Will default to system policy, if applicable. If set to `_default', it will use the `user' portion of the policy if available",
            "type": "string"
          },
          "state": {
            "description": "Whether the line should be there or not.",
            "type": "string"
          },
          "unsafe_writes": {
            "description": "Normally this module uses atomic operations to prevent data corruption or inconsistent reads from the target files, sometimes systems are configured or just broken in ways that prevent this. One example are docker mounted files, they cannot be updated atomically and can only be done in an unsafe manner. This boolean option allows ansible to fall back to unsafe methods of updating files for those cases in which you do not have any other choice. Be aware that this is subject to race conditions and can lead to data corruption.",
            "type": "string"
          },
          "validate": {
            "description": "The validation command to run before copying into place. The path to the file to validate is passed in via '%s' which must be present as in the example below. The command is passed securely so shell features like expansion and pipes won't work.",
            "type": "string"
          }
        },
        "required": "dest"
      }
    },
    {
      "linode": {
        "type": "object",
        "description": "create / delete / stop / restart an instance in Linode Public Cloud",
        "properties": {
          "api_key": {
            "description": "Linode API key",
            "type": "string"
          },
          "datacenter": {
            "description": "datacenter to create an instance in (Linode Datacenter)",
            "type": "string"
          },
          "distribution": {
            "description": "distribution to use for the instance (Linode Distribution)",
            "type": "string"
          },
          "linode_id": {
            "description": "Unique ID of a linode server",
            "type": "string"
          },
          "name": {
            "description": "Name to give the instance (alphanumeric, dashes, underscore) To keep sanity on the Linode Web Console, name is prepended with LinodeID_",
            "type": "string"
          },
          "password": {
            "description": "root password to apply to a new server (auto generated if missing)",
            "type": "string"
          },
          "payment_term": {
            "description": "payment term to use for the instance (payment term in months)",
            "type": "string"
          },
          "plan": {
            "description": "plan to use for the instance (Linode plan)",
            "type": "string"
          },
          "ssh_pub_key": {
            "description": "SSH public key applied to root user",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the resource",
            "type": "string"
          },
          "swap": {
            "description": "swap size in MB",
            "type": "string"
          },
          "wait": {
            "description": "wait for the instance to be in state 'running' before returning",
            "type": "string"
          },
          "wait_timeout": {
            "description": "how long before wait gives up, in seconds",
            "type": "string"
          }
        }
      }
    },
    {
      "lldp": {
        "type": "object",
        "description": "get details reported by lldp",
        "properties": null
      }
    },
    {
      "locale_gen": {
        "type": "object",
        "description": "Creates or removes locales.",
        "properties": {
          "name": {
            "description": "Name and encoding of the locale, such as \"en_GB.UTF-8\".",
            "type": "string"
          },
          "state": {
            "description": "Whether the locale shall be present.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "logentries": {
        "type": "object",
        "description": "Module for tracking logs via logentries.com",
        "properties": {
          "logtype": {
            "description": "type of the log",
            "type": "string"
          },
          "name": {
            "description": "name of the log",
            "type": "string"
          },
          "path": {
            "description": "path to a log file",
            "type": "string"
          },
          "state": {
            "description": "following state of the log",
            "type": "string"
          }
        },
        "required": "path"
      }
    },
    {
      "logicmonitor": {
        "type": "object",
        "description": "Manage your LogicMonitor account through Ansible Playbooks",
        "properties": {
          "action": {
            "description": "The action you wish to perform on target. Add: Add an object to your LogicMonitor account. Remove: Remove an object from your LogicMonitor account. Update: Update properties, description, or groups (target=host) for an object in your LogicMonitor account. SDT: Schedule downtime for an object in your LogicMonitor account.",
            "type": "string"
          },
          "alertenable": {
            "description": "A boolean flag to turn alerting on or off for an object. Optional for managing all hosts (action=add or action=update).",
            "type": "string"
          },
          "collector": {
            "description": "The fully qualified domain name of a collector in your LogicMonitor account. This is required for the creation of a LogicMonitor host (target=host action=add). This is required for updating, removing or scheduling downtime for hosts if 'displayname' isn't specified (target=host action=update action=remove action=sdt).",
            "type": "string"
          },
          "company": {
            "description": "The LogicMonitor account company name. If you would log in to your account at \" superheroes.logic monitor.com\" you would use \"superheroes.\"",
            "type": "string"
          },
          "description": {
            "description": "The long text description of the object in your LogicMonitor account. Optional for managing hosts and host groups (target=host or target=hostgroup; action=add or action=update).",
            "type": "string"
          },
          "displayname": {
            "description": "The display name of a host in your LogicMonitor account or the desired display name of a device to manage. Optional for managing hosts (target=host).",
            "type": "string"
          },
          "duration": {
            "description": "The duration (minutes) of the Scheduled Down Time (SDT). Optional for putting an object into SDT (action=sdt).",
            "type": "string"
          },
          "fullpath": {
            "description": "The fullpath of the host group object you would like to manage. Recommend running on a single Ansible host. Required for management of LogicMonitor host groups (target=ho stgroup).",
            "type": "string"
          },
          "groups": {
            "description": "A list of groups that the host should be a member of. Optional for managing hosts (target=host; action=add or action=update).",
            "type": "string"
          },
          "hostname": {
            "description": "The hostname of a host in your LogicMonitor account, or the desired hostname of a device to manage. Optional for managing hosts (target=host).",
            "type": "string"
          },
          "id": {
            "description": "ID of the datasource to target. Required for management of LogicMonitor datasources (targ et=datasource).",
            "type": "string"
          },
          "password": {
            "description": "The password of the specified LogicMonitor user",
            "type": "string"
          },
          "properties": {
            "description": "A dictionary of properties to set on the LogicMonitor host or host group. Optional for managing hosts and host groups (target=host or target=hostgroup; action=add or action=update). This parameter will add or update existing properties in your LogicMonitor account.",
            "type": "string"
          },
          "starttime": {
            "description": "The time that the Scheduled Down Time (SDT) should begin. Optional for managing SDT (action=sdt). Y-m-d H:M",
            "type": "string"
          },
          "target": {
            "description": "The type of LogicMonitor object you wish to manage. Collector: Perform actions on a LogicMonitor collector. NOTE You should use Ansible service modules such as [service] or [supervisorctl] for managing the Collector 'logicmonitor- agent' and 'logicmonitor- watchdog' services. Specifically, you'll probably want to start these services after a Collector add and stop these services before a Collector remove. Host: Perform actions on a host device. Hostgroup: Perform actions on a LogicMonitor host group. NOTE Host and Hostgroup tasks should always be performed via local_action. There are no benefits to running these tasks on the remote host and doing so will typically cause problems.",
            "type": "string"
          },
          "user": {
            "description": "A LogicMonitor user name. The module will authenticate and perform actions on behalf of this user.",
            "type": "string"
          }
        },
        "required": [
          "action",
          "company",
          "password",
          "target",
          "user"
        ]
      }
    },
    {
      "logicmonitor_facts": {
        "type": "object",
        "description": "Collect facts about LogicMonitor objects",
        "properties": {
          "collector": {
            "description": "The fully qualified domain name of a collector in your LogicMonitor account. This is optional for querying a LogicMonitor host when a displayname is specified. This is required for querying a LogicMonitor host when a displayname is not specified.",
            "type": "string"
          },
          "company": {
            "description": "The LogicMonitor account company name. If you would log in to your account at \" superheroes.logic monitor.com\" you would use \"superheroes\".",
            "type": "string"
          },
          "displayname": {
            "description": "The display name of a host in your LogicMonitor account or the desired display name of a device to add into monitoring.",
            "type": "string"
          },
          "fullpath": {
            "description": "The fullpath of the hostgroup object you would like to manage. Recommend running on a single ansible host. Required for management of LogicMonitor host groups (target=ho stgroup).",
            "type": "string"
          },
          "hostname": {
            "description": "The hostname of a host in your LogicMonitor account, or the desired hostname of a device to add into monitoring. Required for managing hosts (target=host).",
            "type": "string"
          },
          "password": {
            "description": "The password for the chosen LogicMonitor User. If an md5 hash is used, the digest flag must be set to true.",
            "type": "string"
          },
          "target": {
            "description": "The LogicMonitor object you wish to manage.",
            "type": "string"
          },
          "user": {
            "description": "A LogicMonitor user name. The module will authenticate and perform actions on behalf of this user.",
            "type": "string"
          }
        },
        "required": [
          "company",
          "password",
          "target",
          "user"
        ]
      }
    },
    {
      "lvg": {
        "type": "object",
        "description": "Configure LVM volume groups",
        "properties": {
          "force": {
            "description": "If yes, allows to remove volume group with logical volumes.",
            "type": "string"
          },
          "pesize": {
            "description": "The size of the physical extent in megabytes. Must be a power of 2.",
            "type": "string"
          },
          "pvs": {
            "description": "List of comma-separated devices to use as physical devices in this volume group. Required when creating or resizing volume group. The module will take care of running pvcreate if needed.",
            "type": "string"
          },
          "state": {
            "description": "Control if the volume group exists.",
            "type": "string"
          },
          "vg": {
            "description": "The name of the volume group.",
            "type": "string"
          },
          "vg_options": {
            "description": "Additional options to pass to `vgcreate' when creating the volume group.",
            "type": "string"
          }
        },
        "required": "vg"
      }
    },
    {
      "lvol": {
        "type": "object",
        "description": "Configure LVM logical volumes",
        "properties": {
          "active": {
            "description": "Whether the volume is activate and visible to the host.",
            "type": "string"
          },
          "force": {
            "description": "Shrink or remove operations of volumes requires this switch. Ensures that that filesystems get never corrupted/d estroyed by mistake.",
            "type": "string"
          },
          "lv": {
            "description": "The name of the logical volume.",
            "type": "string"
          },
          "opts": {
            "description": "Free-form options to be passed to the lvcreate command",
            "type": "string"
          },
          "pvs": {
            "description": "Comma separated list of physical volumes e.g. /dev/sda,/dev/sdb",
            "type": "string"
          },
          "shrink": {
            "description": "shrink if current size is higher than size requested",
            "type": "string"
          },
          "size": {
            "description": "The size of the logical volume, according to lvcreate(8) --size, by default in megabytes or optionally with one of [bBsSkKmMg GtTpPeE] units; or according to lvcreate(8) --extents as a percentage of [VG|PVS|FREE]; Float values must begin with a digit. Resizing using percentage values was not supported prior to 2.1.",
            "type": "string"
          },
          "snapshot": {
            "description": "The name of the snapshot volume",
            "type": "string"
          },
          "state": {
            "description": "Control if the logical volume exists. If `present' and the volume does not already exist then the `size' option is required.",
            "type": "string"
          },
          "vg": {
            "description": "The volume group this logical volume is part of.",
            "type": "string"
          }
        },
        "required": [
          "lv",
          "vg"
        ]
      }
    },
    {
      "lxc_container": {
        "type": "object",
        "description": "Manage LXC Containers",
        "properties": {
          "archive": {
            "description": "Create an archive of a container. This will create a tarball of the running container.",
            "type": "string"
          },
          "archive_compression": {
            "description": "Type of compression to use when creating an archive of a running container.",
            "type": "string"
          },
          "archive_path": {
            "description": "Path the save the archived container. If the path does not exist the archive method will attempt to create it.",
            "type": "string"
          },
          "backing_store": {
            "description": "Backend storage type for the container.",
            "type": "string"
          },
          "clone_name": {
            "description": "Name of the new cloned server. This is only used when state is clone.",
            "type": "string"
          },
          "clone_snapshot": {
            "description": "Create a snapshot a container when cloning. This is not supported by all container storage backends. Enabling this may fail if the backing store does not support snapshots.",
            "type": "string"
          },
          "config": {
            "description": "Path to the LXC configuration file.",
            "type": "string"
          },
          "container_command": {
            "description": "Run a command within a container.",
            "type": "string"
          },
          "container_config": {
            "description": "list of 'key=value' options to use when configuring a container.",
            "type": "string"
          },
          "container_log": {
            "description": "Enable a container log for host actions to the container.",
            "type": "string"
          },
          "container_log_level": {
            "description": "Set the log level for a container where *container_log* was set.",
            "type": "string"
          },
          "directory": {
            "description": "Place rootfs directory under DIR.",
            "type": "string"
          },
          "fs_size": {
            "description": "File system Size.",
            "type": "string"
          },
          "fs_type": {
            "description": "Create fstype TYPE.",
            "type": "string"
          },
          "lv_name": {
            "description": "Name of the logical volume, defaults to the container name.",
            "type": "string"
          },
          "lxc_path": {
            "description": "Place container under PATH",
            "type": "string"
          },
          "name": {
            "description": "Name of a container.",
            "type": "string"
          },
          "state": {
            "description": "Define the state of a container. If you clone a container using `clone_name` the newly cloned container created in a stopped state. The running container will be stopped while the clone operation is happening and upon completion of the clone the original container state will be restored.",
            "type": "string"
          },
          "template": {
            "description": "Name of the template to use within an LXC create.",
            "type": "string"
          },
          "template_options": {
            "description": "Template options when building the container.",
            "type": "string"
          },
          "thinpool": {
            "description": "Use LVM thin pool called TP.",
            "type": "string"
          },
          "vg_name": {
            "description": "If Backend store is lvm, specify the name of the volume group.",
            "type": "string"
          },
          "zfs_root": {
            "description": "Create zfs under given zfsroot.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "lxd_container": {
        "type": "object",
        "description": "Manage LXD Containers",
        "properties": {
          "architecture": {
            "description": "The archiecture for the container (e.g. \"x86_64\" or \"i686\"). See h ttps://github.com /lxc/lxd/blob/mas ter/doc/rest- api.md#post-1",
            "type": "string"
          },
          "cert_file": {
            "description": "The client certificate file path.",
            "type": "string"
          },
          "config": {
            "description": "The config for the container (e.g. {\"limits.cpu\": \"2\"}). See https: //github.com/lxc/ lxd/blob/master/d oc/rest- api.md#post-1 If the container already exists and its \"config\" value in metadata obtained from GET /1.0/containers/< name> https://git hub.com/lxc/lxd/b lob/master/doc /rest-api.md#10co ntainersname are different, they this module tries to apply the configurations. The key starts with 'volatile.' are ignored for this comparison. Not all config values are supported to apply the existing container. Maybe you need to delete and recreate a container.",
            "type": "string"
          },
          "devices": {
            "description": "The devices for the container (e.g. { \"rootfs\": { \"path\": \"/dev/kvm\", \"type\": \"unix- char\" }). See htt ps://github.com/l xc/lxd/blob/maste r/doc/rest- api.md#post-1",
            "type": "string"
          },
          "ephemeral": {
            "description": "Whether or not the container is ephemeral (e.g. true or false). See https://githu b.com/lxc/lxd/blo b/master/doc /rest- api.md#post-1",
            "type": "string"
          },
          "force_stop": {
            "description": "If this is true, the [lxd_container] forces to stop the container when it stops or restarts the container.",
            "type": "string"
          },
          "key_file": {
            "description": "The client certificate key file path.",
            "type": "string"
          },
          "name": {
            "description": "Name of a container.",
            "type": "string"
          },
          "source": {
            "description": "The source for the container (e.g. { \"type\": \"image\", \"mode\": \"pull\", \"server\": \"https://images.l inuxcontainers.or g\", \"protocol\": \"lxd\", \"alias\": \" ubuntu/xenial/amd 64\" }). See https ://github.com/lxc /lxd/blob/master/ doc/rest- api.md#post-1",
            "type": "string"
          },
          "state": {
            "description": "Define the state of a container.",
            "type": "string"
          },
          "timeout": {
            "description": "A timeout for changing the state of the container. This is also used as a timeout for waiting until IPv4 addresses are set to the all network interfaces in the container after starting or restarting.",
            "type": "string"
          },
          "trust_password": {
            "description": "The client trusted password. You need to set this password on the LXD server before running this module using the following command. lxc config set core.t rust_password <some random password> See htt ps://www.stgraber .org/2016/04/18 /lxd-api-direct- interaction/ If trust_password is set, this module send a request for authentication before sending any requests.",
            "type": "string"
          },
          "url": {
            "description": "The unix domain socket path or the https URL for the LXD server.",
            "type": "string"
          },
          "wait_for_ipv4_addresses": {
            "description": "If this is true, the [lxd_container] waits until IPv4 addresses are set to the all network interfaces in the container after starting or restarting.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "lxd_profile": {
        "type": "object",
        "description": "Manage LXD profiles",
        "properties": {
          "cert_file": {
            "description": "The client certificate file path.",
            "type": "string"
          },
          "config": {
            "description": "The config for the container (e.g. {\"limits.memory\": \"4GB\"}). See http s://github.com/lx c/lxd/blob/master /doc/rest- api.md#patch-3 If the profile already exists and its \"config\" value in metadata obtained from GET /1.0/profiles/<na me> https://githu b.com/lxc/lxd/blo b/master/doc /rest- api.md#get-19 are different, they this module tries to apply the configurations. Not all config values are supported to apply the existing profile. Maybe you need to delete and recreate a profile.",
            "type": "string"
          },
          "devices": {
            "description": "The devices for the profile (e.g. {\"rootfs\": {\"path\": \"/dev/kvm\", \"type\": \"unix- char\"}). See http s://github.com/lx c/lxd/blob/master /doc/rest- api.md#patch-3",
            "type": "string"
          },
          "key_file": {
            "description": "The client certificate key file path.",
            "type": "string"
          },
          "name": {
            "description": "Name of a profile.",
            "type": "string"
          },
          "new_name": {
            "description": "A new name of a profile. If this parameter is specified a profile will be renamed to this name. See https:/ /github.com/lxc/l xd/blob/master/do c/rest- api.md#post-11",
            "type": "string"
          },
          "state": {
            "description": "Define the state of a profile.",
            "type": "string"
          },
          "trust_password": {
            "description": "The client trusted password. You need to set this password on the LXD server before running this module using the following command. lxc config set core.t rust_password <some random password> See htt ps://www.stgraber .org/2016/04/18 /lxd-api-direct- interaction/ If trust_password is set, this module send a request for authentication before sending any requests.",
            "type": "string"
          },
          "url": {
            "description": "The unix domain socket path or the https URL for the LXD server.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "macports": {
        "type": "object",
        "description": "Package manager for MacPorts",
        "properties": {
          "name": {
            "description": "name of package to install/remove",
            "type": "string"
          },
          "state": {
            "description": "state of the package",
            "type": "string"
          },
          "update_cache": {
            "description": "update the package db first",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "mail": {
        "type": "object",
        "description": "Send an email",
        "properties": {
          "attach": {
            "description": "A space-separated list of pathnames of files to attach to the message. Attached files will have their content- type set to `application /octet-stream'.",
            "type": "string"
          },
          "bcc": {
            "description": "The email-address(es) the mail is being 'blind' copied to. This is a comma- separated list, which may contain address and phrase portions.",
            "type": "string"
          },
          "body": {
            "description": "The body of the email being sent.",
            "type": "string"
          },
          "cc": {
            "description": "The email-address(es) the mail is being copied to. This is a comma-separated list, which may contain address and phrase portions.",
            "type": "string"
          },
          "charset": {
            "description": "The character set of email being sent",
            "type": "string"
          },
          "from": {
            "description": "The email-address the mail is sent from. May contain address and phrase.",
            "type": "string"
          },
          "headers": {
            "description": "A vertical-bar-separated list of headers which should be added to the message. Each individual header is specified as `header=value' (see example below).",
            "type": "string"
          },
          "host": {
            "description": "The mail server",
            "type": "string"
          },
          "password": {
            "description": "If SMTP requires password",
            "type": "string"
          },
          "port": {
            "description": "The mail server port",
            "type": "string"
          },
          "subject": {
            "description": "The subject of the email being sent.",
            "type": "string"
          },
          "subtype": {
            "description": "The minor mime type, can be either text or html. The major type is always text.",
            "type": "string"
          },
          "to": {
            "description": "The email-address(es) the mail is being sent to. This is a comma- separated list, which may contain address and phrase portions.",
            "type": "string"
          },
          "username": {
            "description": "If SMTP requires username",
            "type": "string"
          }
        },
        "required": "subject"
      }
    },
    {
      "make": {
        "type": "object",
        "description": "Run targets in a Makefile",
        "properties": {
          "chdir": {
            "description": "cd into this directory before running make",
            "type": "string"
          },
          "params": {
            "description": "Any extra parameters to pass to make",
            "type": "string"
          },
          "target": {
            "description": "The target to run",
            "type": "string"
          }
        },
        "required": "chdir"
      }
    },
    {
      "maven_artifact": {
        "type": "object",
        "description": "Downloads an Artifact from a Maven Repository",
        "properties": {
          "artifact_id": {
            "description": "The maven artifactId coordinate",
            "type": "string"
          },
          "classifier": {
            "description": "The maven classifier coordinate",
            "type": "string"
          },
          "dest": {
            "description": "The path where the artifact should be written to",
            "type": "string"
          },
          "extension": {
            "description": "The maven type/extension coordinate",
            "type": "string"
          },
          "group_id": {
            "description": "The Maven groupId coordinate",
            "type": "string"
          },
          "password": {
            "description": "The password to authenticate with to the Maven Repository. Use AWS secret access key of the repository is hosted on S3",
            "type": "string"
          },
          "repository_url": {
            "description": "The URL of the Maven Repository to download from. Use s3://... if the repository is hosted on Amazon S3, added in version 2.2.",
            "type": "string"
          },
          "state": {
            "description": "The desired state of the artifact",
            "type": "string"
          },
          "username": {
            "description": "The username to authenticate as to the Maven Repository. Use AWS secret key of the repository is hosted on S3",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be set to `no' when no other option exists.",
            "type": "string"
          },
          "version": {
            "description": "The maven version coordinate",
            "type": "string"
          }
        },
        "required": [
          "artifact_id",
          "dest",
          "group_id",
          "state"
        ]
      }
    },
    {
      "meta": {
        "type": "object",
        "description": "Execute Ansible 'actions'",
        "properties": {
          "free_form": {
            "description": "This module takes a free form command, as a string. There's not an actual option named \"free form\".  See the examples! `flush_handlers' makes Ansible run any handler tasks which have thus far been notified. Ansible inserts these tasks internally at certain points to implicitly trigger handler runs (after pre/post tasks, the final role execution, and the main tasks section of your plays). `refresh_ inventory' (added in 2.0) forces the reload of the inventory, which in the case of dynamic inventory scripts means they will be re- executed. This is mainly useful when additional hosts are created and users wish to use them instead of using the `add_host` module. `noop' (added in 2.0) This literally does 'nothing'. It is mainly used internally and not recommended for general use. `clear_facts' (added in 2.1) causes the gathered facts for the hosts specified in the play's list of hosts to be cleared, including the fact cache. `clea r_host_errors' (added in 2.1) clears the failed state (if any) from hosts specified in the play's list of hosts. `end_play' (added in 2.2) causes the play to end without failing the host.",
            "type": "string"
          }
        },
        "required": "free_form"
      }
    },
    {
      "modprobe": {
        "type": "object",
        "description": "Add or remove kernel modules",
        "properties": {
          "name": {
            "description": "Name of kernel module to manage.",
            "type": "string"
          },
          "params": {
            "description": "Modules parameters.",
            "type": "string"
          },
          "state": {
            "description": "Whether the module should be present or absent.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "mongodb_parameter": {
        "type": "object",
        "description": "Change an administrative parameter on a MongoDB server.",
        "properties": {
          "database": {
            "description": "The name of the database to add/remove the user from",
            "type": "string"
          },
          "login_database": {
            "description": "The database where login credentials are stored",
            "type": "string"
          },
          "login_host": {
            "description": "The host running the database",
            "type": "string"
          },
          "login_password": {
            "description": "The password used to authenticate with",
            "type": "string"
          },
          "login_port": {
            "description": "The port to connect to",
            "type": "string"
          },
          "login_user": {
            "description": "The username used to authenticate with",
            "type": "string"
          },
          "param": {
            "description": "MongoDB administrative parameter to modify",
            "type": "string"
          },
          "param_type": {
            "description": "Define the parameter value (str, int)",
            "type": "string"
          },
          "replica_set": {
            "description": "Replica set to connect to (automatically connects to primary for writes)",
            "type": "string"
          },
          "ssl": {
            "description": "Whether to use an SSL connection when connecting to the database",
            "type": "string"
          },
          "value": {
            "description": "MongoDB administrative parameter value to set",
            "type": "string"
          }
        },
        "required": [
          "database",
          "param",
          "value"
        ]
      }
    },
    {
      "mongodb_user": {
        "type": "object",
        "description": "Adds or removes a user from a MongoDB database.",
        "properties": {
          "database": {
            "description": "The name of the database to add/remove the user from",
            "type": "string"
          },
          "login_database": {
            "description": "The database where login credentials are stored",
            "type": "string"
          },
          "login_host": {
            "description": "The host running the database",
            "type": "string"
          },
          "login_password": {
            "description": "The password used to authenticate with",
            "type": "string"
          },
          "login_port": {
            "description": "The port to connect to",
            "type": "string"
          },
          "login_user": {
            "description": "The username used to authenticate with",
            "type": "string"
          },
          "name": {
            "description": "The name of the user to add or remove",
            "type": "string"
          },
          "password": {
            "description": "The password to use for the user",
            "type": "string"
          },
          "replica_set": {
            "description": "Replica set to connect to (automatically connects to primary for writes)",
            "type": "string"
          },
          "roles": {
            "description": "The database user roles valid values could either be one or more of the following strings: 'read', 'readWrite', 'dbAdmin', 'userAdmin', 'clusterAdmin', ' readAnyDatabase', 'readWriteAnyData base', 'userAdmin AnyDatabase', 'db AdminAnyDatabase' Or the following dictionary '{ db: DATABASE_NAME, role: ROLE_NAME }'. This param requires pymongo 2.5+. If it is a string, mongodb 2.4+ is also required. If it is a dictionary, mongo 2.6+  is required.",
            "type": "string"
          },
          "ssl": {
            "description": "Whether to use an SSL connection when connecting to the database",
            "type": "string"
          },
          "ssl_cert_reqs": {
            "description": "Specifies whether a certificate is required from the other side of the connection, and whether it will be validated if provided.",
            "type": "string"
          },
          "state": {
            "description": "The database user state",
            "type": "string"
          },
          "update_password": {
            "description": "`always' will update passwords if they differ. `on_create' will only set the password for newly created users.",
            "type": "string"
          }
        },
        "required": [
          "database",
          "name"
        ]
      }
    },
    {
      "monit": {
        "type": "object",
        "description": "Manage the state of a program monitored via Monit",
        "properties": {
          "name": {
            "description": "The name of the `monit' program/process to manage",
            "type": "string"
          },
          "state": {
            "description": "The state of service",
            "type": "string"
          },
          "timeout": {
            "description": "If there are pending actions for the service monitored by monit, then Ansible will check for up to this many seconds to verify the the requested action has been performed. Ansible will sleep for five seconds between each check.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "state"
        ]
      }
    },
    {
      "mount": {
        "type": "object",
        "description": "Control active and configured mount points",
        "properties": {
          "boot": {
            "description": "Determines if the filesystem should be mounted on boot. Only applies to Solaris systems.",
            "type": "string"
          },
          "dump": {
            "description": "Dump (see fstab(5)). Note that if set to `null' and `state' set to `present', it will cease to work and duplicate entries will be made with subsequent runs. Has no effect on Solaris systems.",
            "type": "string"
          },
          "fstab": {
            "description": "File to use instead of `/etc/fstab'. You shouldn't use that option unless you really know what you are doing. This might be useful if you need to configure mountpoints in a chroot environment.",
            "type": "string"
          },
          "fstype": {
            "description": "Filesystem type. Required when `state' is `present' or `mounted'.",
            "type": "string"
          },
          "name": {
            "description": "Path to the mount point (e.g. `/mnt/files')",
            "type": "string"
          },
          "opts": {
            "description": "Mount options (see fstab(5), or vfstab(4) on Solaris).",
            "type": "string"
          },
          "passno": {
            "description": "Passno (see fstab(5)). Note that if set to `null' and `state' set to `present', it will cease to work and duplicate entries will be made with subsequent runs. Deprecated on Solaris systems.",
            "type": "string"
          },
          "src": {
            "description": "Device to be mounted on `name'. Required when `state' set to `present' or `mounted'.",
            "type": "string"
          },
          "state": {
            "description": "If `mounted' or `unmounted', the device will be actively mounted or unmounted as needed and appropriately configured in `fstab'. `absent' and `present' only deal with `fstab' but will not affect current mounting. If specifying `mounted' and the mount point is not present, the mount point will be created. Similarly, specifying `absent' will remove the mount point directory.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "state"
        ]
      }
    },
    {
      "mqtt": {
        "type": "object",
        "description": "Publish a message on an MQTT topic for the IoT",
        "properties": {
          "client_id": {
            "description": "MQTT client identifier",
            "type": "string"
          },
          "password": {
            "description": "Password for `username' to authenticate against the broker.",
            "type": "string"
          },
          "payload": {
            "description": "Payload. The special string `\"None\"' may be used to send a NULL (i.e. empty) payload which is useful to simply notify with the `topic' or to clear previously retained messages.",
            "type": "string"
          },
          "port": {
            "description": "MQTT broker port number",
            "type": "string"
          },
          "qos": {
            "description": "QoS (Quality of Service)",
            "type": "string"
          },
          "retain": {
            "description": "Setting this flag causes the broker to retain (i.e. keep) the message so that applications that subsequently subscribe to the topic can received the last retained message immediately.",
            "type": "string"
          },
          "server": {
            "description": "MQTT broker address/name",
            "type": "string"
          },
          "topic": {
            "description": "MQTT topic name",
            "type": "string"
          },
          "username": {
            "description": "Username to authenticate against the broker.",
            "type": "string"
          }
        },
        "required": [
          "payload",
          "topic"
        ]
      }
    },
    {
      "mssql_db": {
        "type": "object",
        "description": "Add or remove MSSQL databases from a remote host.",
        "properties": {
          "autocommit": {
            "description": "Automatically commit the change only if the import succeed. Sometimes it is necessary to use autocommit=true, since some content can't be changed within a transaction.",
            "type": "string"
          },
          "login_host": {
            "description": "Host running the database",
            "type": "string"
          },
          "login_password": {
            "description": "The password used to authenticate with",
            "type": "string"
          },
          "login_port": {
            "description": "Port of the MSSQL server. Requires login_host be defined as other then localhost if login_port is used",
            "type": "string"
          },
          "login_user": {
            "description": "The username used to authenticate with",
            "type": "string"
          },
          "name": {
            "description": "name of the database to add or remove",
            "type": "string"
          },
          "state": {
            "description": "The database state",
            "type": "string"
          },
          "target": {
            "description": "Location, on the remote host, of the dump file to read from or write to. Uncompressed SQL files (`.sql') files are supported.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "mysql_db": {
        "type": "object",
        "description": "Add or remove MySQL databases from a remote host.",
        "properties": {
          "collation": {
            "description": "Collation mode (sorting). This only applies to new table/databases and does not update existing ones, this is a limitation of MySQL.",
            "type": "string"
          },
          "config_file": {
            "description": "Specify a config file from which user and password are to be read",
            "type": "string"
          },
          "connect_timeout": {
            "description": "The connection timeout when connecting to the MySQL server.",
            "type": "string"
          },
          "encoding": {
            "description": "Encoding mode to use, examples include `utf8' or `latin1_swedish_c i'",
            "type": "string"
          },
          "login_host": {
            "description": "Host running the database",
            "type": "string"
          },
          "login_password": {
            "description": "The password used to authenticate with",
            "type": "string"
          },
          "login_port": {
            "description": "Port of the MySQL server. Requires login_host be defined as other then localhost if login_port is used",
            "type": "string"
          },
          "login_unix_socket": {
            "description": "The path to a Unix domain socket for local connections",
            "type": "string"
          },
          "login_user": {
            "description": "The username used to authenticate with",
            "type": "string"
          },
          "name": {
            "description": "name of the database to add or remove name=all May only be provided if `state' is `dump' or `import'. if name=all Works like --all- databases option for mysqldump (Added in 2.0)",
            "type": "string"
          },
          "quick": {
            "description": "Option used for dumping large tables",
            "type": "string"
          },
          "single_transaction": {
            "description": "Execute the dump in a single transaction",
            "type": "string"
          },
          "ssl_ca": {
            "description": "The path to a Certificate Authority (CA) certificate. This option, if used, must specify the same certificate as used by the server.",
            "type": "string"
          },
          "ssl_cert": {
            "description": "The path to a client public key certificate.",
            "type": "string"
          },
          "ssl_key": {
            "description": "The path to the client private key.",
            "type": "string"
          },
          "state": {
            "description": "The database state",
            "type": "string"
          },
          "target": {
            "description": "Location, on the remote host, of the dump file to read from or write to. Uncompressed SQL files (`.sql') as well as bzip2 (`.bz2'), gzip (`.gz') and xz (Added in 2.0) compressed files are supported.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "mysql_replication": {
        "type": "object",
        "description": "Manage MySQL replication",
        "properties": {
          "config_file": {
            "description": "Specify a config file from which user and password are to be read",
            "type": "string"
          },
          "connect_timeout": {
            "description": "The connection timeout when connecting to the MySQL server.",
            "type": "string"
          },
          "login_host": {
            "description": "Host running the database",
            "type": "string"
          },
          "login_password": {
            "description": "The password used to authenticate with",
            "type": "string"
          },
          "login_port": {
            "description": "Port of the MySQL server. Requires login_host be defined as other then localhost if login_port is used",
            "type": "string"
          },
          "login_unix_socket": {
            "description": "The path to a Unix domain socket for local connections",
            "type": "string"
          },
          "login_user": {
            "description": "The username used to authenticate with",
            "type": "string"
          },
          "master_auto_position": {
            "description": "does the host uses GTID based replication or not",
            "type": "string"
          },
          "master_connect_retry": {
            "description": "same as mysql variable",
            "type": "string"
          },
          "master_host": {
            "description": "same as mysql variable",
            "type": "string"
          },
          "master_log_file": {
            "description": "same as mysql variable",
            "type": "string"
          },
          "master_log_pos": {
            "description": "same as mysql variable",
            "type": "string"
          },
          "master_password": {
            "description": "same as mysql variable",
            "type": "string"
          },
          "master_port": {
            "description": "same as mysql variable",
            "type": "string"
          },
          "master_ssl": {
            "description": "same as mysql variable",
            "type": "string"
          },
          "master_ssl_ca": {
            "description": "same as mysql variable",
            "type": "string"
          },
          "master_ssl_capath": {
            "description": "same as mysql variable",
            "type": "string"
          },
          "master_ssl_cert": {
            "description": "same as mysql variable",
            "type": "string"
          },
          "master_ssl_cipher": {
            "description": "same as mysql variable",
            "type": "string"
          },
          "master_ssl_key": {
            "description": "same as mysql variable",
            "type": "string"
          },
          "master_user": {
            "description": "same as mysql variable",
            "type": "string"
          },
          "mode": {
            "description": "module operating mode. Could be getslave (SHOW SLAVE STATUS), getmaster (SHOW MASTER STATUS), changemaster (CHANGE MASTER TO), startslave (START SLAVE), stopslave (STOP SLAVE), resetslave (RESET SLAVE), resetslaveall (RESET SLAVE ALL)",
            "type": "string"
          },
          "relay_log_file": {
            "description": "same as mysql variable",
            "type": "string"
          },
          "relay_log_pos": {
            "description": "same as mysql variable",
            "type": "string"
          },
          "ssl_ca": {
            "description": "The path to a Certificate Authority (CA) certificate. This option, if used, must specify the same certificate as used by the server.",
            "type": "string"
          },
          "ssl_cert": {
            "description": "The path to a client public key certificate.",
            "type": "string"
          },
          "ssl_key": {
            "description": "The path to the client private key.",
            "type": "string"
          }
        }
      }
    },
    {
      "mysql_user": {
        "type": "object",
        "description": "Adds or removes a user from a MySQL database.",
        "properties": {
          "append_privs": {
            "description": "Append the privileges defined by priv to the existing ones for this user instead of overwriting existing ones.",
            "type": "string"
          },
          "check_implicit_admin": {
            "description": "Check if mysql allows login as root/nopassword before trying supplied credentials.",
            "type": "string"
          },
          "config_file": {
            "description": "Specify a config file from which user and password are to be read",
            "type": "string"
          },
          "connect_timeout": {
            "description": "The connection timeout when connecting to the MySQL server.",
            "type": "string"
          },
          "encrypted": {
            "description": "Indicate that the 'password' field is a `mysql_native_pas sword` hash",
            "type": "string"
          },
          "host": {
            "description": "the 'host' part of the MySQL username",
            "type": "string"
          },
          "host_all": {
            "description": "override the host option, making ansible apply changes to all hostnames for a given user.  This option cannot be used when creating users",
            "type": "string"
          },
          "login_host": {
            "description": "Host running the database",
            "type": "string"
          },
          "login_password": {
            "description": "The password used to authenticate with",
            "type": "string"
          },
          "login_port": {
            "description": "Port of the MySQL server. Requires login_host be defined as other then localhost if login_port is used",
            "type": "string"
          },
          "login_unix_socket": {
            "description": "The path to a Unix domain socket for local connections",
            "type": "string"
          },
          "login_user": {
            "description": "The username used to authenticate with",
            "type": "string"
          },
          "name": {
            "description": "name of the user (role) to add or remove",
            "type": "string"
          },
          "password": {
            "description": "set the user's password.",
            "type": "string"
          },
          "priv": {
            "description": "MySQL privileges string in the format: `db.table:priv1,p riv2'",
            "type": "string"
          },
          "sql_log_bin": {
            "description": "Whether binary logging should be enabled or disabled for the connection.",
            "type": "string"
          },
          "ssl_ca": {
            "description": "The path to a Certificate Authority (CA) certificate. This option, if used, must specify the same certificate as used by the server.",
            "type": "string"
          },
          "ssl_cert": {
            "description": "The path to a client public key certificate.",
            "type": "string"
          },
          "ssl_key": {
            "description": "The path to the client private key.",
            "type": "string"
          },
          "state": {
            "description": "Whether the user should exist.  When `absent', removes the user.",
            "type": "string"
          },
          "update_password": {
            "description": "`always' will update passwords if they differ. `on_create' will only set the password for newly created users.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "mysql_variables": {
        "type": "object",
        "description": "Manage MySQL global variables",
        "properties": {
          "config_file": {
            "description": "Specify a config file from which user and password are to be read",
            "type": "string"
          },
          "connect_timeout": {
            "description": "The connection timeout when connecting to the MySQL server.",
            "type": "string"
          },
          "login_host": {
            "description": "Host running the database",
            "type": "string"
          },
          "login_password": {
            "description": "The password used to authenticate with",
            "type": "string"
          },
          "login_port": {
            "description": "Port of the MySQL server. Requires login_host be defined as other then localhost if login_port is used",
            "type": "string"
          },
          "login_unix_socket": {
            "description": "The path to a Unix domain socket for local connections",
            "type": "string"
          },
          "login_user": {
            "description": "The username used to authenticate with",
            "type": "string"
          },
          "ssl_ca": {
            "description": "The path to a Certificate Authority (CA) certificate. This option, if used, must specify the same certificate as used by the server.",
            "type": "string"
          },
          "ssl_cert": {
            "description": "The path to a client public key certificate.",
            "type": "string"
          },
          "ssl_key": {
            "description": "The path to the client private key.",
            "type": "string"
          },
          "value": {
            "description": "If set, then sets variable value to this",
            "type": "string"
          },
          "variable": {
            "description": "Variable name to operate",
            "type": "string"
          }
        },
        "required": "variable"
      }
    },
    {
      "nagios": {
        "type": "object",
        "description": "Perform common tasks in Nagios related to downtime and notifications.",
        "properties": {
          "action": {
            "description": "Action to take. servicegroup options were added in 2.0. delete_downtime options were added in 2.2.",
            "type": "string"
          },
          "author": {
            "description": "Author to leave downtime comments as. Only usable with the `downtime' action.",
            "type": "string"
          },
          "cmdfile": {
            "description": "Path to the nagios `command file' (FIFO pipe). Only required if auto-detection fails.",
            "type": "string"
          },
          "command": {
            "description": "The raw command to send to nagios, which should not include the submitted time header or the line-feed *Required* option when using the `command' action.",
            "type": "string"
          },
          "comment": {
            "description": "Comment for `downtime' action.",
            "type": "string"
          },
          "host": {
            "description": "Host to operate on in Nagios.",
            "type": "string"
          },
          "minutes": {
            "description": "Minutes to schedule downtime for. Only usable with the `downtime' action.",
            "type": "string"
          },
          "servicegroup": {
            "description": "The Servicegroup we want to set downtimes/alerts for. *Required* option when using the `servicegroup _service_downtime ' amd `servicegro up_host_downtime' .",
            "type": "string"
          },
          "services": {
            "description": "What to manage downtime/alerts for. Separate multiple services with commas. `service' is an alias for `services'. *Required* option when using the `downtime', `enable_alerts', and `disable_alerts' actions.",
            "type": "string"
          }
        },
        "required": [
          "action",
          "command",
          "services"
        ]
      }
    },
    {
      "netapp_e_amg": {
        "type": "object",
        "description": "Create, Remove, and Update Asynchronous Mirror Groups",
        "properties": {
          "api_password": {
            "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "api_url": {
            "description": "The url to the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "api_username": {
            "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "interfaceType": {
            "description": "The intended protocol to use if both Fibre and iSCSI are available.",
            "type": "string"
          },
          "manualSync": {
            "description": "Setting this to true will cause other synchronization values to be ignored",
            "type": "string"
          },
          "name": {
            "description": "The name of the async array you wish to target, or create. If `state' is present and the name isn't found, it will attempt to create.",
            "type": "string"
          },
          "recoveryWarnThresholdMinutes": {
            "description": "Recovery point warning threshold (minutes). The user will be warned when the age of the last good failures point exceeds this value",
            "type": "string"
          },
          "repoUtilizationWarnThreshold": {
            "description": "Recovery point warning threshold",
            "type": "string"
          },
          "secondaryArrayId": {
            "description": "The ID of the secondary array to be used in mirroing process",
            "type": "string"
          },
          "ssid": {
            "description": "The ID of the primary storage array for the async mirror action",
            "type": "string"
          },
          "state": {
            "description": "A `state' of present will either create or update the async mirror group. A `state' of absent will remove the async mirror group.",
            "type": "string"
          },
          "syncIntervalMinutes": {
            "description": "The synchronization interval in minutes",
            "type": "string"
          },
          "syncWarnThresholdMinutes": {
            "description": "The threshold (in minutes) for notifying the user that periodic synchronization has taken too long to complete.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Should https certificates be validated?",
            "type": "string"
          }
        },
        "required": [
          "api_password",
          "api_url",
          "api_username",
          "name",
          "secondaryArrayId",
          "ssid",
          "state"
        ]
      }
    },
    {
      "netapp_e_amg_role": {
        "type": "object",
        "description": "Update the role of a storage array within an Asynchronous Mirror Group (AMG).",
        "properties": {
          "api_password": {
            "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "api_url": {
            "description": "The url to the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "api_username": {
            "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "force": {
            "description": "Whether to force the role reversal regardless of the online-state of the primary",
            "type": "string"
          },
          "noSync": {
            "description": "Whether to avoid synchronization prior to role reversal",
            "type": "string"
          },
          "role": {
            "description": "Whether the array should be the primary or secondary array for the AMG",
            "type": "string"
          },
          "ssid": {
            "description": "The ID of the primary storage array for the async mirror action",
            "type": "string"
          },
          "validate_certs": {
            "description": "Should https certificates be validated?",
            "type": "string"
          }
        },
        "required": [
          "api_password",
          "api_url",
          "api_username",
          "role",
          "ssid"
        ]
      }
    },
    {
      "netapp_e_amg_sync": {
        "type": "object",
        "description": "Conduct synchronization actions on asynchronous member groups.",
        "properties": {
          "api_password": {
            "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "api_url": {
            "description": "The url to the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "api_username": {
            "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "delete_recovery_point": {
            "description": "Indicates whether the failures point can be deleted on the secondary if necessary to achieve the synchronization. If true, and if the amount of unsynchronized data exceeds the CoW repository capacity on the secondary for any member volume, the last failures point will be deleted and synchronization will continue. If false, the synchronization will be suspended if the amount of unsynchronized data exceeds the CoW Repository capacity on the secondary and the failures point will be preserved. NOTE: This only has impact for newly launched syncs.",
            "type": "string"
          },
          "name": {
            "description": "The name of the async mirror group you wish to target",
            "type": "string"
          },
          "ssid": {
            "description": "The ID of the storage array containing the AMG you wish to target",
            "type": "string"
          },
          "state": {
            "description": "The synchronization action you'd like to take. If `running' then it will begin syncing if there is no active sync or will resume a suspended sync. If there is already a sync in progress, it will return with an OK status. If `suspended' it will suspend any ongoing sync action, but return OK if there is no active sync or if the sync is already suspended",
            "type": "string"
          },
          "validate_certs": {
            "description": "Should https certificates be validated?",
            "type": "string"
          }
        },
        "required": [
          "api_password",
          "api_url",
          "api_username",
          "name",
          "state"
        ]
      }
    },
    {
      "netapp_e_auth": {
        "type": "object",
        "description": "Sets or updates the password for a storage array.",
        "properties": {
          "api_password": {
            "description": "The password used to authenticate against the API This can optionally be set via an environment variable, API_PASSWORD",
            "type": "string"
          },
          "api_url": {
            "description": "The full API url. Example: http://ENDPOINT:8 080/devmgr/v2 This can optionally be set via an environment variable, API_URL",
            "type": "string"
          },
          "api_username": {
            "description": "The username used to authenticate against the API This can optionally be set via an environment variable, API_USERNAME",
            "type": "string"
          },
          "current_password": {
            "description": "The current admin password. This is not required if the password hasn't been set before.",
            "type": "string"
          },
          "name": {
            "description": "The name of the storage array. Note that if more than one storage array with this name is detected, the task will fail and you'll have to use the ID instead.",
            "type": "string"
          },
          "new_password": {
            "description": "The password you would like to set. Cannot be more than 30 characters.",
            "type": "string"
          },
          "set_admin": {
            "description": "Boolean value on whether to update the admin password. If set to false then the RO account is updated.",
            "type": "string"
          },
          "ssid": {
            "description": "the identifier of the storage array in the Web Services Proxy.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Should https certificates be validated?",
            "type": "string"
          }
        },
        "required": "new_password"
      }
    },
    {
      "netapp_e_facts": {
        "type": "object",
        "description": "Get facts about NetApp E-Series arrays",
        "properties": {
          "api_password": {
            "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "api_url": {
            "description": "The url to the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "api_username": {
            "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "ssid": {
            "description": "The ID of the array to manage. This value must be unique for each array.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Should https certificates be validated?",
            "type": "string"
          }
        },
        "required": [
          "api_password",
          "api_url",
          "api_username",
          "ssid"
        ]
      }
    },
    {
      "netapp_e_flashcache": {
        "type": "object",
        "description": "Manage NetApp SSD caches",
        "properties": {
          "api_password": {
            "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "api_url": {
            "description": "The url to the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "api_username": {
            "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "cache_size_min": {
            "description": "The minimum size (in size_units) of the ssd cache. The cache will be expanded if this exceeds the current size of the cache.",
            "type": "string"
          },
          "disk_count": {
            "description": "The minimum number of disks to use for building the cache. The cache will be expanded if this number exceeds the number of disks already in place",
            "type": "string"
          },
          "io_type": {
            "description": "The type of workload to optimize the cache for.",
            "type": "string"
          },
          "name": {
            "description": "The name of the SSD cache to manage",
            "type": "string"
          },
          "size_unit": {
            "description": "The unit to be applied to size arguments",
            "type": "string"
          },
          "ssid": {
            "description": "The ID of the array to manage (as configured on the web services proxy).",
            "type": "string"
          },
          "state": {
            "description": "Whether the specified SSD cache should exist or not.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Should https certificates be validated?",
            "type": "string"
          }
        },
        "required": [
          "api_password",
          "api_url",
          "api_username",
          "name",
          "ssid",
          "state"
        ]
      }
    },
    {
      "netapp_e_host": {
        "type": "object",
        "description": "manage eseries hosts",
        "properties": {
          "api_password": {
            "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "api_url": {
            "description": "The url to the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "api_username": {
            "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "group": {
            "description": "the group you want the host to be a member of",
            "type": "string"
          },
          "host_type_index": {
            "description": "The index that maps to host type you wish to create. It is recommended to use the [netapp_e_facts] module to gather this information. Alternatively you can use the WSP portal to retrieve the information.",
            "type": "string"
          },
          "name": {
            "description": "If the host doesnt yet exist, the label to assign at creation time. If the hosts already exists, this is what is used to identify the host to apply any desired changes",
            "type": "string"
          },
          "ports": {
            "description": "a list of of dictionaries of host ports you wish to associate with the newly created host",
            "type": "string"
          },
          "ssid": {
            "description": "the id of the storage array you wish to act against",
            "type": "string"
          },
          "validate_certs": {
            "description": "Should https certificates be validated?",
            "type": "string"
          }
        },
        "required": [
          "api_password",
          "api_url",
          "api_username",
          "host_type_index",
          "name",
          "ssid"
        ]
      }
    },
    {
      "netapp_e_hostgroup": {
        "type": "object",
        "description": "Manage NetApp Storage Array Host Groups",
        "properties": {
          "api_password": {
            "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "api_url": {
            "description": "The url to the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "api_username": {
            "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "hosts": {
            "description": "a list of host names/labels to add to the group",
            "type": "string"
          },
          "id": {
            "description": "The id number of the host group to manage. Either this or `name' must be supplied.",
            "type": "string"
          },
          "name": {
            "description": "The name of the host group to manage. Either this or `id_num' must be supplied.",
            "type": "string"
          },
          "new_name": {
            "description": "specify this when you need to update the name of a host group",
            "type": "string"
          },
          "ssid": {
            "description": "The ID of the array to manage (as configured on the web services proxy).",
            "type": "string"
          },
          "state": {
            "description": "Whether the specified host group should exist or not.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Should https certificates be validated?",
            "type": "string"
          }
        },
        "required": [
          "api_password",
          "api_url",
          "api_username",
          "ssid",
          "state"
        ]
      }
    },
    {
      "netapp_e_lun_mapping": {
        "type": "object",
        "description": "Create or Remove LUN Mappings",
        "properties": {
          "api_password": {
            "description": "The password used to authenticate against the API. This can optionally be set via an environment variable, API_PASSWORD",
            "type": "string"
          },
          "api_url": {
            "description": "The full API url. Example: http://ENDPOINT:8 080/devmgr/v2 This can optionally be set via an environment variable, API_URL",
            "type": "string"
          },
          "api_username": {
            "description": "The username used to authenticate against the API. This can optionally be set via an environment variable, API_USERNAME",
            "type": "string"
          },
          "lun": {
            "description": "The LUN number you wish to give the mapping If the supplied `volume_name' is associated with a different LUN, it will be updated to what is supplied here.",
            "type": "string"
          },
          "ssid": {
            "description": "The storage system array identifier.",
            "type": "string"
          },
          "state": {
            "description": "Present will ensure the mapping exists, absent will remove the mapping. All parameters `lun', `target', `target_type' and `volume_name' must still be supplied.",
            "type": "string"
          },
          "target": {
            "description": "The name of host or hostgroup you wish to assign to the mapping If omitted, the default hostgroup is used. If the supplied `volume_name' is associated with a different target, it will be updated to what is supplied here.",
            "type": "string"
          },
          "target_type": {
            "description": "Whether the target is a host or group. Required if supplying an explicit target.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Should https certificates be validated?",
            "type": "string"
          },
          "volume_name": {
            "description": "The name of the volume you wish to include in the mapping.",
            "type": "string"
          }
        },
        "required": [
          "state",
          "volume_name"
        ]
      }
    },
    {
      "netapp_e_snapshot_group": {
        "type": "object",
        "description": "Manage snapshot groups",
        "properties": {
          "api_password": {
            "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "api_url": {
            "description": "The url to the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "api_username": {
            "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "base_volume_name": {
            "description": "The name of the base volume or thin volume to use as the base for the new snapshot group. If a snapshot group with an identical `name' already exists but with a different base volume an error will be returned.",
            "type": "string"
          },
          "delete_limit": {
            "description": "The automatic deletion indicator. If non-zero, the oldest snapshot image will be automatically deleted when creating a new snapshot image to keep the total number of snapshot images limited to the number specified. This value is overridden by the consistency group setting if this snapshot group is associated with a consistency group.",
            "type": "string"
          },
          "full_policy": {
            "description": "The behavior on when the data repository becomes full. This value is overridden by consistency group setting if this snapshot group is associated with a consistency group",
            "type": "string"
          },
          "name": {
            "description": "The name to give the snapshot group",
            "type": "string"
          },
          "repo_pct": {
            "description": "The size of the repository in relation to the size of the base volume",
            "type": "string"
          },
          "rollback_priority": {
            "description": "The importance of the rollback operation. This value is overridden by consistency group setting if this snapshot group is associated with a consistency group",
            "type": "string"
          },
          "state": {
            "description": "Whether to ensure the group is present or absent.",
            "type": "string"
          },
          "storage_pool_name": {
            "description": "The name of the storage pool on which to allocate the repository volume.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Should https certificates be validated?",
            "type": "string"
          },
          "warning_threshold": {
            "description": "The repository utilization warning threshold, as a percentage of the repository volume capacity.",
            "type": "string"
          }
        },
        "required": [
          "api_password",
          "api_url",
          "api_username",
          "base_volume_name",
          "name",
          "state",
          "storage_pool_name"
        ]
      }
    },
    {
      "netapp_e_snapshot_images": {
        "type": "object",
        "description": "Create and delete snapshot images",
        "properties": {
          "api_password": {
            "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "api_url": {
            "description": "The url to the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "api_username": {
            "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "snapshot_group": {
            "description": "The name of the snapshot group in which you want to create a snapshot image.",
            "type": "string"
          },
          "state": {
            "description": "Whether a new snapshot image should be created or oldest be deleted.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Should https certificates be validated?",
            "type": "string"
          }
        },
        "required": [
          "api_password",
          "api_url",
          "api_username",
          "snapshot_group",
          "state"
        ]
      }
    },
    {
      "netapp_e_snapshot_volume": {
        "type": "object",
        "description": "Manage E/EF-Series snapshot volumes.",
        "properties": {
          "api_password": {
            "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "api_url": {
            "description": "The url to the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "api_username": {
            "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "full_threshold": {
            "description": "The repository utilization warning threshold percentage",
            "type": "string"
          },
          "name": {
            "description": "The name you wish to give the snapshot volume",
            "type": "string"
          },
          "repo_percentage": {
            "description": "The size of the view in relation to the size of the base volume",
            "type": "string"
          },
          "snapshot_image_id": {
            "description": "The identifier of the snapshot image used to create the new snapshot volume. Note: You'll likely want to use the [netapp_e_facts] module to find the ID of the image you want.",
            "type": "string"
          },
          "ssid": {
            "description": "storage array ID",
            "type": "string"
          },
          "state": {
            "description": "Whether to create or remove the snapshot volume",
            "type": "string"
          },
          "storage_pool_name": {
            "description": "Name of the storage pool on which to allocate the repository volume.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Should https certificates be validated?",
            "type": "string"
          },
          "view_mode": {
            "description": "The snapshot volume access mode",
            "type": "string"
          }
        },
        "required": [
          "api_password",
          "api_url",
          "api_username",
          "name",
          "snapshot_image_id",
          "ssid",
          "state",
          "storage_pool_name",
          "view_mode"
        ]
      }
    },
    {
      "netapp_e_storage_system": {
        "type": "object",
        "description": "Add/remove arrays from the Web Services Proxy",
        "properties": {
          "api_password": {
            "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "api_url": {
            "description": "The url to the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "api_username": {
            "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "array_password": {
            "description": "The management password of the array to manage, if set.",
            "type": "string"
          },
          "array_wwn": {
            "description": "The WWN of the array to manage. Only necessary if in-band managing multiple arrays on the same agent host. Mutually exclusive of cont roller_addresses parameter.",
            "type": "string"
          },
          "controller_addresses": {
            "description": "The list addresses for the out-of-band management adapter or the agent host. Mutually exclusive of array_wwn parameter.",
            "type": "string"
          },
          "enable_trace": {
            "description": "Enable trace logging for SYMbol calls to the storage system.",
            "type": "string"
          },
          "meta_tags": {
            "description": "Optional meta tags to associate to this storage system",
            "type": "string"
          },
          "ssid": {
            "description": "The ID of the array to manage. This value must be unique for each array.",
            "type": "string"
          },
          "state": {
            "description": "Whether the specified array should be configured on the Web Services Proxy or not.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Should https certificates be validated?",
            "type": "string"
          }
        },
        "required": [
          "api_password",
          "api_url",
          "api_username",
          "controller_addresses",
          "ssid",
          "state"
        ]
      }
    },
    {
      "netapp_e_storagepool": {
        "type": "object",
        "description": "Manage disk groups and disk pools",
        "properties": {
          "api_password": {
            "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "api_url": {
            "description": "The url to the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "api_username": {
            "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "criteria_drive_count": {
            "description": "The number of disks to use for building the storage pool. The pool will be expanded if this number exceeds the number of disks already in place",
            "type": "string"
          },
          "criteria_drive_interface_type": {
            "description": "The interface type to use when selecting drives for the storage pool (no value means all interface types will be considered)",
            "type": "string"
          },
          "criteria_drive_min_size": {
            "description": "The minimum individual drive size (in size_unit) to consider when choosing drives for the storage pool.",
            "type": "string"
          },
          "criteria_drive_require_fde": {
            "description": "Whether full disk encryption ability is required for drives to be added to the storage pool",
            "type": "string"
          },
          "criteria_drive_type": {
            "description": "The type of disk (hdd or ssd) to use when searching for candidates to use.",
            "type": "string"
          },
          "criteria_min_usable_capacity": {
            "description": "The minimum size of the storage pool (in size_unit). The pool will be expanded if this value exceeds itscurrent size.",
            "type": "string"
          },
          "criteria_size_unit": {
            "description": "The unit used to interpret size parameters",
            "type": "string"
          },
          "erase_secured_drives": {
            "description": "Whether to erase secured disks before adding to storage pool",
            "type": "string"
          },
          "name": {
            "description": "The name of the storage pool to manage",
            "type": "string"
          },
          "raid_level": {
            "description": "Only required when the requested state is 'present'.  The RAID level of the storage pool to be created.",
            "type": "string"
          },
          "remove_volumes": {
            "description": "Prior to removing a storage pool, delete all volumes in the pool.",
            "type": "string"
          },
          "reserve_drive_count": {
            "description": "Set the number of drives reserved by the storage pool for reconstruction operations. Only valide on raid disk pools.",
            "type": "string"
          },
          "secure_pool": {
            "description": "Whether to convert to a secure storage pool. Will only work if all drives in the pool are security capable.",
            "type": "string"
          },
          "ssid": {
            "description": "The ID of the array to manage (as configured on the web services proxy).",
            "type": "string"
          },
          "state": {
            "description": "Whether the specified storage pool should exist or not. Note that removing a storage pool currently requires the removal of all defined volumes first.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Should https certificates be validated?",
            "type": "string"
          }
        },
        "required": [
          "api_password",
          "api_url",
          "api_username",
          "name",
          "raid_level",
          "ssid",
          "state"
        ]
      }
    },
    {
      "netapp_e_volume": {
        "type": "object",
        "description": "Manage storage volumes (standard and thin)",
        "properties": {
          "api_password": {
            "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "api_url": {
            "description": "The url to the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "api_username": {
            "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "data_assurance_enabled": {
            "description": "If data assurance should be enabled for the volume",
            "type": "string"
          },
          "name": {
            "description": "The name of the volume to manage",
            "type": "string"
          },
          "segment_size_kb": {
            "description": "The segment size of the new volume",
            "type": "string"
          },
          "size": {
            "description": "Required only when state = 'present'.  The size of the volume in (size_unit).",
            "type": "string"
          },
          "size_unit": {
            "description": "The unit used to interpret the size parameter",
            "type": "string"
          },
          "ssd_cache_enabled": {
            "description": "Whether an existing SSD cache should be enabled on the volume (fails if no SSD cache defined)",
            "type": "string"
          },
          "ssid": {
            "description": "The ID of the array to manage (as configured on the web services proxy).",
            "type": "string"
          },
          "state": {
            "description": "Whether the specified volume should exist or not.",
            "type": "string"
          },
          "storage_pool_name": {
            "description": "Required only when requested state is 'present'. The name of the storage pool the volume should exist on.",
            "type": "string"
          },
          "thin_provision": {
            "description": "Whether the volume should be thin provisioned. Thin volumes can only be created on disk pools (raidDiskPool).",
            "type": "string"
          },
          "thin_volume_max_repo_size": {
            "description": "Maximum size that the thin volume repository volume will automatically expand to",
            "type": "string"
          },
          "thin_volume_repo_size": {
            "description": "Initial size of the thin volume repository volume (in size_unit)",
            "type": "string"
          },
          "validate_certs": {
            "description": "Should https certificates be validated?",
            "type": "string"
          }
        },
        "required": [
          "api_password",
          "api_url",
          "api_username",
          "name",
          "size",
          "ssid",
          "state",
          "storage_pool_name",
          "thin_volume_repo_size"
        ]
      }
    },
    {
      "netapp_e_volume_copy": {
        "type": "object",
        "description": "Create volume copy pairs",
        "properties": {
          "api_password": {
            "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "api_url": {
            "description": "The url to the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "api_username": {
            "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API.",
            "type": "string"
          },
          "create_copy_pair_if_does_not_exist": {
            "description": "Defines if a copy pair will be created if it does not exist. If set to True de stination_volume_ id and source_volume_id are required.",
            "type": "string"
          },
          "destination_volume_id": {
            "description": "The the id of the volume copy destination. If used, must be paired with source_volume_id Mutually exclusive with vo lume_copy_pair_id , and search_volume_id",
            "type": "string"
          },
          "search_volume_id": {
            "description": "Searches for all valid potential target and source volumes that could be used in a copy_pair Mutually exclusive with vo lume_copy_pair_id , destination_vol ume_id and source_volume_id",
            "type": "string"
          },
          "source_volume_id": {
            "description": "The the id of the volume copy source. If used, must be paired with destination_ volume_id Mutually exclusive with vo lume_copy_pair_id , and search_volume_id",
            "type": "string"
          },
          "start_stop_copy": {
            "description": "starts a re-copy or stops a copy in progress Note: If you stop the initial file copy before it it done the copy pair will be destroyed Requires volume_c opy_pair_id",
            "type": "string"
          },
          "state": {
            "description": "Whether the specified volume copy pair should exist or not.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Should https certificates be validated?",
            "type": "string"
          },
          "volume_copy_pair_id": {
            "description": "The the id of a given volume copy pair Mutually exclusive with de stination_volume_ id, source_volume_id, and search_volume_id Can use to delete or check presence of volume pairs Must specify this or (destination_v olume_id and source_volume_id)",
            "type": "string"
          }
        },
        "required": [
          "api_password",
          "api_url",
          "api_username",
          "state"
        ]
      }
    },
    {
      "netconf_config": {
        "type": "object",
        "description": "netconf device configuration",
        "properties": {
          "host": {
            "description": "the hostname or ip address of the netconf device",
            "type": "string"
          },
          "hostkey_verify": {
            "description": "if true, the ssh host key of the device must match a ssh key present on the host if false, the ssh host key of the device is not checked",
            "type": "string"
          },
          "password": {
            "description": "password of the user to authenticate with",
            "type": "string"
          },
          "port": {
            "description": "the netconf port",
            "type": "string"
          },
          "username": {
            "description": "the username to authenticate with",
            "type": "string"
          },
          "xml": {
            "description": "the XML content to send to the device",
            "type": "string"
          }
        },
        "required": [
          "host",
          "password",
          "username",
          "xml"
        ]
      }
    },
    {
      "netscaler": {
        "type": "object",
        "description": "Manages Citrix NetScaler entities",
        "properties": {
          "action": {
            "description": "the action you want to perform on the entity",
            "type": "string"
          },
          "name": {
            "description": "name of the entity",
            "type": "string"
          },
          "nsc_host": {
            "description": "hostname or ip of your netscaler",
            "type": "string"
          },
          "nsc_protocol": {
            "description": "protocol used to access netscaler",
            "type": "string"
          },
          "password": {
            "description": "password",
            "type": "string"
          },
          "type": {
            "description": "type of the entity",
            "type": "string"
          },
          "user": {
            "description": "username",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates for the target url will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "nsc_host",
          "password",
          "user"
        ]
      }
    },
    {
      "newrelic_deployment": {
        "type": "object",
        "description": "Notify newrelic about app deployments",
        "properties": {
          "app_name": {
            "description": "(one of app_name or application_id are required) The value of app_name in the newrelic.yml file used by the application",
            "type": "string"
          },
          "application_id": {
            "description": "(one of app_name or application_id are required) The application id, found in the URL when viewing the application in RPM",
            "type": "string"
          },
          "appname": {
            "description": "Name of the application",
            "type": "string"
          },
          "changelog": {
            "description": "A list of changes for this deployment",
            "type": "string"
          },
          "description": {
            "description": "Text annotation for the deployment - notes for you",
            "type": "string"
          },
          "environment": {
            "description": "The environment for this deployment",
            "type": "string"
          },
          "revision": {
            "description": "A revision number (e.g., git commit SHA)",
            "type": "string"
          },
          "token": {
            "description": "API token, to place in the x-api-key header.",
            "type": "string"
          },
          "user": {
            "description": "The name of the user/process that triggered this deployment",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": "token"
      }
    },
    {
      "nexmo": {
        "type": "object",
        "description": "Send a SMS via nexmo",
        "properties": {
          "api_key": {
            "description": "Nexmo API Key",
            "type": "string"
          },
          "api_secret": {
            "description": "Nexmo API Secret",
            "type": "string"
          },
          "dest": {
            "description": "Phone number(s) to send SMS message to",
            "type": "string"
          },
          "msg": {
            "description": "Message to text to send. Messages longer than 160 characters will be split into multiple messages",
            "type": "string"
          },
          "src": {
            "description": "Nexmo Number to send from",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": [
          "api_key",
          "api_secret",
          "dest",
          "msg",
          "src"
        ]
      }
    },
    {
      "nmcli": {
        "type": "object",
        "description": "Manage Networking",
        "properties": {
          "ageingtime": {
            "description": "This is only used with bridge - [ageing-time <0-1000000>] the Ethernet MAC address aging time, in seconds",
            "type": "string"
          },
          "arp_interval": {
            "description": "This is only used with bond - ARP interval",
            "type": "string"
          },
          "arp_ip_target": {
            "description": "This is only used with bond - ARP IP target",
            "type": "string"
          },
          "autoconnect": {
            "description": "Whether the connection should start on boot. Whether the connection profile can be automatically activated",
            "type": "string"
          },
          "conn_name": {
            "description": "Where conn_name will be the name used to call the connection. when not provided a default name is generated: <type> [-<ifname>][-<num >]",
            "type": "string"
          },
          "dns4": {
            "description": "A list of upto 3 dns servers, ipv4 format e.g. To add two IPv4 DNS server addresses: [\"192.0.2.53\", \"198.51.100.53\"]",
            "type": "string"
          },
          "dns6": {
            "description": "A list of upto 3 dns servers, ipv6 format e.g. To add two IPv6 DNS server addresses: [\"2001 :4860:4860::8888  2001:4860:4860::8 844\"]",
            "type": "string"
          },
          "downdelay": {
            "description": "This is only used with bond - downdelay",
            "type": "string"
          },
          "egress": {
            "description": "This is only used with VLAN - VLAN egress priority mapping",
            "type": "string"
          },
          "flags": {
            "description": "This is only used with VLAN - flags",
            "type": "string"
          },
          "forwarddelay": {
            "description": "This is only used with bridge - [forward-delay <2-30>] STP forwarding delay, in seconds",
            "type": "string"
          },
          "gw4": {
            "description": "The IPv4 gateway for this interface using this format ie: \"192.0.2.1\"",
            "type": "string"
          },
          "gw6": {
            "description": "The IPv6 gateway for this interface using this format ie: \"2001:db8::1\"",
            "type": "string"
          },
          "hairpin": {
            "description": "This is only used with 'bridge-slave' - 'hairpin mode' for the slave, which allows frames to be sent back out through the slave the frame was received on.",
            "type": "string"
          },
          "hellotime": {
            "description": "This is only used with bridge - [hello-time <1-10>] STP hello time, in seconds",
            "type": "string"
          },
          "ifname": {
            "description": "Where IFNAME will be the what we call the interface name. interface to bind the connection to. The connection will only be applicable to this interface name. A special value of \"*\" can be used for interface- independent connections. The ifname argument is mandatory for all connection types except bond, team, bridge and vlan.",
            "type": "string"
          },
          "ingress": {
            "description": "This is only used with VLAN - VLAN ingress priority mapping",
            "type": "string"
          },
          "ip4": {
            "description": "The IPv4 address to this interface using this format ie: \"192.0.2.24/24\"",
            "type": "string"
          },
          "ip6": {
            "description": "The IPv6 address to this interface using this format ie: \"abbe::cafe\"",
            "type": "string"
          },
          "mac": {
            "description": "This is only used with bridge - MAC address of the bridge (note: this requires a recent kernel feature, originally introduced in 3.15 upstream kernel)",
            "type": "string"
          },
          "master": {
            "description": "master <master (ifname, or connection UUID or conn_name) of bridge, team, bond master connection profile.",
            "type": "string"
          },
          "maxage": {
            "description": "This is only used with bridge - [max-age <6-42>] STP maximum message age, in seconds",
            "type": "string"
          },
          "miimon": {
            "description": "This is only used with bond - miimon",
            "type": "string"
          },
          "mode": {
            "description": "This is the type of device or network connection that you wish to create for a bond, team or bridge.",
            "type": "string"
          },
          "mtu": {
            "description": "The connection MTU, e.g. 9000. This can't be applied when creating the interface and is done once the interface has been created. Can be used when modifying Team, VLAN, Ethernet (Future plans to implement wifi, pppoe, infiniband)",
            "type": "string"
          },
          "path_cost": {
            "description": "This is only used with 'bridge-slave' - [<1-65535>] - STP port cost for destinations via this slave",
            "type": "string"
          },
          "primary": {
            "description": "This is only used with bond and is the primary interface name (for \"active- backup\" mode), this is the usually the 'ifname'",
            "type": "string"
          },
          "priority": {
            "description": "This is only used with 'bridge' - sets STP priority",
            "type": "string"
          },
          "slavepriority": {
            "description": "This is only used with 'bridge-slave' - [<0-63>] - STP priority of this slave",
            "type": "string"
          },
          "state": {
            "description": "Whether the device should exist or not, taking action if the state is different from what is stated.",
            "type": "string"
          },
          "stp": {
            "description": "This is only used with bridge and controls whether Spanning Tree Protocol (STP) is enabled for this bridge",
            "type": "string"
          },
          "type": {
            "description": "This is the type of device or network connection that you wish to create.",
            "type": "string"
          },
          "updelay": {
            "description": "This is only used with bond - updelay",
            "type": "string"
          },
          "vlandev": {
            "description": "This is only used with VLAN - parent device this VLAN is on, can use ifname",
            "type": "string"
          },
          "vlanid": {
            "description": "This is only used with VLAN - VLAN ID in range <0-4095>",
            "type": "string"
          }
        },
        "required": [
          "conn_name",
          "state"
        ]
      }
    },
    {
      "npm": {
        "type": "object",
        "description": "Manage node.js packages with npm",
        "properties": {
          "executable": {
            "description": "The executable location for npm. This is useful if you are using a version manager, such as nvm",
            "type": "string"
          },
          "global": {
            "description": "Install the node.js library globally",
            "type": "string"
          },
          "ignore_scripts": {
            "description": "Use the --ignore-scripts flag when installing.",
            "type": "string"
          },
          "name": {
            "description": "The name of a node.js library to install",
            "type": "string"
          },
          "path": {
            "description": "The base path where to install the node.js libraries",
            "type": "string"
          },
          "production": {
            "description": "Install dependencies in production mode, excluding devDependencies",
            "type": "string"
          },
          "registry": {
            "description": "The registry to install modules from.",
            "type": "string"
          },
          "state": {
            "description": "The state of the node.js library",
            "type": "string"
          },
          "version": {
            "description": "The version to be installed",
            "type": "string"
          }
        }
      }
    },
    {
      "nxos_aaa_server": {
        "type": "object",
        "description": "Manages AAA server global configuration.",
        "properties": {
          "deadtime": {
            "description": "Duration for which a non-reachable AAA server is skipped, in minutes. Range is 1-1440. Device default is 0.",
            "type": "string"
          },
          "directed_request": {
            "description": "Enables direct authentication requests to AAA server. Device default is disabled.",
            "type": "string"
          },
          "encrypt_type": {
            "description": "The state of encryption applied to the entered global key. O clear text, 7 encrypted. Type-6 encryption is not supported.",
            "type": "string"
          },
          "global_key": {
            "description": "Global AAA shared secret.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "server_timeout": {
            "description": "Global AAA server timeout period, in seconds. Range is 1-60. Device default is 5.",
            "type": "string"
          },
          "server_type": {
            "description": "The server type is either radius or tacacs.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Manage the state of the resource.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "server_type",
          "state",
          "transport"
        ]
      }
    },
    {
      "nxos_aaa_server_host": {
        "type": "object",
        "description": "Manages AAA server host-specific configuration.",
        "properties": {
          "acct_port": {
            "description": "Alternate UDP port for RADIUS accounting.",
            "type": "string"
          },
          "address": {
            "description": "Address or name of the radius or tacacs host.",
            "type": "string"
          },
          "auth_port": {
            "description": "Alternate UDP port for RADIUS authentication.",
            "type": "string"
          },
          "encrypt_type": {
            "description": "The state of encryption applied to the entered key. O for clear text, 7 for encrypted. Type-6 encryption is not supported.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "host_timeout": {
            "description": "Timeout period for specified host, in seconds. Range is 1-60.",
            "type": "string"
          },
          "key": {
            "description": "Shared secret for the specified host.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "server_type": {
            "description": "The server type is either radius or tacacs.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Manage the state of the resource.",
            "type": "string"
          },
          "tacacs_port": {
            "description": "Alternate TCP port TACACS Server.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "address",
          "host",
          "server_type",
          "transport"
        ]
      }
    },
    {
      "nxos_acl": {
        "type": "object",
        "description": "Manages access list entries for ACLs.",
        "properties": {
          "ack": {
            "description": "Match on the ACK bit.",
            "type": "string"
          },
          "action": {
            "description": "Action of the ACE.",
            "type": "string"
          },
          "dest": {
            "description": "Destination ip and mask using IP/MASK notation and supports the keyword 'any'.",
            "type": "string"
          },
          "dest_port1": {
            "description": "Port/protocol and also first (lower) port when using range operand.",
            "type": "string"
          },
          "dest_port2": {
            "description": "Second (end) port when using range operand.",
            "type": "string"
          },
          "dest_port_op": {
            "description": "Destination port operands such as eq, neq, gt, lt, range.",
            "type": "string"
          },
          "dscp": {
            "description": "Match packets with given dscp value.",
            "type": "string"
          },
          "established": {
            "description": "Match established connections.",
            "type": "string"
          },
          "fin": {
            "description": "Match on the FIN bit.",
            "type": "string"
          },
          "fragments": {
            "description": "Check non-initial fragments.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "log": {
            "description": "Log matches against this entry.",
            "type": "string"
          },
          "name": {
            "description": "Case sensitive name of the access list (ACL).",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "precedence": {
            "description": "Match packets with given precedence.",
            "type": "string"
          },
          "proto": {
            "description": "Port number or protocol (as supported by the switch).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "psh": {
            "description": "Match on the PSH bit.",
            "type": "string"
          },
          "remark": {
            "description": "If action is set to remark, this is the description.",
            "type": "string"
          },
          "rst": {
            "description": "Match on the RST bit.",
            "type": "string"
          },
          "seq": {
            "description": "Sequence number of the entry (ACE).",
            "type": "string"
          },
          "src": {
            "description": "Source ip and mask using IP/MASK notation and supports keyword 'any'.",
            "type": "string"
          },
          "src_port1": {
            "description": "Port/protocol and also first (lower) port when using range operand.",
            "type": "string"
          },
          "src_port2": {
            "description": "Second (end) port when using range operand.",
            "type": "string"
          },
          "src_port_op": {
            "description": "Source port operands such as eq, neq, gt, lt, range.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Specify desired state of the resource.",
            "type": "string"
          },
          "syn": {
            "description": "Match on the SYN bit.",
            "type": "string"
          },
          "time-range": {
            "description": "Name of time-range to apply.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "urg": {
            "description": "Match on the URG bit.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "name",
          "transport"
        ]
      }
    },
    {
      "nxos_acl_interface": {
        "type": "object",
        "description": "Manages applying ACLs to interfaces.",
        "properties": {
          "direction": {
            "description": "Direction ACL to be applied in on the interface.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "interface": {
            "description": "Full name of interface, e.g. `Ethernet1/1'.",
            "type": "string"
          },
          "name": {
            "description": "Case sensitive name of the access list (ACL).",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Specify desired state of the resource.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "direction",
          "host",
          "interface",
          "name",
          "transport"
        ]
      }
    },
    {
      "nxos_bgp": {
        "type": "object",
        "description": "Manages BGP configuration.",
        "properties": {
          "asn": {
            "description": "BGP autonomous system number. Valid values are String, Integer in ASPLAIN or ASDOT notation.",
            "type": "string"
          },
          "bestpath_always_compare_med": {
            "description": "Enable/Disable MED comparison on paths from different autonomous systems.",
            "type": "string"
          },
          "bestpath_aspath_multipath_relax": {
            "description": "Enable/Disable load sharing across the providers with different (but equal- length) AS paths.",
            "type": "string"
          },
          "bestpath_compare_routerid": {
            "description": "Enable/Disable comparison of router IDs for identical eBGP paths.",
            "type": "string"
          },
          "bestpath_cost_community_ignore": {
            "description": "Enable/Disable Ignores the cost community for BGP best-path calculations.",
            "type": "string"
          },
          "bestpath_med_confed": {
            "description": "Enable/Disable enforcement of bestpath to do a MED comparison only between paths originated within a confederation.",
            "type": "string"
          },
          "bestpath_med_missing_as_worst": {
            "description": "Enable/Disable assigns the value of infinity to received routes that do not carry the MED attribute, making these routes the least desirable.",
            "type": "string"
          },
          "bestpath_med_non_deterministic": {
            "description": "Enable/Disable deterministic selection of the best MED pat from among the paths from the same autonomous system.",
            "type": "string"
          },
          "cluster_id": {
            "description": "Route Reflector Cluster-ID.",
            "type": "string"
          },
          "confederation_id": {
            "description": "Routing domain confederation AS.",
            "type": "string"
          },
          "confederation_peers": {
            "description": "AS confederation parameters.",
            "type": "string"
          },
          "disable_policy_batching": {
            "description": "Enable/Disable the batching evaluation of prefix advertisement to all peers.",
            "type": "string"
          },
          "disable_policy_batching_ipv4_prefix_list": {
            "description": "Enable/Disable the batching evaluation of prefix advertisements to all peers with prefix list.",
            "type": "string"
          },
          "disable_policy_batching_ipv6_prefix_list": {
            "description": "Enable/Disable the batching evaluation of prefix advertisements to all peers with prefix list.",
            "type": "string"
          },
          "enforce_first_as": {
            "description": "Enable/Disable enforces the neighbor autonomous system to be the first AS number listed in the AS path attribute for eBGP. On NX- OS, this property is only supported in the global BGP context.",
            "type": "string"
          },
          "event_history_cli": {
            "description": "Enable/Disable cli event history buffer.",
            "type": "string"
          },
          "event_history_detail": {
            "description": "Enable/Disable detail event history buffer.",
            "type": "string"
          },
          "event_history_events": {
            "description": "Enable/Disable event history buffer.",
            "type": "string"
          },
          "event_history_periodic": {
            "description": "Enable/Disable periodic event history buffer.",
            "type": "string"
          },
          "fast_external_fallover": {
            "description": "Enable/Disable immediately reset the session if the link to a directly connected BGP peer goes down. Only supported in the global BGP context.",
            "type": "string"
          },
          "flush_routes": {
            "description": "Enable/Disable flush routes in RIB upon controlled restart. On NX- OS, this property is only supported in the global BGP context.",
            "type": "string"
          },
          "graceful_restart": {
            "description": "Enable/Disable graceful restart.",
            "type": "string"
          },
          "graceful_restart_helper": {
            "description": "Enable/Disable graceful restart helper mode.",
            "type": "string"
          },
          "graceful_restart_timers_restart": {
            "description": "Set maximum time for a restart sent to the BGP peer.",
            "type": "string"
          },
          "graceful_restart_timers_stalepath_time": {
            "description": "Set maximum time that BGP keeps the stale routes from the restarting BGP peer.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "isolate": {
            "description": "Enable/Disable isolate this router from BGP perspective.",
            "type": "string"
          },
          "local_as": {
            "description": "Local AS number to be used within a VRF instance.",
            "type": "string"
          },
          "log_neighbor_changes": {
            "description": "Enable/Disable message logging for neighbor up/down event.",
            "type": "string"
          },
          "maxas_limit": {
            "description": "Specify Maximum number of AS numbers allowed in the AS-path attribute. Valid values are between 1 and 512.",
            "type": "string"
          },
          "neighbor_down_fib_accelerate": {
            "description": "Enable/Disable handle BGP neighbor down event, due to various reasons.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "reconnect_interval": {
            "description": "The BGP reconnection interval for dropped sessions. Valid values are between 1 and 60.",
            "type": "string"
          },
          "router_id": {
            "description": "Router Identifier (ID) of the BGP router VRF instance.",
            "type": "string"
          },
          "shutdown": {
            "description": "Administratively shutdown the BGP protocol.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Determines whether the config should be present or not on the device.",
            "type": "string"
          },
          "suppress_fib_pending": {
            "description": "Enable/Disable advertise only routes programmed in hardware to peers.",
            "type": "string"
          },
          "timer_bestpath_limit": {
            "description": "Specify timeout for the first best path after a restart, in seconds.",
            "type": "string"
          },
          "timer_bestpath_limit_always": {
            "description": "Enable/Disable update-delay-always option.",
            "type": "string"
          },
          "timer_bgp_hold": {
            "description": "Set BGP hold timer.",
            "type": "string"
          },
          "timer_bgp_keepalive": {
            "description": "Set BGP keepalive timer.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          },
          "vrf": {
            "description": "Name of the VRF. The name 'default' is a valid VRF representing the global BGP.",
            "type": "string"
          }
        },
        "required": [
          "asn",
          "host",
          "transport"
        ]
      }
    },
    {
      "nxos_bgp_af": {
        "type": "object",
        "description": "Manages BGP Address-family configuration.",
        "properties": {
          "additional_paths_install": {
            "description": "Install a backup path into the forwarding table and provide prefix independent convergence (PIC) in case of a PE- CE link failure.",
            "type": "string"
          },
          "additional_paths_receive": {
            "description": "Enables the receive capability of additional paths for all of the neighbors under this address family for which the capability has not been disabled.",
            "type": "string"
          },
          "additional_paths_selection": {
            "description": "Configures the capability of selecting additional paths for a prefix. Valid values are a string defining the name of the route-map.",
            "type": "string"
          },
          "additional_paths_send": {
            "description": "Enables the send capability of additional paths for all of the neighbors under this address family for which the capability has not been disabled.",
            "type": "string"
          },
          "advertise_l2vpn_evpn": {
            "description": "Advertise evpn routes.",
            "type": "string"
          },
          "afi": {
            "description": "Address Family Identifier.",
            "type": "string"
          },
          "asn": {
            "description": "BGP autonomous system number. Valid values are String, Integer in ASPLAIN or ASDOT notation.",
            "type": "string"
          },
          "client_to_client": {
            "description": "Configure client-to-client route reflection.",
            "type": "string"
          },
          "dampen_igp_metric": {
            "description": "Specify dampen value for IGP metric-related changes, in seconds. Valid values are integer and keyword 'default'.",
            "type": "string"
          },
          "dampening_half_time": {
            "description": "Specify decay half-life in minutes for route- flap dampening. Valid values are integer and keyword 'default'.",
            "type": "string"
          },
          "dampening_max_suppress_time": {
            "description": "Specify max suppress time for route-flap dampening stable route. Valid values are integer and keyword 'default'.",
            "type": "string"
          },
          "dampening_reuse_time": {
            "description": "Specify route reuse time for route-flap dampening. Valid values are integer and keyword 'default'.",
            "type": "string"
          },
          "dampening_routemap": {
            "description": "Specify route-map for route-flap dampening. Valid values are a string defining the name of the route-map.",
            "type": "string"
          },
          "dampening_state": {
            "description": "Enable/disable route-flap dampening.",
            "type": "string"
          },
          "dampening_suppress_time": {
            "description": "Specify route suppress time for route-flap dampening. Valid values are integer and keyword 'default'.",
            "type": "string"
          },
          "default_information_originate": {
            "description": "Default information originate.",
            "type": "string"
          },
          "default_metric": {
            "description": "Sets default metrics for routes redistributed into BGP. Valid values are Integer or keyword 'default'",
            "type": "string"
          },
          "distance_ebgp": {
            "description": "Sets the administrative distance for eBGP routes. Valid values are Integer or keyword 'default'.",
            "type": "string"
          },
          "distance_ibgp": {
            "description": "Sets the administrative distance for iBGP routes. Valid values are Integer or keyword 'default'.",
            "type": "string"
          },
          "distance_local": {
            "description": "Sets the administrative distance for local BGP routes. Valid values are Integer or keyword 'default'.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "inject_map": {
            "description": "An array of route-map names which will specify prefixes to inject. Each array entry must first specify the inject-map name, secondly an exist-map name, and optionally the copy- attributes keyword which indicates that attributes should be copied from the aggregate. For example [['la x_inject_map', 'lax_exist_map'], ['nyc_inject_map' , 'nyc_exist_map', 'copy- attributes'], ['f sd_inject_map', ' fsd_exist_map']].",
            "type": "string"
          },
          "maximum_paths": {
            "description": "Configures the maximum number of equal-cost paths for load sharing. Valid value is an integer in the range 1-64.",
            "type": "string"
          },
          "maximum_paths_ibgp": {
            "description": "Configures the maximum number of ibgp equal-cost paths for load sharing. Valid value is an integer in the range 1-64.",
            "type": "string"
          },
          "networks": {
            "description": "Networks to configure. Valid value is a list of network prefixes to advertise. The list must be in the form of an array. Each entry in the array must include a prefix address and an optional route- map. For example [['10.0.0.0/16', 'routemap_LA'], ['192.168.1.1', 'Chicago'], ['192 .168.2.0/24], ['1 92.168.3.0/24', 'routemap_NYC']].",
            "type": "string"
          },
          "next_hop_route_map": {
            "description": "Configure a route-map for valid nexthops. Valid values are a string defining the name of the route-map.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "redistribute": {
            "description": "A list of redistribute directives. Multiple redistribute entries are allowed. The list must be in the form of a nested array. the first entry of each array defines the source-protocol to redistribute from; the second entry defines a route-map name. A route-map is highly advised but may be optional on some platforms, in which case it may be omitted from the array list. For example [['direct', 'rm_direct'], ['lisp', 'rm_lisp']].",
            "type": "string"
          },
          "safi": {
            "description": "Sub Address Family Identifier.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Determines whether the config should be present or not on the device.",
            "type": "string"
          },
          "suppress_inactive": {
            "description": "Advertises only active routes to peers.",
            "type": "string"
          },
          "table_map": {
            "description": "Apply table-map to filter routes downloaded into URIB. Valid values are a string.",
            "type": "string"
          },
          "table_map_filter": {
            "description": "Filters routes rejected by the route-map and does not download them to the RIB.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          },
          "vrf": {
            "description": "Name of the VRF. The name 'default' is a valid VRF representing the global bgp.",
            "type": "string"
          }
        },
        "required": [
          "afi",
          "asn",
          "host",
          "safi",
          "transport",
          "vrf"
        ]
      }
    },
    {
      "nxos_bgp_neighbor": {
        "type": "object",
        "description": "Manages BGP neighbors configurations.",
        "properties": {
          "asn": {
            "description": "BGP autonomous system number. Valid values are string, Integer in ASPLAIN or ASDOT notation.",
            "type": "string"
          },
          "capability_negotiation": {
            "description": "Configure whether or not to negotiate capability with this neighbor.",
            "type": "string"
          },
          "connected_check": {
            "description": "Configure whether or not to check for directly connected peer.",
            "type": "string"
          },
          "description": {
            "description": "Description of the neighbor.",
            "type": "string"
          },
          "dynamic_capability": {
            "description": "Configure whether or not to enable dynamic capability.",
            "type": "string"
          },
          "ebgp_multihop": {
            "description": "Specify multihop TTL for a remote peer. Valid values are integers between 2 and 255, or keyword 'default' to disable this property.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "local_as": {
            "description": "Specify the local-as number for the eBGP neighbor. Valid values are String or Integer in ASPLAIN or ASDOT notation, or 'default', which means not to configure it.",
            "type": "string"
          },
          "log_neighbor_changes": {
            "description": "Specify whether or not to enable log messages for neighbor up/down event.",
            "type": "string"
          },
          "low_memory_exempt": {
            "description": "Specify whether or not to shut down this neighbor under memory pressure.",
            "type": "string"
          },
          "maximum_peers": {
            "description": "Specify Maximum number of peers for this neighbor prefix Valid values are between 1 and 1000, or 'default', which does not impose the limit.",
            "type": "string"
          },
          "neighbor": {
            "description": "Neighbor Identifier. Valid values are string. Neighbors may use IPv4 or IPv6 notation, with or without prefix length.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "pwd": {
            "description": "Specify the password for neighbor. Valid value is string.",
            "type": "string"
          },
          "pwd_type": {
            "description": "Specify the encryption type the password will use. Valid values are '3des' or 'cisco_type_7' encryption.",
            "type": "string"
          },
          "remote_as": {
            "description": "Specify Autonomous System Number of the neighbor. Valid values are String or Integer in ASPLAIN or ASDOT notation, or 'default', which means not to configure it.",
            "type": "string"
          },
          "remove_private_as": {
            "description": "Specify the config to remove private AS number from outbound updates. Valid values are 'enable' to enable this config, 'disable' to disable this config, 'all' to remove all private AS number, or 'replace-as', to replace the private AS number.",
            "type": "string"
          },
          "shutdown": {
            "description": "Configure to administratively shutdown this neighbor.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Determines whether the config should be present or not on the device.",
            "type": "string"
          },
          "suppress_4_byte_as": {
            "description": "Configure to suppress 4-byte AS Capability.",
            "type": "string"
          },
          "timers_holdtime": {
            "description": "Specify holdtime timer value. Valid values are integers between 0 and 3600 in terms of seconds, or 'default', which is 180.",
            "type": "string"
          },
          "timers_keepalive": {
            "description": "Specify keepalive timer value. Valid values are integers between 0 and 3600 in terms of seconds, or 'default', which is 60.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "transport_passive_only": {
            "description": "Specify whether or not to only allow passive connection setup. Valid values are 'true', 'false', and 'default', which defaults to 'false'. This property can only be configured when the neighbor is in 'ip' address format without prefix length. This property and the  transport_passive _mode property are mutually exclusive.",
            "type": "string"
          },
          "update_source": {
            "description": "Specify source interface of BGP session and updates.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          },
          "vrf": {
            "description": "Name of the VRF. The name 'default' is a valid VRF representing the global bgp.",
            "type": "string"
          }
        },
        "required": [
          "asn",
          "host",
          "neighbor",
          "transport"
        ]
      }
    },
    {
      "nxos_bgp_neighbor_af": {
        "type": "object",
        "description": "Manages BGP address-family's neighbors configuration.",
        "properties": {
          "additional_paths_receive": {
            "description": "Valid values are enable for basic command enablement; disable for disabling the command at the neighbor af level (it adds the disable keyword to the basic command); and inherit to remove the command at this level (the command value is inherited from a higher BGP layer).",
            "type": "string"
          },
          "additional_paths_send": {
            "description": "Valid values are enable for basic command enablement; disable for disabling the command at the neighbor af level (it adds the disable keyword to the basic command); and inherit to remove the command at this level (the command value is inherited from a higher BGP layer).",
            "type": "string"
          },
          "advertise_map_exist": {
            "description": "Conditional route advertisement. This property requires two route maps, an advertise-map and an exist-map. Valid values are an array specifying both the advertise-map name and the exist-map name, or simply 'default' e.g. [' my_advertise_map' , 'my_exist_map']. This command is mutually exclusive with the advertise_map _non_exist property.",
            "type": "string"
          },
          "advertise_map_non_exist": {
            "description": "Conditional route advertisement. This property requires two route maps, an advertise-map and an exist-map. Valid values are an array specifying both the advertise-map name and the non- exist-map name, or simply 'default' e.g. [' my_advertise_map' , 'my_non_exist_m ap']. This command is mutually exclusive with the advertise_map _exist property.",
            "type": "string"
          },
          "afi": {
            "description": "Address Family Identifier.",
            "type": "string"
          },
          "allowas_in": {
            "description": "Activate allowas-in property",
            "type": "string"
          },
          "allowas_in_max": {
            "description": "Optional max-occurrences value for allowas_in. Valid values are an integer value or 'default'. Can be used independently or in conjunction with allowas_in.",
            "type": "string"
          },
          "as_override": {
            "description": "Activate the as-override feature.",
            "type": "string"
          },
          "asn": {
            "description": "BGP autonomous system number. Valid values are String, Integer in ASPLAIN or ASDOT notation.",
            "type": "string"
          },
          "default_originate": {
            "description": "Activate the default-originate feature.",
            "type": "string"
          },
          "default_originate_route_map": {
            "description": "Optional route-map for the default_originate property. Can be used independently or in conjunction with `default_ori ginate'. Valid values are a string defining a route-map name, or 'default'.",
            "type": "string"
          },
          "filter_list_in": {
            "description": "Valid values are a string defining a filter-list name, or 'default'.",
            "type": "string"
          },
          "filter_list_out": {
            "description": "Valid values are a string defining a filter-list name, or 'default'.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "max_prefix_interval": {
            "description": "Optional restart interval. Valid values are an integer. Requires max_prefix_limit.",
            "type": "string"
          },
          "max_prefix_limit": {
            "description": "maximum-prefix limit value. Valid values are an integer value or 'default'.",
            "type": "string"
          },
          "max_prefix_threshold": {
            "description": "Optional threshold percentage at which to generate a warning. Valid values are an integer value. Requires max_prefix_limit.",
            "type": "string"
          },
          "max_prefix_warning": {
            "description": "Optional warning-only keyword. Requires max_prefix_limit.",
            "type": "string"
          },
          "neighbor": {
            "description": "Neighbor Identifier. Valid values are string. Neighbors may use IPv4 or IPv6 notation, with or without prefix length.",
            "type": "string"
          },
          "next_hop_self": {
            "description": "Activate the next-hop-self feature.",
            "type": "string"
          },
          "next_hop_third_party": {
            "description": "Activate the next-hop-third-party feature.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "prefix_list_in": {
            "description": "Valid values are a string defining a prefix-list name, or 'default'.",
            "type": "string"
          },
          "prefix_list_out": {
            "description": "Valid values are a string defining a prefix-list name, or 'default'.",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "route_map_in": {
            "description": "Valid values are a string defining a route-map name, or 'default'.",
            "type": "string"
          },
          "route_map_out": {
            "description": "Valid values are a string defining a route-map name, or 'default'.",
            "type": "string"
          },
          "route_reflector_client": {
            "description": "Router reflector client.",
            "type": "string"
          },
          "safi": {
            "description": "Sub Address Family Identifier.",
            "type": "string"
          },
          "send_community": {
            "description": "send-community attribute.",
            "type": "string"
          },
          "soft_reconfiguration_in": {
            "description": "Valid values are 'enable' for basic command enablement; 'always' to add the always keyword to the basic command; and 'inherit' to remove the command at this level (the command value is inherited from a higher BGP layer).",
            "type": "string"
          },
          "soo": {
            "description": "Site-of-origin. Valid values are a string defining a VPN extcommunity or 'default'.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Determines whether the config should be present or not on the device.",
            "type": "string"
          },
          "suppress_inactive": {
            "description": "suppress-inactive feature.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "unsuppress_map": {
            "description": "unsuppress-map. Valid values are a string defining a route- map name or 'default'.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          },
          "vrf": {
            "description": "Name of the VRF. The name 'default' is a valid VRF representing the global bgp.",
            "type": "string"
          },
          "weight": {
            "description": "Weight value. Valid values are an integer value or 'default'.",
            "type": "string"
          }
        },
        "required": [
          "afi",
          "asn",
          "host",
          "neighbor",
          "safi",
          "transport"
        ]
      }
    },
    {
      "nxos_command": {
        "type": "object",
        "description": "Run arbitrary command on Cisco NXOS devices",
        "properties": {
          "commands": {
            "description": "The commands to send to the remote NXOS device over the configured provider.  The resulting output from the command is returned.  If the `wait_for' argument is provided, the module is not returned until the condition is satisfied or the number of retires as expired. The `commands' argument also accepts an alternative form that allows for complex values that specify the command to run and the output format to return. This can be done on a command by command basis. The complex argument supports the keywords `command' and `output' where `command' is the command to run and `output' is one of 'text' or 'json'.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "interval": {
            "description": "Configures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditional, the interval indicates how to long to wait before trying the command again.",
            "type": "string"
          },
          "match": {
            "description": "The `match' argument is used in conjunction with the `wait_for' argument to specify the match policy.  Valid values are `all' or `any'.  If the value is set to `all' then all conditionals in the `wait_for' must be satisfied.  If the value is set to `any' then only one of the values must be satisfied.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "retries": {
            "description": "Specifies the number of retries a command should by tried before it is considered failed.  The command is run on the target device every retry and evaluated against the `wait_for' conditionals.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          },
          "wait_for": {
            "description": "Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward. If the conditional is not true by the configured retries, the task fails.  See examples.",
            "type": "string"
          }
        },
        "required": [
          "commands",
          "host",
          "transport"
        ]
      }
    },
    {
      "nxos_config": {
        "type": "object",
        "description": "Manage Cisco NXOS configuration sections",
        "properties": {
          "after": {
            "description": "The ordered set of commands to append to the end of the command stack if a change needs to be made. Just like with `before' this allows the playbook designer to append a set of commands to be executed after the command set.",
            "type": "string"
          },
          "backup": {
            "description": "This argument will cause the module to create a full backup of the current `running-config' from the remote device before any changes are made. The backup file is written to the `backup' folder in the playbook root directory. If the directory does not exist, it is created.",
            "type": "string"
          },
          "before": {
            "description": "The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.",
            "type": "string"
          },
          "config": {
            "description": "The module, by default, will connect to the remote device and retrieve the current running- config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The `config' argument allows the implementer to pass in the configuration to use as the base config for comparison.",
            "type": "string"
          },
          "defaults": {
            "description": "The `defaults' argument will influence how the running-config is collected from the device.  When the value is set to true, the command used to collect the running-config is append with the all keyword. When the value is set to false, the command is issued without the all keyword",
            "type": "string"
          },
          "force": {
            "description": "The force argument instructs the module to not consider the current devices running-config. When set to true, this will cause the module to push the contents of `src' into the device without first checking if already configured. Note this argument should be considered deprecated.  To achieve the equivalent, set the `match=none' which is idempotent.  This argument will be removed in a future release.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "lines": {
            "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config. Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.",
            "type": "string"
          },
          "match": {
            "description": "Instructs the module on the way to perform the matching of the set of commands against the current device config.  If match is set to `line', commands are matched line by line.  If match is set to `strict', command lines are matched with respect to position.  If match is set to `exact', command lines must be an equal match. Finally, if match is set to `none', the module will not attempt to compare the source configuration with the running configuration on the remote device.",
            "type": "string"
          },
          "parents": {
            "description": "The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "replace": {
            "description": "Instructs the module on the way to perform the configuration on the device.  If the replace argument is set to `line' then the modified lines are pushed to the device in configuration mode.  If the replace argument is set to `block' then the entire command block is pushed to the device in configuration mode if any line is not correct.",
            "type": "string"
          },
          "save": {
            "description": "The `save' argument instructs the module to save the running- config to startup-config. This operation is performed after any changes are made to the current running config.  If no changes are made, the configuration is still saved to the startup config.  This option will always cause the module to return changed.",
            "type": "string"
          },
          "src": {
            "description": "The `src' argument provides a path to the configuration file to load into the remote system.  The path can either be a full system path to the configuration file if the value starts with / or relative to the root of the implemented role or playbook. This argument is mutually exclusive with the `lines' and `parents' arguments.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "transport"
        ]
      }
    },
    {
      "nxos_evpn_global": {
        "type": "object",
        "description": "Handles the EVPN control plane for VXLAN.",
        "properties": {
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "nv_overlay_evpn": {
            "description": "EVPN control plane.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "nv_overlay_evpn",
          "transport"
        ]
      }
    },
    {
      "nxos_evpn_vni": {
        "type": "object",
        "description": "Manages Cisco EVPN VXLAN Network Identifier (VNI).",
        "properties": {
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "route_distinguisher": {
            "description": "The VPN Route Distinguisher (RD). The RD is combined with the IPv4 or IPv6 prefix learned by the PE router to create a globally unique address.",
            "type": "string"
          },
          "route_target_both": {
            "description": "Enables/Disables route-target settings for both import and export target communities using a single property.",
            "type": "string"
          },
          "route_target_export": {
            "description": "Sets the route-target 'import' extended communities.",
            "type": "string"
          },
          "route_target_import": {
            "description": "Sets the route-target 'import' extended communities.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Determines whether the config should be present or not on the device.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          },
          "vni": {
            "description": "The EVPN VXLAN Network Identifier.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "route_distinguisher",
          "transport",
          "vni"
        ]
      }
    },
    {
      "nxos_facts": {
        "type": "object",
        "description": "Gets facts about NX-OS switches",
        "properties": {
          "gather_subset": {
            "description": "When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, legacy, and interfaces. Can specify a list of values to include a larger subset.  Values can also be used with an initial `[!]' to specify that a specific subset should not be collected.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "transport"
        ]
      }
    },
    {
      "nxos_feature": {
        "type": "object",
        "description": "Manage features in NX-OS switches.",
        "properties": {
          "feature": {
            "description": "Name of feature.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Desired state of the feature.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "feature",
          "host",
          "transport"
        ]
      }
    },
    {
      "nxos_file_copy": {
        "type": "object",
        "description": "Copy a file to a remote NXOS device over SCP.",
        "properties": {
          "file_system": {
            "description": "The remote file system of the device. If omitted, devices that support a file_system parameter will use their default values.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "local_file": {
            "description": "Path to local file. Local directory must exist.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "remote_file": {
            "description": "Remote file path of the copy. Remote directories must exist. If omitted, the name of the local file will be used.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "local_file",
          "transport"
        ]
      }
    },
    {
      "nxos_gir": {
        "type": "object",
        "description": "Trigger a graceful removal or insertion (GIR) of the switch.",
        "properties": {
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Specify desired state of the resource.",
            "type": "string"
          },
          "system_mode_maintenance": {
            "description": "When `system_mode_maintenance=true' it puts all enabled protocols in maintenance mode (using the isolate command). When `system_mode _maintenance=fals e' it puts all enabled protocols in normal mode (using the no isolate command).",
            "type": "string"
          },
          "system_mode_maintenance_dont_generate_profile": {
            "description": "When `system_mode_maintenance_dont_generate_prof ile=true' it prevents the dynamic searching of enabled protocols and executes commands configured in a maintenance-mode profile. Use this option if you want the system to use a maintenance-mode profile that you have created. When `system_mode _maintenance_dont _generate_profile =false' it prevents the dynamic searching of enabled protocols and executes commands configured in a normal-mode profile. Use this option if you want the system to use a normal- mode profile that you have created.",
            "type": "string"
          },
          "system_mode_maintenance_on_reload_reset_reason": {
            "description": "Boots the switch into maintenance mode automatically in the event of a specified system crash.",
            "type": "string"
          },
          "system_mode_maintenance_shutdown": {
            "description": "Shuts down all protocols, vPC domains, and interfaces except the management interface (using the shutdown command). This option is disruptive while  `system_mode_main tenance' (which uses the isolate command) is not.",
            "type": "string"
          },
          "system_mode_maintenance_timeout": {
            "description": "Keeps the switch in maintenance mode for a specified number of minutes. Range is 5-65535.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "state",
          "transport"
        ]
      }
    },
    {
      "nxos_gir_profile_management": {
        "type": "object",
        "description": "Create a maintenance-mode or normal-mode profile for GIR.",
        "properties": {
          "commands": {
            "description": "List of commands to be included into the profile.",
            "type": "string"
          },
          "config": {
            "description": "Specify the configuration string to be used for module operations.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "include_defaults": {
            "description": "Specify to retrieve or not the complete running configuration for module operations.",
            "type": "string"
          },
          "mode": {
            "description": "Configure the profile as Maintenance or Normal mode.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Specify desired state of the resource.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "mode",
          "transport"
        ]
      }
    },
    {
      "nxos_hsrp": {
        "type": "object",
        "description": "Manages HSRP configuration on NX-OS switches.",
        "properties": {
          "auth_string": {
            "description": "Authentication string.",
            "type": "string"
          },
          "auth_type": {
            "description": "Authentication type.",
            "type": "string"
          },
          "group": {
            "description": "HSRP group number.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "interface": {
            "description": "Full name of interface that is being managed for HSRP.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "priority": {
            "description": "HSRP priority.",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Specify desired state of the resource.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          },
          "version": {
            "description": "HSRP version.",
            "type": "string"
          },
          "vip": {
            "description": "HSRP virtual IP address.",
            "type": "string"
          }
        },
        "required": [
          "group",
          "host",
          "interface",
          "transport"
        ]
      }
    },
    {
      "nxos_igmp": {
        "type": "object",
        "description": "Manages IGMP global configuration.",
        "properties": {
          "enforce_rtr_alert": {
            "description": "Enables or disables the enforce router alert option check for IGMPv2 and IGMPv3 packets.",
            "type": "string"
          },
          "flush_routes": {
            "description": "Removes routes when the IGMP process is restarted. By default, routes are not flushed.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "restart": {
            "description": "Restarts the igmp process (using an exec config command).",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Manages desired state of the resource.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "transport"
        ]
      }
    },
    {
      "nxos_igmp_interface": {
        "type": "object",
        "description": "Manages IGMP interface configuration.",
        "properties": {
          "group_timeout": {
            "description": "Sets the group membership timeout for IGMPv2. Values can range from 3 to 65,535 seconds. The default is 260 seconds.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "immediate_leave": {
            "description": "Enables the device to remove the group entry from the multicast routing table immediately upon receiving a leave message for the group. Use this command to minimize the leave latency of IGMPv2 group memberships on a given IGMP interface because the device does not send group- specific queries. The default is disabled.",
            "type": "string"
          },
          "interface": {
            "description": "The full interface name for IGMP configuration. e.g. `Ethernet1/2'.",
            "type": "string"
          },
          "last_member_qrt": {
            "description": "Sets the query interval waited after sending membership reports before the software deletes the group state. Values can range from 1 to 25 seconds. The default is 1 second.",
            "type": "string"
          },
          "last_member_query_count": {
            "description": "Sets the number of times that the software sends an IGMP query in response to a host leave message. Values can range from 1 to 5. The default is 2.",
            "type": "string"
          },
          "oif_prefix": {
            "description": "Configure a prefix for static outgoing interface (OIF).",
            "type": "string"
          },
          "oif_routemap": {
            "description": "Configure a routemap for static outgoing interface (OIF).",
            "type": "string"
          },
          "oif_source": {
            "description": "Configure a source for static outgoing interface (OIF).",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "querier_timeout": {
            "description": "Sets the querier timeout that the software uses when deciding to take over as the querier. Values can range from 1 to 65535 seconds. The default is 255 seconds.",
            "type": "string"
          },
          "query_interval": {
            "description": "Sets the frequency at which the software sends IGMP host query messages. Values can range from 1 to 18000 seconds. he default is 125 seconds.",
            "type": "string"
          },
          "query_mrt": {
            "description": "Sets the response time advertised in IGMP queries. Values can range from 1 to 25 seconds. The default is 10 seconds.",
            "type": "string"
          },
          "report_llg": {
            "description": "Configures report-link-local-groups. Enables sending reports for groups in 224.0.0.0/24. Reports are always sent for nonlink local groups. By default, reports are not sent for link local groups.",
            "type": "string"
          },
          "restart": {
            "description": "Restart IGMP.",
            "type": "string"
          },
          "robustness": {
            "description": "Sets the robustness variable. Values can range from 1 to 7. The default is 2.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "startup_query_count": {
            "description": "Query count used when the IGMP process starts up. The range is from 1 to 10. The default is 2.",
            "type": "string"
          },
          "startup_query_interval": {
            "description": "Query interval used when the IGMP process starts up. The range is from 1 to 18000. The default is 31.",
            "type": "string"
          },
          "state": {
            "description": "Manages desired state of the resource.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          },
          "version": {
            "description": "IGMP version. It can be 2 or 3.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "interface",
          "transport"
        ]
      }
    },
    {
      "nxos_igmp_snooping": {
        "type": "object",
        "description": "Manages IGMP snooping global configuration.",
        "properties": {
          "group_timeout": {
            "description": "Group membership timeout value for all VLANs on the device. Accepted values are integer in range 1-10080, `never' and `default'.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "link_local_grp_supp": {
            "description": "Global link-local groups suppression.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "report_supp": {
            "description": "Global IGMPv1/IGMPv2 Report Suppression.",
            "type": "string"
          },
          "snooping": {
            "description": "Enables/disables IGMP snooping on the switch.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Manage the state of the resource.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          },
          "v3_report_supp": {
            "description": "Global IGMPv3 Report Suppression and Proxy Reporting.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "transport"
        ]
      }
    },
    {
      "nxos_install_os": {
        "type": "object",
        "description": "Set boot options like boot image and kickstart image.",
        "properties": {
          "kickstart_image_file": {
            "description": "Name of the kickstart image file on flash.",
            "type": "string"
          },
          "system_image_file": {
            "description": "Name of the system (or combined) image file on flash.",
            "type": "string"
          }
        },
        "required": "system_image_file"
      }
    },
    {
      "nxos_interface": {
        "type": "object",
        "description": "Manages physical attributes of interfaces.",
        "properties": {
          "admin_state": {
            "description": "Administrative state of the interface.",
            "type": "string"
          },
          "description": {
            "description": "Interface description.",
            "type": "string"
          },
          "fabric_forwarding_anycast_gateway": {
            "description": "Associate SVI with anycast gateway under VLAN configuration mode.",
            "type": "string"
          },
          "interface": {
            "description": "Full name of interface, i.e. Ethernet1/1, port- channel10.",
            "type": "string"
          },
          "interface_type": {
            "description": "Interface type to be unconfigured from the device.",
            "type": "string"
          },
          "ip_forward": {
            "description": "Enable/Disable ip forward feature on SVIs.",
            "type": "string"
          },
          "mode": {
            "description": "Manage Layer 2 or Layer 3 state of the interface.",
            "type": "string"
          },
          "state": {
            "description": "Specify desired state of the resource.",
            "type": "string"
          }
        },
        "required": [
          "interface",
          "state"
        ]
      }
    },
    {
      "nxos_interface_ospf": {
        "type": "object",
        "description": "Manages configuration of an OSPF interface instance.",
        "properties": {
          "area": {
            "description": "Ospf area associated with this cisco_interface_o spf instance. Valid values are a string, formatted as an IP address (i.e. \"0.0.0.0\") or as an integer.",
            "type": "string"
          },
          "cost": {
            "description": "The cost associated with this cisco_interface_o spf instance.",
            "type": "string"
          },
          "dead_interval": {
            "description": "Time interval an ospf neighbor waits for a hello packet before tearing down adjacencies. Valid values are an integer or the keyword 'default'.",
            "type": "string"
          },
          "hello_interval": {
            "description": "Time between sending successive hello packets. Valid values are an integer or the keyword 'default'.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "interface": {
            "description": "Name of this cisco_interface resource. Valid value is a string.",
            "type": "string"
          },
          "message_digest": {
            "description": "Enables or disables the usage of message digest authentication. Valid values are 'true' and 'false'.",
            "type": "string"
          },
          "message_digest_algorithm_type": {
            "description": "Algorithm used for authentication among neighboring routers within an area. Valid values is 'md5'.",
            "type": "string"
          },
          "message_digest_encryption_type": {
            "description": "Specifies the scheme used for encrypting message_digest_pa ssword. Valid values are '3des' or 'cisco_type_7' encryption.",
            "type": "string"
          },
          "message_digest_key_id": {
            "description": "Md5 authentication key-id associated with the ospf instance. If this is present,  message_digest_en cryption_type, me ssage_digest_algo rithm_type and me ssage_digest_pass word are mandatory. Valid value is an integer and 'default'.",
            "type": "string"
          },
          "message_digest_password": {
            "description": "Specifies the message_digest password. Valid value is a string.",
            "type": "string"
          },
          "ospf": {
            "description": "Name of the ospf instance.",
            "type": "string"
          },
          "passive_interface": {
            "description": "Setting to true will prevent this interface from receiving HELLO packets. Valid values are 'true' and 'false'.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Determines whether the config should be present or not on the device.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "area",
          "host",
          "interface",
          "ospf",
          "transport"
        ]
      }
    },
    {
      "nxos_ip_interface": {
        "type": "object",
        "description": "Manages L3 attributes for IPv4 and IPv6 interfaces.",
        "properties": {
          "addr": {
            "description": "IPv4 or IPv6 Address.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "interface": {
            "description": "Full name of interface, i.e. Ethernet1/1, vlan10.",
            "type": "string"
          },
          "mask": {
            "description": "Subnet mask for IPv4 or IPv6 Address in decimal format.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Specify desired state of the resource.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "interface",
          "transport"
        ]
      }
    },
    {
      "nxos_mtu": {
        "type": "object",
        "description": "Manages MTU settings on Nexus switch.",
        "properties": {
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "interface": {
            "description": "Full name of interface, i.e. Ethernet1/1.",
            "type": "string"
          },
          "mtu": {
            "description": "MTU for a specific interface.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Specify desired state of the resource.",
            "type": "string"
          },
          "sysmtu": {
            "description": "System jumbo MTU.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "transport"
        ]
      }
    },
    {
      "nxos_ntp": {
        "type": "object",
        "description": "Manages core NTP configuration.",
        "properties": {
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "key_id": {
            "description": "Authentication key identifier to use with given NTP server or peer.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "peer": {
            "description": "Network address of NTP peer.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "prefer": {
            "description": "Makes given NTP server or peer the preferred NTP server or peer for the device.",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "server": {
            "description": "Network address of NTP server.",
            "type": "string"
          },
          "source_addr": {
            "description": "Local source address from which NTP messages are sent.",
            "type": "string"
          },
          "source_int": {
            "description": "Local source interface from which NTP messages are sent. Must be fully qualified interface name.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Manage the state of the resource.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          },
          "vrf_name": {
            "description": "Makes the device communicate with the given NTP server or peer over a specific VRF.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "transport"
        ]
      }
    },
    {
      "nxos_ntp_auth": {
        "type": "object",
        "description": "Manages NTP authentication.",
        "properties": {
          "auth_type": {
            "description": "Whether the given md5string is in cleartext or has been encrypted. If in cleartext, the device will encrypt it before storing it.",
            "type": "string"
          },
          "authentication": {
            "description": "Turns NTP authentication on or off.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "key_id": {
            "description": "Authentication key identifier (numeric).",
            "type": "string"
          },
          "md5string": {
            "description": "MD5 String.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Manage the state of the resource.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "trusted_key": {
            "description": "Whether the given key is required to be supplied by a time source for the device to synchronize to the time source.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "key_id",
          "md5string",
          "transport"
        ]
      }
    },
    {
      "nxos_ntp_options": {
        "type": "object",
        "description": "Manages NTP options.",
        "properties": {
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "logging": {
            "description": "Sets whether NTP logging is enabled on the device.",
            "type": "string"
          },
          "master": {
            "description": "Sets whether the device is an authoritative NTP server.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Manage the state of the resource.",
            "type": "string"
          },
          "stratrum": {
            "description": "If `master=true', an optional stratum can be supplied (1-15). The device default is 8.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "transport"
        ]
      }
    },
    {
      "nxos_nxapi": {
        "type": "object",
        "description": "Manage NXAPI configuration on an NXOS device.",
        "properties": {
          "config": {
            "description": "The `config' argument provides an optional argument to specify the device running- config to used as the basis for configuring the remote system. The `config' argument accepts a string value that represents the device configuration.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "http": {
            "description": "Controls the operating state of the HTTP protocol as one of the underlying transports for NXAPI.  By default, NXAPI will enable the HTTP transport when the feature is first configured.  To disable the use of the HTTP transport, set the value of this argument to False.",
            "type": "string"
          },
          "http_port": {
            "description": "Configure the port with which the HTTP server will listen on for requests.  By default, NXAPI will bind the HTTP service to the standard HTTP port 80.  This argument accepts valid port values in the range of 1 to 65535.",
            "type": "string"
          },
          "https": {
            "description": "Controls the operating state of the HTTPS protocol as one of the underlying transports for NXAPI.  By default, NXAPI will disable the HTTPS transport when the feature is first configured.  To enable the use of the HTTPS transport, set the value of this argument to True.",
            "type": "string"
          },
          "https_port": {
            "description": "Configure the port with which the HTTPS server will listen on for requests.  By default, NXAPI will bind the HTTPS service to the standard HTTPS port 443. This argument accepts valid port values in the range of 1 to 65535.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "sandbox": {
            "description": "The NXAPI feature provides a web base UI for developers for entering commands.  This feature is initially disabled when the NXAPI feature is configured for the first time. When the `sandbox' argument is set to True, the developer sandbox URL will accept requests and when the value is set to False, the sandbox URL is unavailable.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "The `state' argument controls whether or not the NXAPI feature is configured on the remote device. When the value is `present' the NXAPI feature configuration is present in the device running- config.  When the values is `absent' the feature configuration is removed from the running-config.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "transport"
        ]
      }
    },
    {
      "nxos_ospf": {
        "type": "object",
        "description": "Manages configuration of an ospf instance.",
        "properties": {
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "ospf": {
            "description": "Name of the ospf instance.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Determines whether the config should be present or not on the device.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "ospf",
          "transport"
        ]
      }
    },
    {
      "nxos_ospf_vrf": {
        "type": "object",
        "description": "Manages a VRF for an OSPF router.",
        "properties": {
          "auto_cost": {
            "description": "Specifies the reference bandwidth used to assign OSPF cost. Valid values are an integer, in Mbps, or the keyword 'default'.",
            "type": "string"
          },
          "default_metric": {
            "description": "Specify the default Metric value. Valid values are an integer or the keyword 'default'.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "log_adjacency": {
            "description": "Controls the level of log messages generated whenever a neighbor changes state. Valid values are 'log', 'detail', and 'default'.",
            "type": "string"
          },
          "ospf": {
            "description": "Name of the OSPF instance.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "router_id": {
            "description": "Router Identifier (ID) of the OSPF router VRF instance.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "timer_throttle_lsa_hold": {
            "description": "Specify the hold interval for rate-limiting Link-State Advertisement (LSA) generation. Valid values are an integer, in milliseconds, or the keyword 'default'.",
            "type": "string"
          },
          "timer_throttle_lsa_max": {
            "description": "Specify the max interval for rate-limiting Link- State Advertisement (LSA) generation. Valid values are an integer, in milliseconds, or the keyword 'default'.",
            "type": "string"
          },
          "timer_throttle_lsa_start": {
            "description": "Specify the start interval for rate-limiting Link-State Advertisement (LSA) generation. Valid values are an integer, in milliseconds, or the keyword 'default'.",
            "type": "string"
          },
          "timer_throttle_spf_hold": {
            "description": "Specify minimum hold time between Shortest Path First (SPF) calculations. Valid values are an integer, in milliseconds, or the keyword 'default'.",
            "type": "string"
          },
          "timer_throttle_spf_max": {
            "description": "Specify the maximum wait time between Shortest Path First (SPF) calculations. Valid values are an integer, in milliseconds, or the keyword 'default'.",
            "type": "string"
          },
          "timer_throttle_spf_start": {
            "description": "Specify initial Shortest Path First (SPF) schedule delay. Valid values are an integer, in milliseconds, or the keyword 'default'.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          },
          "vrf": {
            "description": "Name of the resource instance. Valid value is a string. The name 'default' is a valid VRF representing the global OSPF.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "ospf",
          "transport"
        ]
      }
    },
    {
      "nxos_overlay_global": {
        "type": "object",
        "description": "Configures anycast gateway MAC of the switch.",
        "properties": {
          "anycast_gateway_mac": {
            "description": "Anycast gateway mac of the switch.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "anycast_gateway_mac",
          "host",
          "transport"
        ]
      }
    },
    {
      "nxos_pim": {
        "type": "object",
        "description": "Manages configuration of a PIM instance.",
        "properties": {
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "ssm_range": {
            "description": "Configure group ranges for Source Specific Multicast (SSM). Valid values are multicast addresses or the keyword 'none'.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "ssm_range",
          "transport"
        ]
      }
    },
    {
      "nxos_pim_interface": {
        "type": "object",
        "description": "Manages PIM interface configuration.",
        "properties": {
          "border": {
            "description": "Configures interface to be a boundary of a PIM domain.",
            "type": "string"
          },
          "hello_auth_key": {
            "description": "Authentication for hellos on this interface.",
            "type": "string"
          },
          "hello_interval": {
            "description": "Hello interval in milliseconds for this interface.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "interface": {
            "description": "Full name of the interface such as Ethernet1/33.",
            "type": "string"
          },
          "jp_policy_in": {
            "description": "Policy for join-prune messages (inbound).",
            "type": "string"
          },
          "jp_policy_out": {
            "description": "Policy for join-prune messages (outbound).",
            "type": "string"
          },
          "jp_type_in": {
            "description": "Type of policy mapped to `jp_policy_in'.",
            "type": "string"
          },
          "jp_type_out": {
            "description": "Type of policy mapped to `jp_policy_out'.",
            "type": "string"
          },
          "neighbor_policy": {
            "description": "Configures a neighbor policy for filtering adjacencies.",
            "type": "string"
          },
          "neighbor_type": {
            "description": "Type of policy mapped to neighbor_policy.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "sparse": {
            "description": "Enable/disable sparse-mode on the interface.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Manages desired state of the resource.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "interface",
          "jp_policy_out",
          "transport"
        ]
      }
    },
    {
      "nxos_pim_rp_address": {
        "type": "object",
        "description": "Manages configuration of an PIM static RP address instance.",
        "properties": {
          "bidir": {
            "description": "Group range is treated in PIM bidirectional mode.",
            "type": "string"
          },
          "group_list": {
            "description": "Group range for static RP. Valid values are multicast addresses.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "prefix_list": {
            "description": "Prefix list policy for static RP. Valid values are prefix-list policy names.",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "route_map": {
            "description": "Route map policy for static RP. Valid values are route-map policy names.",
            "type": "string"
          },
          "rp_address": {
            "description": "Configures a Protocol Independent Multicast (PIM) static rendezvous point (RP) address. Valid values are unicast addresses.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "rp_address",
          "transport"
        ]
      }
    },
    {
      "nxos_ping": {
        "type": "object",
        "description": "Tests reachability using ping from Nexus switch.",
        "properties": {
          "count": {
            "description": "Number of packets to send.",
            "type": "string"
          },
          "dest": {
            "description": "IP address or hostname (resolvable by switch) of remote node.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "source": {
            "description": "Source IP Address.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          },
          "vrf": {
            "description": "Outgoing VRF.",
            "type": "string"
          }
        },
        "required": [
          "dest",
          "host",
          "transport"
        ]
      }
    },
    {
      "nxos_portchannel": {
        "type": "object",
        "description": "Manages port-channel interfaces.",
        "properties": {
          "force": {
            "description": "When true it forces port-channel members to match what is declared in the members param. This can be used to remove members.",
            "type": "string"
          },
          "group": {
            "description": "Channel-group number for the port-channel.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "members": {
            "description": "List of interfaces that will be managed in a given portchannel.",
            "type": "string"
          },
          "min_links": {
            "description": "Min links required to keep portchannel up.",
            "type": "string"
          },
          "mode": {
            "description": "Mode for the port-channel, i.e. on, active, passive.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Manage the state of the resource.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "group",
          "host",
          "transport"
        ]
      }
    },
    {
      "nxos_reboot": {
        "type": "object",
        "description": "Reboot a network device.",
        "properties": {
          "confirm": {
            "description": "Safeguard boolean. Set to true if you're sure you want to reboot.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "transport"
        ]
      }
    },
    {
      "nxos_rollback": {
        "type": "object",
        "description": "Set a checkpoint or rollback to a checkpoint.",
        "properties": {
          "checkpoint_file": {
            "description": "Name of checkpoint file to create. Mutually exclusive with rollback_to.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "rollback_to": {
            "description": "Name of checkpoint file to rollback to. Mutually exclusive with checkpoint_file.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "transport"
        ]
      }
    },
    {
      "nxos_smu": {
        "type": "object",
        "description": "Perform SMUs on Cisco NX-OS devices.",
        "properties": {
          "file_system": {
            "description": "The remote file system of the device. If omitted, devices that support a file_system parameter will use their default values.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "pkg": {
            "description": "Name of the remote package.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "pkg",
          "transport"
        ]
      }
    },
    {
      "nxos_snapshot": {
        "type": "object",
        "description": "Manage snapshots of the running states of selected features.",
        "properties": {
          "action": {
            "description": "Define what snapshot action the module would perform.",
            "type": "string"
          },
          "compare_option": {
            "description": "Snapshot options to be used when `action=compare'.",
            "type": "string"
          },
          "comparison_results_file": {
            "description": "Name of the file where snapshots comparison will be store.",
            "type": "string"
          },
          "description": {
            "description": "Snapshot description to be used when `action=create'.",
            "type": "string"
          },
          "element_key1": {
            "description": "Specify the tags used to distinguish among row entries, to be used when `action=add'.",
            "type": "string"
          },
          "element_key2": {
            "description": "Specify the tags used to distinguish among row entries, to be used when `action=add'.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "path": {
            "description": "Specify the path of the file where new created snapshot or snapshots comparison will be stored, to be used when `action=create' and `save_snapsho t_locally=true' or `action=compare'.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "row_id": {
            "description": "Specifies the tag of each row entry of the show command's XML output, to be used when `action=add'.",
            "type": "string"
          },
          "save_snapshot_locally": {
            "description": "Specify to locally store a new created snapshot, to be used when `action=create'.",
            "type": "string"
          },
          "section": {
            "description": "Used to name the show command output, to be used when `action=add'.",
            "type": "string"
          },
          "show_command": {
            "description": "Specify a new show command, to be used when `action=add'.",
            "type": "string"
          },
          "snapshot1": {
            "description": "First snapshot to be used when `action=compare'.",
            "type": "string"
          },
          "snapshot2": {
            "description": "Second snapshot to be used when `action=compare'.",
            "type": "string"
          },
          "snapshot_name": {
            "description": "Snapshot name, to be used when `action=create' or `action=delete'.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "action",
          "host",
          "transport"
        ]
      }
    },
    {
      "nxos_snmp_community": {
        "type": "object",
        "description": "Manages SNMP community configs.",
        "properties": {
          "access": {
            "description": "Access type for community.",
            "type": "string"
          },
          "acl": {
            "description": "ACL name to filter snmp requests.",
            "type": "string"
          },
          "community": {
            "description": "Case-sensitive community string.",
            "type": "string"
          },
          "config": {
            "description": "Configuration string to be used for module operations. If not specified, the module will use the current running configuration.",
            "type": "string"
          },
          "group": {
            "description": "Group to which the community belongs.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "include_defaults": {
            "description": "Specify to use or not the complete running configuration for module operations.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "save": {
            "description": "Specify to save the running configuration after module operations.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Manage the state of the resource.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "community",
          "host",
          "state",
          "transport"
        ]
      }
    },
    {
      "nxos_snmp_contact": {
        "type": "object",
        "description": "Manages SNMP contact info.",
        "properties": {
          "contact": {
            "description": "Contact information.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Manage the state of the resource.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "contact",
          "host",
          "state",
          "transport"
        ]
      }
    },
    {
      "nxos_snmp_host": {
        "type": "object",
        "description": "Manages SNMP host configuration.",
        "properties": {
          "community": {
            "description": "Community string or v3 username.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "snmp_host": {
            "description": "IP address of hostname of target host.",
            "type": "string"
          },
          "snmp_type": {
            "description": "type of message to send to host.",
            "type": "string"
          },
          "src_intf": {
            "description": "Source interface.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Manage the state of the resource.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "udp": {
            "description": "UDP port number (0-65535).",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          },
          "version": {
            "description": "SNMP version.",
            "type": "string"
          },
          "vrf": {
            "description": "VRF to use to source traffic to source.",
            "type": "string"
          },
          "vrf_filter": {
            "description": "Name of VRF to filter.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "snmp_host",
          "state",
          "transport"
        ]
      }
    },
    {
      "nxos_snmp_location": {
        "type": "object",
        "description": "Manages SNMP location information.",
        "properties": {
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "location": {
            "description": "Location information.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Manage the state of the resource.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "location",
          "transport"
        ]
      }
    },
    {
      "nxos_snmp_traps": {
        "type": "object",
        "description": "Manages SNMP traps.",
        "properties": {
          "group": {
            "description": "Case sensitive group.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Manage the state of the resource.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "group",
          "host",
          "transport"
        ]
      }
    },
    {
      "nxos_snmp_user": {
        "type": "object",
        "description": "Manages SNMP users for monitoring.",
        "properties": {
          "auth": {
            "description": "Auth parameters for the user.",
            "type": "string"
          },
          "encrypt": {
            "description": "Enables AES-128 bit encryption when using privacy password.",
            "type": "string"
          },
          "group": {
            "description": "Group to which the user will belong to.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "privacy": {
            "description": "Privacy password for the user.",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "pwd": {
            "description": "Auth password when using md5 or sha.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Manage the state of the resource.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "user": {
            "description": "Name of the user.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "group",
          "host",
          "transport",
          "user"
        ]
      }
    },
    {
      "nxos_static_route": {
        "type": "object",
        "description": "Manages static route configuration",
        "properties": {
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "next_hop": {
            "description": "Next hop address or interface of static route. If interface, it must be the fully-qualified interface name.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "pref": {
            "description": "Preference or administrative difference of route (range 1-255).",
            "type": "string"
          },
          "prefix": {
            "description": "Destination prefix of static route.",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "route_name": {
            "description": "Name of the route. Used with the name parameter on the CLI.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Manage the state of the resource.",
            "type": "string"
          },
          "tag": {
            "description": "Route tag value (numeric).",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          },
          "vrf": {
            "description": "VRF for static route.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "next_hop",
          "prefix",
          "state",
          "transport"
        ]
      }
    },
    {
      "nxos_switchport": {
        "type": "object",
        "description": "Manages Layer 2 switchport interfaces.",
        "properties": {
          "access_vlan": {
            "description": "If `mode=access', used as the access VLAN ID.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "interface": {
            "description": "Full name of the interface, i.e. Ethernet1/1.",
            "type": "string"
          },
          "mode": {
            "description": "Mode for the Layer 2 port.",
            "type": "string"
          },
          "native_vlan": {
            "description": "If `mode=trunk', used as the trunk native VLAN ID.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Manage the state of the resource.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "trunk_allowed_vlans": {
            "description": "if `mode=trunk', these are the only VLANs that will be configured on the trunk, i.e. \"2-10,15\".",
            "type": "string"
          },
          "trunk_vlans": {
            "description": "If `mode=trunk', used as the VLAN range to ADD or REMOVE from the trunk.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "interface",
          "transport"
        ]
      }
    },
    {
      "nxos_udld": {
        "type": "object",
        "description": "Manages UDLD global configuration params.",
        "properties": {
          "aggressive": {
            "description": "Toggles aggressive mode.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "msg_time": {
            "description": "Message time in seconds for UDLD packets.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "reset": {
            "description": "Ability to reset UDLD down interfaces.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Manage the state of the resource.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "transport"
        ]
      }
    },
    {
      "nxos_udld_interface": {
        "type": "object",
        "description": "Manages UDLD interface configuration params.",
        "properties": {
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "interface": {
            "description": "FULL name of the interface, i.e. Ethernet1/1-",
            "type": "string"
          },
          "mode": {
            "description": "Manages UDLD mode for an interface.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Manage the state of the resource.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "interface",
          "mode",
          "transport"
        ]
      }
    },
    {
      "nxos_vlan": {
        "type": "object",
        "description": "Manages VLAN resources and attributes.",
        "properties": {
          "admin_state": {
            "description": "Manage the VLAN administrative state of the VLAN equivalent to shut/no shut in VLAN config mode.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "mapped_vni": {
            "description": "The Virtual Network Identifier (VNI) ID that is mapped to the VLAN. Valid values are integer and keyword 'default'.",
            "type": "string"
          },
          "name": {
            "description": "Name of VLAN.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Manage the state of the resource.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          },
          "vlan_id": {
            "description": "Single VLAN ID.",
            "type": "string"
          },
          "vlan_range": {
            "description": "Range of VLANs such as 2-10 or 2,5,10-15, etc.",
            "type": "string"
          },
          "vlan_state": {
            "description": "Manage the vlan operational state of the VLAN (equivalent to state {active | suspend} command.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "transport"
        ]
      }
    },
    {
      "nxos_vpc": {
        "type": "object",
        "description": "Manages global VPC configuration",
        "properties": {
          "auto_recovery": {
            "description": "Enables/Disables auto recovery",
            "type": "string"
          },
          "delay_restore": {
            "description": "manages delay restore command and config value in seconds",
            "type": "string"
          },
          "domain": {
            "description": "VPC domain",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "peer_gw": {
            "description": "Enables/Disables peer gateway",
            "type": "string"
          },
          "pkl_dest": {
            "description": "Destination (remote) IP address used for peer keepalive link",
            "type": "string"
          },
          "pkl_src": {
            "description": "Source IP address used for peer keepalive link",
            "type": "string"
          },
          "pkl_vrf": {
            "description": "VRF used for peer keepalive link",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "role_priority": {
            "description": "Role priority for device. Remember lower is better.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Manages desired state of the resource",
            "type": "string"
          },
          "system_priority": {
            "description": "System priority device.  Remember they must match between peers.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "auto_recovery",
          "domain",
          "host",
          "peer_gw",
          "state",
          "transport"
        ]
      }
    },
    {
      "nxos_vpc_interface": {
        "type": "object",
        "description": "Manages interface VPC configuration",
        "properties": {
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "peer_link": {
            "description": "Set to true/false for peer link config on associated portchannel.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "portchannel": {
            "description": "Group number of the portchannel that will be configured.",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Manages desired state of the resource.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          },
          "vpc": {
            "description": "VPC group/id that will be configured on associated portchannel.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "portchannel",
          "state",
          "transport"
        ]
      }
    },
    {
      "nxos_vrf": {
        "type": "object",
        "description": "Manages global VRF configuration.",
        "properties": {
          "admin_state": {
            "description": "Administrative state of the VRF.",
            "type": "string"
          },
          "description": {
            "description": "Description of the VRF.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "route_distinguisher": {
            "description": "VPN Route Distinguisher (RD). Valid values are a string in one of the route- distinguisher formats (ASN2:NN, ASN4:NN, or IPV4:NN); the keyword 'auto', or the keyword 'default'.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Manages desired state of the resource.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          },
          "vni": {
            "description": "Specify virtual network identifier. Valid values are Integer or keyword 'default'.",
            "type": "string"
          },
          "vrf": {
            "description": "Name of VRF to be managed.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "transport",
          "vrf"
        ]
      }
    },
    {
      "nxos_vrf_af": {
        "type": "object",
        "description": "Manages VRF AF.",
        "properties": {
          "afi": {
            "description": "Address-Family Identifier (AFI).",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "route_target_both_auto_evpn": {
            "description": "Enable/Disable the EVPN route-target 'auto' setting for both import and export target communities.",
            "type": "string"
          },
          "safi": {
            "description": "Sub Address-Family Identifier (SAFI).",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Determines whether the config should be present or not on the device.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          },
          "vrf": {
            "description": "Name of the VRF.",
            "type": "string"
          }
        },
        "required": [
          "afi",
          "host",
          "safi",
          "transport",
          "vrf"
        ]
      }
    },
    {
      "nxos_vrf_interface": {
        "type": "object",
        "description": "Manages interface specific VRF configuration.",
        "properties": {
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "interface": {
            "description": "Full name of interface to be managed, i.e. Ethernet1/1.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Manages desired state of the resource.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          },
          "vrf": {
            "description": "Name of VRF to be managed.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "interface",
          "transport",
          "vrf"
        ]
      }
    },
    {
      "nxos_vrrp": {
        "type": "object",
        "description": "Manages VRRP configuration on NX-OS switches.",
        "properties": {
          "admin_state": {
            "description": "Used to enable or disable the VRRP process.",
            "type": "string"
          },
          "authentication": {
            "description": "Clear text authentication string.",
            "type": "string"
          },
          "group": {
            "description": "VRRP group number.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "interface": {
            "description": "Full name of interface that is being managed for VRRP.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "priority": {
            "description": "VRRP priority.",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Specify desired state of the resource.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          },
          "vip": {
            "description": "VRRP virtual IP address.",
            "type": "string"
          }
        },
        "required": [
          "group",
          "host",
          "interface",
          "transport"
        ]
      }
    },
    {
      "nxos_vtp_domain": {
        "type": "object",
        "description": "Manages VTP domain configuration.",
        "properties": {
          "domain": {
            "description": "VTP domain name.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "domain",
          "host",
          "transport"
        ]
      }
    },
    {
      "nxos_vtp_password": {
        "type": "object",
        "description": "Manages VTP password configuration.",
        "properties": {
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Manage the state of the resource",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          },
          "vtp_password": {
            "description": "VTP password",
            "type": "string"
          }
        },
        "required": [
          "host",
          "transport"
        ]
      }
    },
    {
      "nxos_vtp_version": {
        "type": "object",
        "description": "Manages VTP version configuration.",
        "properties": {
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          },
          "version": {
            "description": "VTP version number.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "transport",
          "version"
        ]
      }
    },
    {
      "nxos_vxlan_vtep": {
        "type": "object",
        "description": "Manages VXLAN Network Virtualization Endpoint (NVE).",
        "properties": {
          "description": {
            "description": "Description of the NVE interface.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "host_reachability": {
            "description": "Specify mechanism for host reachability advertisement.",
            "type": "string"
          },
          "interface": {
            "description": "Interface name for the VXLAN Network Virtualization Endpoint.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "shutdown": {
            "description": "Administratively shutdown the NVE interface.",
            "type": "string"
          },
          "source_interface": {
            "description": "Specify the loopback interface whose IP address should be used for the NVE interface.",
            "type": "string"
          },
          "source_interface_hold_down_time": {
            "description": "Suppresses advertisement of the NVE loopback address until the overlay has converged.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Determines whether the config should be present or not on the device.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "interface",
          "transport"
        ]
      }
    },
    {
      "nxos_vxlan_vtep_vni": {
        "type": "object",
        "description": "Creates a Virtual Network Identifier member (VNI)",
        "properties": {
          "assoc_vrf": {
            "description": "This attribute is used to identify and separate processing VNIs that are associated with a VRF and used for routing. The VRF and VNI specified with this command must match the configuration of the VNI under the VRF.",
            "type": "string"
          },
          "config": {
            "description": "Configuration string to be used for module operations. If not specified, the module will use the current running configuration.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "include_defaults": {
            "description": "Specify to use or not the complete running configuration for module operations.",
            "type": "string"
          },
          "ingress_replication": {
            "description": "Specifies mechanism for host reachability advertisement.",
            "type": "string"
          },
          "interface": {
            "description": "Interface name for the VXLAN Network Virtualization Endpoint.",
            "type": "string"
          },
          "multicast_group": {
            "description": "The multicast group (range) of the VNI. Valid values are string and keyword 'default'.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `nxapi' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "peer_list": {
            "description": "Set the ingress-replication static peer list. Valid values are an array, a space-separated string of ip addresses, or the keyword 'default'.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `nxapi'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `nxos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "save": {
            "description": "Specify to save the running configuration after module operations.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "Determines whether the config should be present or not on the device.",
            "type": "string"
          },
          "suppress_arp": {
            "description": "Suppress arp under layer 2 VNI.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over cli (ssh) or nxapi.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport=nx api', otherwise this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the nxapi authentication depending on which transport is used. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          },
          "vni": {
            "description": "ID of the Virtual Network Identifier.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "interface",
          "transport",
          "vni"
        ]
      }
    },
    {
      "ohai": {
        "type": "object",
        "description": "Returns inventory data from `Ohai'",
        "properties": null
      }
    },
    {
      "open_iscsi": {
        "type": "object",
        "description": "Manage iscsi targets with open-iscsi",
        "properties": {
          "auto_node_startup": {
            "description": "whether the target node should be automatically connected at startup",
            "type": "string"
          },
          "discover": {
            "description": "whether the list of target nodes on the portal should be (re)discovered and added to the persistent iscsi database. Keep in mind that iscsiadm discovery resets configurtion, like node.startup to manual, hence combined with aut o_node_startup=ye s will allways return a changed state.",
            "type": "string"
          },
          "login": {
            "description": "whether the target node should be connected",
            "type": "string"
          },
          "node_auth": {
            "description": "discovery.sendtargets.auth.authmethod",
            "type": "string"
          },
          "node_pass": {
            "description": "discovery.sendtargets.auth.password",
            "type": "string"
          },
          "node_user": {
            "description": "discovery.sendtargets.auth.username",
            "type": "string"
          },
          "port": {
            "description": "the port on which the iscsi target process listens",
            "type": "string"
          },
          "portal": {
            "description": "the ip address of the iscsi target",
            "type": "string"
          },
          "show_nodes": {
            "description": "whether the list of nodes in the persistent iscsi database should be returned by the module",
            "type": "string"
          },
          "target": {
            "description": "the iscsi target name",
            "type": "string"
          }
        }
      }
    },
    {
      "openbsd_pkg": {
        "type": "object",
        "description": "Manage packages on OpenBSD.",
        "properties": {
          "build": {
            "description": "Build the package from source instead of downloading and installing a binary. Requires that the port source tree is already installed. Automatically builds and installs the 'sqlports' package, if it is not already installed.",
            "type": "string"
          },
          "name": {
            "description": "Name of the package.",
            "type": "string"
          },
          "ports_dir": {
            "description": "When used in combination with the 'build' option, allows overriding the default ports source directory.",
            "type": "string"
          },
          "state": {
            "description": "`present' will make sure the package is installed. `latest' will make sure the latest version of the package is installed. `absent' will make sure the specified package is not installed.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "state"
        ]
      }
    },
    {
      "opendj_backendprop": {
        "type": "object",
        "description": "Will update the backend configuration of OpenDJ via the dsconfig set-backend-prop command.",
        "properties": {
          "backend": {
            "description": "The name of the backend on which the property needs to be updated.",
            "type": "string"
          },
          "hostname": {
            "description": "The hostname of the OpenDJ server.",
            "type": "string"
          },
          "name": {
            "description": "The configuration setting to update.",
            "type": "string"
          },
          "opendj_bindir": {
            "description": "The path to the bin directory of OpenDJ.",
            "type": "string"
          },
          "password": {
            "description": "The password for the cn=Directory Manager user. Either password or passwordfile is needed.",
            "type": "string"
          },
          "passwordfile": {
            "description": "Location to the password file which holds the password for the cn=Directory Manager user. Either password or passwordfile is needed.",
            "type": "string"
          },
          "port": {
            "description": "The Admin port on which the OpenDJ instance is available.",
            "type": "string"
          },
          "state": {
            "description": "If configuration needs to be added/updated",
            "type": "string"
          },
          "username": {
            "description": "The username to connect to.",
            "type": "string"
          },
          "value": {
            "description": "The value for the configuration item.",
            "type": "string"
          }
        },
        "required": [
          "backend",
          "hostname",
          "name",
          "port",
          "value"
        ]
      }
    },
    {
      "openvswitch_bridge": {
        "type": "object",
        "description": "Manage Open vSwitch bridges",
        "properties": {
          "bridge": {
            "description": "Name of bridge to manage",
            "type": "string"
          },
          "external_ids": {
            "description": "A dictionary of external-ids. Omitting this parameter is a No-op. To  clear all external-ids pass an empty value.",
            "type": "string"
          },
          "fail_mode": {
            "description": "Set bridge fail-mode. The default value (None) is a No-op.",
            "type": "string"
          },
          "state": {
            "description": "Whether the bridge should exist",
            "type": "string"
          },
          "timeout": {
            "description": "How long to wait for ovs-vswitchd to respond",
            "type": "string"
          }
        },
        "required": "bridge"
      }
    },
    {
      "openvswitch_db": {
        "type": "object",
        "description": "Configure open vswitch database.",
        "properties": {
          "column": {
            "description": "Identifies the column in the record.",
            "type": "string"
          },
          "key": {
            "description": "Identifies the key in the record column",
            "type": "string"
          },
          "record": {
            "description": "Identifies the recoard in the table.",
            "type": "string"
          },
          "table": {
            "description": "Identifies the table in the database.",
            "type": "string"
          },
          "timeout": {
            "description": "How long to wait for ovs-vswitchd to respond",
            "type": "string"
          },
          "value": {
            "description": "Expected value for the table, record, column and key.",
            "type": "string"
          }
        },
        "required": [
          "column",
          "key",
          "record",
          "table",
          "value"
        ]
      }
    },
    {
      "openvswitch_port": {
        "type": "object",
        "description": "Manage Open vSwitch ports",
        "properties": {
          "bridge": {
            "description": "Name of bridge to manage",
            "type": "string"
          },
          "external_ids": {
            "description": "Dictionary of external_ids applied to a port.",
            "type": "string"
          },
          "port": {
            "description": "Name of port to manage on the bridge",
            "type": "string"
          },
          "set": {
            "description": "Set a single property on a port.",
            "type": "string"
          },
          "state": {
            "description": "Whether the port should exist",
            "type": "string"
          },
          "tag": {
            "description": "VLAN tag for this port",
            "type": "string"
          },
          "timeout": {
            "description": "How long to wait for ovs-vswitchd to respond",
            "type": "string"
          }
        },
        "required": [
          "bridge",
          "port"
        ]
      }
    },
    {
      "opkg": {
        "type": "object",
        "description": "Package manager for OpenWrt",
        "properties": {
          "force": {
            "description": "opkg --force parameter used",
            "type": "string"
          },
          "name": {
            "description": "name of package to install/remove",
            "type": "string"
          },
          "state": {
            "description": "state of the package",
            "type": "string"
          },
          "update_cache": {
            "description": "update the package db first",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "ops_command": {
        "type": "object",
        "description": "Run arbitrary commands on OpenSwitch devices.",
        "properties": {
          "commands": {
            "description": "List of commands to send to the remote ops device over the configured provider. The resulting output from the command is returned. If the `wait_for' argument is provided, the module is not returned until the condition is satisfied or the number of retires as expired.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.  Note this argument does not affect the SSH argument.",
            "type": "string"
          },
          "interval": {
            "description": "Configures the interval in seconds to wait between `retries' of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.",
            "type": "string"
          },
          "match": {
            "description": "The `match' argument is used in conjunction with the `wait_for' argument to specify the match policy.  Valid values are `all' or `any'.  If the value is set to `all' then all conditionals in the `wait_for' must be satisfied.  If the value is set to `any' then only one of the values must be satisfied.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `rest' transports.  Note this argument does not affect the SSH transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `rest'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).  Note this argument does not affect the SSH transport.",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `openswitch' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "retries": {
            "description": "Specifies the number of retries a command should by tried before it is considered failed. The command is run on the target device every retry and evaluated against the `wait_for' conditions.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over ssh, cli or REST.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport' argument is configured as rest.  If the transport argument is not `rest', this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the eAPI authentication depending on which transport is used. Note this argument does not affect the SSH transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          },
          "wait_for": {
            "description": "List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.",
            "type": "string"
          }
        },
        "required": [
          "commands",
          "host",
          "transport"
        ]
      }
    },
    {
      "ops_config": {
        "type": "object",
        "description": "Manage OpenSwitch configuration using CLI",
        "properties": {
          "after": {
            "description": "The ordered set of commands to append to the end of the command stack if a change needs to be made. Just like with `before' this allows the playbook designer to append a set of commands to be executed after the command set.",
            "type": "string"
          },
          "before": {
            "description": "The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.",
            "type": "string"
          },
          "config": {
            "description": "The module, by default, will connect to the remote device and retrieve the current running- config to use as a base for comparing against the contents of source.  There are times when it is not desirable to have the task get the current running-config for every task in a playbook.  The `config' argument allows the implementer to pass in the configuration to use as the base config for comparison.",
            "type": "string"
          },
          "force": {
            "description": "The force argument instructs the module to not consider the current devices running-config. When set to true, this will cause the module to push the contents of `src' into the device without first checking if already configured. Note this argument should be considered deprecated.  To achieve the equivalent, set the `match=none' which is idempotent.  This argument will be removed in a future release.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.  Note this argument does not affect the SSH argument.",
            "type": "string"
          },
          "lines": {
            "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config. Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.",
            "type": "string"
          },
          "match": {
            "description": "Instructs the module on the way to perform the matching of the set of commands against the current device config.  If match is set to `line', commands are matched line by line.  If match is set to `strict', command lines are matched with respect to position.  If match is set to `exact', command lines must be an equal match. Finally, if match is set to `none', the module will not attempt to compare the source configuration with the running configuration on the remote device.",
            "type": "string"
          },
          "parents": {
            "description": "The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `rest' transports.  Note this argument does not affect the SSH transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `rest'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).  Note this argument does not affect the SSH transport.",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `openswitch' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "replace": {
            "description": "Instructs the module on the way to perform the configuration on the device.  If the replace argument is set to `line' then the modified lines are pushed to the device in configuration mode.  If the replace argument is set to `block' then the entire command block is pushed to the device in configuration mode if any line is not correct.",
            "type": "string"
          },
          "save": {
            "description": "The `save' argument instructs the module to save the running- config to the startup-config at the conclusion of the module running.  If check mode is specified, this argument is ignored.",
            "type": "string"
          },
          "src": {
            "description": "The `src' argument provides a path to the configuration file to load into the remote system.  The path can either be a full system path to the configuration file if the value starts with / or relative to the root of the implemented role or playbook. This argument is mutually exclusive with the `lines' and `parents' arguments.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over ssh, cli or REST.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport' argument is configured as rest.  If the transport argument is not `rest', this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the eAPI authentication depending on which transport is used. Note this argument does not affect the SSH transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "transport"
        ]
      }
    },
    {
      "ops_facts": {
        "type": "object",
        "description": "Collect device specific facts from OpenSwitch",
        "properties": {
          "config": {
            "description": "When enabled, this argument will collect the current running configuration from the remote device.  If the `transport=rest' then the collected configuration will be the full system configuration.",
            "type": "string"
          },
          "endpoints": {
            "description": "Accepts a list of endpoints to retrieve from the remote device using the REST API.  The endpoints should be valid endpoints available on the device.  This argument is only valid when the `transport=rest'.",
            "type": "string"
          },
          "gather_subset": {
            "description": "When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, legacy, and interfaces. Can specify a list of values to include a larger subset.  Values can also be used with an initial `[!]' to specify that a specific subset should not be collected.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.  Note this argument does not affect the SSH argument.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.  This is a common argument used for either `cli' or `rest' transports.  Note this argument does not affect the SSH transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. This value applies to either `cli' or `rest'. The port value will default to the appropriate transport common port if none is provided in the task.  (cli=22, http=80, https=443).  Note this argument does not affect the SSH transport.",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `openswitch' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. This argument is only used for the `cli' transports. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "transport": {
            "description": "Configures the transport connection to use when connecting to the remote device. The transport argument supports connectivity to the device over ssh, cli or REST.",
            "type": "string"
          },
          "use_ssl": {
            "description": "Configures the `transport' to use SSL if set to true only when the `transport' argument is configured as rest.  If the transport argument is not `rest', this value is ignored.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate either the CLI login or the eAPI authentication depending on which transport is used. Note this argument does not affect the SSH transport. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "transport"
        ]
      }
    },
    {
      "os_auth": {
        "type": "object",
        "description": "Retrieve an auth token",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        }
      }
    },
    {
      "os_client_config": {
        "type": "object",
        "description": "Get OpenStack Client config",
        "properties": {
          "clouds": {
            "description": "List of clouds to limit the return list to. No value means return information on all configured clouds",
            "type": "string"
          }
        }
      }
    },
    {
      "os_flavor_facts": {
        "type": "object",
        "description": "Retrieve facts about one or more flavors",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "limit": {
            "description": "Limits the number of flavors returned. All matching flavors are returned by default.",
            "type": "string"
          },
          "name": {
            "description": "A flavor name. Cannot be used with `ram' or `vcpus'.",
            "type": "string"
          },
          "ram": {
            "description": "A string used for filtering flavors based on the amount of RAM (in MB) desired. This string accepts the following special values: 'MIN' (return flavors with the minimum amount of RAM), and 'MAX' (return flavors with the maximum amount of RAM). A specific amount of RAM may also be specified. Any flavors with this exact amount of RAM will be returned. A range of acceptable RAM may be given using a special syntax. Simply prefix the amount of RAM with one of these acceptable range values: '<', '>', '<=', '>='. These values represent less than, greater than, less than or equal to, and greater than or equal to, respectively.",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "vcpus": {
            "description": "A string used for filtering flavors based on the number of virtual CPUs desired. Format is the same as the `ram' parameter.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        }
      }
    },
    {
      "os_floating_ip": {
        "type": "object",
        "description": "Add/Remove floating IP from an instance",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "fixed_address": {
            "description": "To which fixed IP of server the floating IP address should be attached to.",
            "type": "string"
          },
          "floating_ip_address": {
            "description": "A floating IP address to attach or to detach. Required only if `state' is absent. When `state' is present can be used to specify a IP address to attach.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "network": {
            "description": "The name or ID of a neutron external network or a nova pool name.",
            "type": "string"
          },
          "purge": {
            "description": "When `state' is absent, indicates whether or not to delete the floating IP completely, or only detach it from the server. Default is to detach only.",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "reuse": {
            "description": "When `state' is present, and `floating_ip_addr ess' is not present, this parameter can be used to specify whether we should try to reuse a floating IP address already allocated to the project.",
            "type": "string"
          },
          "server": {
            "description": "The name or ID of the instance to which the IP address should be assigned.",
            "type": "string"
          },
          "state": {
            "description": "Should the resource be present or absent.",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        },
        "required": "server"
      }
    },
    {
      "os_group": {
        "type": "object",
        "description": "Manage OpenStack Identity Groups",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "description": {
            "description": "Group description",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "name": {
            "description": "Group name",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "state": {
            "description": "Should the resource be present or absent.",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "os_image": {
        "type": "object",
        "description": "Add/Delete images from OpenStack Cloud",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "container_format": {
            "description": "The format of the container",
            "type": "string"
          },
          "disk_format": {
            "description": "The format of the disk that is getting uploaded",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "filename": {
            "description": "The path to the file which has to be uploaded",
            "type": "string"
          },
          "is_public": {
            "description": "Whether the image can be accessed publicly. Note that publicizing an image requires admin role by default.",
            "type": "string"
          },
          "kernel": {
            "description": "The name of an existing kernel image that will be associated with this image",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "min_disk": {
            "description": "The minimum disk space (in GB) required to boot this image",
            "type": "string"
          },
          "min_ram": {
            "description": "The minimum ram (in MB) required to boot this image",
            "type": "string"
          },
          "name": {
            "description": "Name that has to be given to the image",
            "type": "string"
          },
          "owner": {
            "description": "The owner of the image",
            "type": "string"
          },
          "properties": {
            "description": "Additional properties to be associated with this image",
            "type": "string"
          },
          "ramdisk": {
            "description": "The name of an existing ramdisk image that will be associated with this image",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "state": {
            "description": "Should the resource be present or absent.",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "os_image_facts": {
        "type": "object",
        "description": "Retrieve facts about an image within OpenStack.",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "image": {
            "description": "Name or ID of the image",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        },
        "required": "image"
      }
    },
    {
      "os_ironic": {
        "type": "object",
        "description": "Create/Delete Bare Metal Resources from OpenStack",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "chassis_uuid": {
            "description": "Associate the node with a pre-defined chassis.",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "driver": {
            "description": "The name of the Ironic Driver to use with this node.",
            "type": "string"
          },
          "driver_info": {
            "description": "Information for this server's driver. Will vary based on which driver is in use. Any sub-field which is populated will be validated during creation.",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "ironic_url": {
            "description": "If noauth mode is utilized, this is required to be set to the endpoint URL for the Ironic API. Use with \"auth\" and \"auth_type\" settings set to None.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "name": {
            "description": "unique name identifier to be given to the resource.",
            "type": "string"
          },
          "nics": {
            "description": "A list of network interface cards, eg, \" - mac: aa:bb:cc:aa:bb:cc \"",
            "type": "string"
          },
          "properties": {
            "description": "Definition of the physical characteristics of this server, used for scheduling purposes",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "skip_update_of_driver_password": {
            "description": "Allows the code that would assert changes to nodes to skip the update if the change is a single line consisting of the password field. As of Kilo, by default, passwords are always masked to API requests, which means the logic as a result always attempts to re-assert the password field.",
            "type": "string"
          },
          "state": {
            "description": "Indicates desired state of the resource",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "uuid": {
            "description": "globally unique identifier (UUID) to be given to the resource. Will be auto- generated if not specified, and name is specified. Definition of a UUID will always take precedence to a name value.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        },
        "required": [
          "driver",
          "nics"
        ]
      }
    },
    {
      "os_ironic_inspect": {
        "type": "object",
        "description": "Explicitly triggers baremetal node introspection in ironic.",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "ironic_url": {
            "description": "If noauth mode is utilized, this is required to be set to the endpoint URL for the Ironic API. Use with \"auth\" and \"auth_type\" settings set to None.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "mac": {
            "description": "unique mac address that is used to attempt to identify the host.",
            "type": "string"
          },
          "name": {
            "description": "unique name identifier to identify the host in Ironic.",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "uuid": {
            "description": "globally unique identifier (UUID) to identify the host.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        }
      }
    },
    {
      "os_ironic_node": {
        "type": "object",
        "description": "Activate/Deactivate Bare Metal Resources from OpenStack",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "config_drive": {
            "description": "A configdrive file or HTTP(S) URL that will be passed along to the node.",
            "type": "string"
          },
          "deploy": {
            "description": "Indicates if the resource should be deployed. Allows for deployment logic to be disengaged and control of the node power or maintenance state to be changed.",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "instance_info": {
            "description": "Definition of the instance information which is used to deploy the node.  This information is only required when an instance is set to present.",
            "type": "string"
          },
          "ironic_url": {
            "description": "If noauth mode is utilized, this is required to be set to the endpoint URL for the Ironic API. Use with \"auth\" and \"auth_type\" settings set to None.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "maintenance": {
            "description": "A setting to allow the direct control if a node is in maintenance mode.",
            "type": "string"
          },
          "maintenance_reason": {
            "description": "A string expression regarding the reason a node is in a maintenance mode.",
            "type": "string"
          },
          "power": {
            "description": "A setting to allow power state to be asserted allowing nodes that are not yet deployed to be powered on, and nodes that are deployed to be powered off.",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "state": {
            "description": "Indicates desired state of the resource",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "uuid": {
            "description": "globally unique identifier (UUID) to be given to the resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        }
      }
    },
    {
      "os_keypair": {
        "type": "object",
        "description": "Add/Delete a keypair from OpenStack",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "name": {
            "description": "Name that has to be given to the key pair",
            "type": "string"
          },
          "public_key": {
            "description": "The public key that would be uploaded to nova and injected into VMs upon creation.",
            "type": "string"
          },
          "public_key_file": {
            "description": "Path to local file containing ssh public key. Mutually exclusive with public_key.",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "state": {
            "description": "Should the resource be present or absent.",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "os_keystone_domain": {
        "type": "object",
        "description": "Manage OpenStack Identity Domains",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "description": {
            "description": "Description of the domain",
            "type": "string"
          },
          "enabled": {
            "description": "Is the domain enabled",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "name": {
            "description": "Name that has to be given to the instance",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "state": {
            "description": "Should the resource be present or absent.",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "os_keystone_domain_facts": {
        "type": "object",
        "description": "Retrieve facts about one or more OpenStack domains",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "filters": {
            "description": "A dictionary of meta data to use for further filtering. Elements of this dictionary may be additional dictionaries.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "name": {
            "description": "Name or ID of the domain",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "os_keystone_role": {
        "type": "object",
        "description": "Manage OpenStack Identity Roles",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "name": {
            "description": "Role Name",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "state": {
            "description": "Should the resource be present or absent.",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "os_keystone_service": {
        "type": "object",
        "description": "Manage OpenStack Identity services",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "description": {
            "description": "Description of the service",
            "type": "string"
          },
          "enabled": {
            "description": "Is the service enabled",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "name": {
            "description": "Name of the service",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "service_type": {
            "description": "The type of service",
            "type": "string"
          },
          "state": {
            "description": "Should the resource be present or absent.",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "service_type"
        ]
      }
    },
    {
      "os_network": {
        "type": "object",
        "description": "Creates/removes networks from OpenStack",
        "properties": {
          "admin_state_up": {
            "description": "Whether the state should be marked as up or down.",
            "type": "string"
          },
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "external": {
            "description": "Whether this network is externally accessible.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "name": {
            "description": "Name to be assigned to the network.",
            "type": "string"
          },
          "project": {
            "description": "Project name or ID containing the network (name admin-only)",
            "type": "string"
          },
          "provider_network_type": {
            "description": "The type of physical network that maps to this network resource.",
            "type": "string"
          },
          "provider_physical_network": {
            "description": "The physical network where this network object is implemented.",
            "type": "string"
          },
          "provider_segmentation_id": {
            "description": "An isolated segment on the physical network. The `network_type' attribute defines the segmentation model. For example, if the `network_type' value is vlan, this ID is a vlan identifier. If the `network_type' value is gre, this ID is a gre key.",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "shared": {
            "description": "Whether this network is shared or not.",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the resource.",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "os_networks_facts": {
        "type": "object",
        "description": "Retrieve facts about one or more OpenStack networks.",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "filters": {
            "description": "A dictionary of meta data to use for further filtering. Elements of this dictionary may be additional dictionaries.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "name": {
            "description": "Name or ID of the Network",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        }
      }
    },
    {
      "os_nova_flavor": {
        "type": "object",
        "description": "Manage OpenStack compute flavors",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "disk": {
            "description": "Size of local disk, in GB.",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "ephemeral": {
            "description": "Ephemeral space size, in GB.",
            "type": "string"
          },
          "flavorid": {
            "description": "ID for the flavor. This is optional as a unique UUID will be assigned if a value is not specified.",
            "type": "string"
          },
          "is_public": {
            "description": "Make flavor accessible to the public.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "name": {
            "description": "Flavor name.",
            "type": "string"
          },
          "ram": {
            "description": "Amount of memory, in MB.",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "rxtx_factor": {
            "description": "RX/TX factor.",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the resource. When `state' is 'present', then `ram', `vcpus', and `disk' are all required. There are no default values for those parameters.",
            "type": "string"
          },
          "swap": {
            "description": "Swap space size, in MB.",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "vcpus": {
            "description": "Number of virtual CPUs.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "os_object": {
        "type": "object",
        "description": "Create or Delete objects and containers from OpenStack",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "container": {
            "description": "The name of the container in which to create the object",
            "type": "string"
          },
          "container_access": {
            "description": "desired container access level.",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "filename": {
            "description": "Path to local file to be uploaded.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "name": {
            "description": "Name to be give to the object. If omitted, operations will be on the entire container",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "state": {
            "description": "Should the resource be present or absent.",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        },
        "required": "container"
      }
    },
    {
      "os_port": {
        "type": "object",
        "description": "Add/Update/Delete ports from an OpenStack cloud.",
        "properties": {
          "admin_state_up": {
            "description": "Sets admin state.",
            "type": "string"
          },
          "allowed_address_pairs": {
            "description": "Allowed address pairs list.  Allowed address pairs are supported with dictionary structure. e.g.   allowed_address_p airs: - ip_address: 10.1.0.12 mac_address: ab:cd:ef:12:34:56 - ip_address: ...",
            "type": "string"
          },
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "device_id": {
            "description": "Device ID of device using this port.",
            "type": "string"
          },
          "device_owner": {
            "description": "The ID of the entity that uses this port.",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "extra_dhcp_opts": {
            "description": "Extra dhcp options to be assigned to this port. Extra options are supported with dictionary structure. e.g. extra_dhcp_opts: - opt_name: opt name1 opt_value: value1 - opt_name: ...",
            "type": "string"
          },
          "fixed_ips": {
            "description": "Desired IP and/or subnet for this port.  Subnet is referenced by subnet_id and IP is referenced by ip_address.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "mac_address": {
            "description": "MAC address of this port.",
            "type": "string"
          },
          "name": {
            "description": "Name that has to be given to the port.",
            "type": "string"
          },
          "network": {
            "description": "Network ID or name this port belongs to.",
            "type": "string"
          },
          "no_security_groups": {
            "description": "Do not associate a security group with this port.",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "security_groups": {
            "description": "Security group(s) ID(s) or name(s) associated with the port (comma separated string or YAML list)",
            "type": "string"
          },
          "state": {
            "description": "Should the resource be present or absent.",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        },
        "required": "network"
      }
    },
    {
      "os_port_facts": {
        "type": "object",
        "description": "Retrieve facts about ports within OpenStack.",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "filters": {
            "description": "A dictionary of meta data to use for further filtering. Elements of this dictionary will be matched against the returned port dictionaries. Matching is currently limited to strings within the port dictionary, or strings within nested dictionaries.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "port": {
            "description": "Unique name or ID of a port.",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        }
      }
    },
    {
      "os_project": {
        "type": "object",
        "description": "Manage OpenStack Projects",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "description": {
            "description": "Description for the project",
            "type": "string"
          },
          "domain_id": {
            "description": "Domain id to create the project in if the cloud supports domains. The domain_id parameter requires shade >= 1.8.0",
            "type": "string"
          },
          "enabled": {
            "description": "Is the project enabled",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "name": {
            "description": "Name for the project",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "state": {
            "description": "Should the resource be present or absent.",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "os_project_facts": {
        "type": "object",
        "description": "Retrieve facts about one or more OpenStack projects",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "domain": {
            "description": "Name or ID of the domain containing the project if the cloud supports domains",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "filters": {
            "description": "A dictionary of meta data to use for further filtering. Elements of this dictionary may be additional dictionaries.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "name": {
            "description": "Name or ID of the project",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "os_recordset": {
        "type": "object",
        "description": "Manage OpenStack DNS recordsets",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "description": {
            "description": "Description of the recordset",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "name": {
            "description": "Name of the recordset",
            "type": "string"
          },
          "records": {
            "description": "List of recordset definitions",
            "type": "string"
          },
          "recordset_type": {
            "description": "Recordset type",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "state": {
            "description": "Should the resource be present or absent.",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "ttl": {
            "description": "TTL (Time To Live) value in seconds",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          },
          "zone": {
            "description": "Zone managing the recordset",
            "type": "string"
          }
        },
        "required": [
          "name",
          "records",
          "recordset_type",
          "zone"
        ]
      }
    },
    {
      "os_router": {
        "type": "object",
        "description": "Create or delete routers from OpenStack",
        "properties": {
          "admin_state_up": {
            "description": "Desired admin state of the created or existing router.",
            "type": "string"
          },
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "enable_snat": {
            "description": "Enable Source NAT (SNAT) attribute.",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "external_fixed_ips": {
            "description": "The IP address parameters for the external gateway network. Each is a dictionary with the subnet name or ID (subnet) and the IP address to assign on the subnet (ip). If no IP is specified, one is automatically assigned from that subnet.",
            "type": "string"
          },
          "interfaces": {
            "description": "List of subnets to attach to the router internal interface.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "name": {
            "description": "Name to be give to the router",
            "type": "string"
          },
          "network": {
            "description": "Unique name or ID of the external gateway network. required `interfaces' or `enable_snat' are provided.",
            "type": "string"
          },
          "project": {
            "description": "Unique name or ID of the project.",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the resource",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "os_security_group": {
        "type": "object",
        "description": "Add/Delete security groups from an OpenStack cloud.",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "description": {
            "description": "Long description of the purpose of the security group",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "name": {
            "description": "Name that has to be given to the security group. This module requires that security group names be unique.",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "state": {
            "description": "Should the resource be present or absent.",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "os_security_group_rule": {
        "type": "object",
        "description": "Add/Delete rule from an existing security group",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "direction": {
            "description": "The direction in which the security group rule is applied. Not all providers support egress.",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "ethertype": {
            "description": "Must be IPv4 or IPv6, and addresses represented in CIDR must match the ingress or egress rules. Not all providers support IPv6.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "port_range_max": {
            "description": "Ending port",
            "type": "string"
          },
          "port_range_min": {
            "description": "Starting port",
            "type": "string"
          },
          "protocol": {
            "description": "IP protocols TCP UDP ICMP 112 (VRRP)",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "remote_group": {
            "description": "Name or ID of the Security group to link (exclusive with remote_ip_prefix)",
            "type": "string"
          },
          "remote_ip_prefix": {
            "description": "Source IP address(es) in CIDR notation (exclusive with remote_group)",
            "type": "string"
          },
          "security_group": {
            "description": "Name or ID of the security group",
            "type": "string"
          },
          "state": {
            "description": "Should the resource be present or absent.",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        },
        "required": "security_group"
      }
    },
    {
      "os_server": {
        "type": "object",
        "description": "Create/Delete Compute Instances from OpenStack",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "auto_ip": {
            "description": "Ensure instance has public ip however the cloud wants to do that",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "boot_from_volume": {
            "description": "Should the instance boot from a persistent volume created based on the image given. Mututally exclusive with boot_volume.",
            "type": "string"
          },
          "boot_volume": {
            "description": "Volume name or id to use as the volume to boot from. Implies boot_from_volume. Mutually exclusive with image and boot_from_volume.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "config_drive": {
            "description": "Whether to boot the server with config drive enabled",
            "type": "string"
          },
          "delete_fip": {
            "description": "When `state' is absent and this option is true, any floating IP associated with the instance will be deleted along with the instance.",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "flavor": {
            "description": "The name or id of the flavor in which the new instance has to be created. Mutually exclusive with flavor_ram",
            "type": "string"
          },
          "flavor_include": {
            "description": "Text to use to filter flavor names, for the case, such as Rackspace, where there are multiple flavors that have the same ram count. flavor_include is a positive match filter - it must exist in the flavor name.",
            "type": "string"
          },
          "flavor_ram": {
            "description": "The minimum amount of ram in MB that the flavor in which the new instance has to be created must have. Mutually exclusive with flavor.",
            "type": "string"
          },
          "floating_ip_pools": {
            "description": "Name of floating IP pool from which to choose a floating IP",
            "type": "string"
          },
          "floating_ips": {
            "description": "list of valid floating IPs that pre-exist to assign to this node",
            "type": "string"
          },
          "image": {
            "description": "The name or id of the base image to boot.",
            "type": "string"
          },
          "image_exclude": {
            "description": "Text to use to filter image names, for the case, such as HP, where there are multiple image names matching the common identifying portions. image_exclude is a negative match filter - it is text that may not exist in the image name. Defaults to \"(deprecated)\"",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "key_name": {
            "description": "The key pair name to be used when creating a instance",
            "type": "string"
          },
          "meta": {
            "description": "A list of key value pairs that should be provided as a metadata to the new instance or a string containing a list of key- value pairs. Eg: meta: \"key1=value 1,key2=value2\"",
            "type": "string"
          },
          "name": {
            "description": "Name that has to be given to the instance",
            "type": "string"
          },
          "network": {
            "description": "Name or ID of a network to attach this instance to. A simpler version of the nics parameter, only one of network or nics should be supplied.",
            "type": "string"
          },
          "nics": {
            "description": "A list of networks to which the instance's interface should be attached. Networks may be referenced by net-id/net-name /port-id or port- name. Also this accepts a string containing a list of (net/port)-(id /name) Eg: nics: \"net-id=uuid-1 ,port- name=myport\" Only one of network or nics should be supplied.",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "reuse_ips": {
            "description": "When `auto_ip' is true and this option is true, the `auto_ip' code will attempt to re-use unassigned floating ips in the project before creating a new one. It is important to note that it is impossible to safely do this concurrently, so if your use case involves concurrent server creation, it is highly recommended to set this to false and to delete the floating ip associated with a server when the server is deleted using `delete_fip'.",
            "type": "string"
          },
          "scheduler_hints": {
            "description": "Arbitrary key/value pairs to the scheduler for custom use",
            "type": "string"
          },
          "security_groups": {
            "description": "Names of the security groups to which the instance should be added. This may be a YAML list or a comma separated string.",
            "type": "string"
          },
          "state": {
            "description": "Should the resource be present or absent.",
            "type": "string"
          },
          "terminate_volume": {
            "description": "If true, delete volume when deleting instance (if booted from volume)",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "userdata": {
            "description": "Opaque blob of data which is made available to the instance",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "volume_size": {
            "description": "The size of the volume to create in GB if booting from volume based on an image.",
            "type": "string"
          },
          "volumes": {
            "description": "A list of preexisting volumes names or ids to attach to the instance",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        },
        "required": [
          "image",
          "name"
        ]
      }
    },
    {
      "os_server_actions": {
        "type": "object",
        "description": "Perform actions on Compute Instances from OpenStack",
        "properties": {
          "action": {
            "description": "Perform the given action. The lock and unlock actions always return changed as the servers API does not provide lock status.",
            "type": "string"
          },
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "server": {
            "description": "Name or ID of the instance",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        },
        "required": "server"
      }
    },
    {
      "os_server_facts": {
        "type": "object",
        "description": "Retrieve facts about one or more compute instances",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "detailed": {
            "description": "when true, return additional detail about servers at the expense of additional API calls.",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "server": {
            "description": "restrict results to servers with names matching this glob expression (e.g., C<web*>).",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        }
      }
    },
    {
      "os_server_group": {
        "type": "object",
        "description": "Manage OpenStack server groups",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "name": {
            "description": "Server group name.",
            "type": "string"
          },
          "policies": {
            "description": "A list of one or more policy names to associate with the server group. The list must contain at least one policy name. The current valid policy names are anti- affinity, affinity, soft- anti-affinity and soft-affinity.",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the resource. When `state' is 'present', then `policies' is required.",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "os_server_volume": {
        "type": "object",
        "description": "Attach/Detach Volumes from OpenStack VM's",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "device": {
            "description": "Device you want to attach. Defaults to auto finding a device name.",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "server": {
            "description": "Name or ID of server you want to attach a volume to",
            "type": "string"
          },
          "state": {
            "description": "Should the resource be present or absent.",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "volume": {
            "description": "Name or id of volume you want to attach to a server",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        },
        "required": [
          "server",
          "volume"
        ]
      }
    },
    {
      "os_stack": {
        "type": "object",
        "description": "Add/Remove Heat Stack",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "environment": {
            "description": "List of environment files that should be used for the stack creation",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "name": {
            "description": "Name of the stack that should be created, name could be char and digit, no space",
            "type": "string"
          },
          "parameters": {
            "description": "Dictionary of parameters for the stack creation",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "rollback": {
            "description": "Rollback stack creation",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the resource",
            "type": "string"
          },
          "template": {
            "description": "Path of the template file to use for the stack creation",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "os_subnet": {
        "type": "object",
        "description": "Add/Remove subnet to an OpenStack network",
        "properties": {
          "allocation_pool_end": {
            "description": "From the subnet pool the last IP that should be assigned to the virtual machines.",
            "type": "string"
          },
          "allocation_pool_start": {
            "description": "From the subnet pool the starting address from which the IP should be allocated.",
            "type": "string"
          },
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cidr": {
            "description": "The CIDR representation of the subnet that should be assigned to the subnet. Required when `state' is 'present'",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "dns_nameservers": {
            "description": "List of DNS nameservers for this subnet.",
            "type": "string"
          },
          "enable_dhcp": {
            "description": "Whether DHCP should be enabled for this subnet.",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "gateway_ip": {
            "description": "The ip that would be assigned to the gateway for this subnet",
            "type": "string"
          },
          "host_routes": {
            "description": "A list of host route dictionaries for the subnet.",
            "type": "string"
          },
          "ip_version": {
            "description": "The IP version of the subnet 4 or 6",
            "type": "string"
          },
          "ipv6_address_mode": {
            "description": "IPv6 address mode",
            "type": "string"
          },
          "ipv6_ra_mode": {
            "description": "IPv6 router advertisement mode",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "name": {
            "description": "The name of the subnet that should be created. Although Neutron allows for non- unique subnet names, this module enforces subnet name uniqueness.",
            "type": "string"
          },
          "network_name": {
            "description": "Name of the network to which the subnet should be attached Required when `state' is 'present'",
            "type": "string"
          },
          "no_gateway_ip": {
            "description": "The gateway IP would not be assigned for this subnet",
            "type": "string"
          },
          "project": {
            "description": "Project name or ID containing the subnet (name admin-only)",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the resource",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "os_subnets_facts": {
        "type": "object",
        "description": "Retrieve facts about one or more OpenStack subnets.",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "filters": {
            "description": "A dictionary of meta data to use for further filtering. Elements of this dictionary may be additional dictionaries.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "subnet": {
            "description": "Name or ID of the subnet",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        }
      }
    },
    {
      "os_user": {
        "type": "object",
        "description": "Manage OpenStack Identity Users",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "default_project": {
            "description": "Project name or ID that the user should be associated with by default",
            "type": "string"
          },
          "domain": {
            "description": "Domain to create the user in if the cloud supports domains",
            "type": "string"
          },
          "email": {
            "description": "Email address for the user",
            "type": "string"
          },
          "enabled": {
            "description": "Is the user enabled",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "name": {
            "description": "Username for the user",
            "type": "string"
          },
          "password": {
            "description": "Password for the user",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "state": {
            "description": "Should the resource be present or absent.",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "os_user_facts": {
        "type": "object",
        "description": "Retrieve facts about one or more OpenStack users",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "domain": {
            "description": "Name or ID of the domain containing the user if the cloud supports domains",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "filters": {
            "description": "A dictionary of meta data to use for further filtering. Elements of this dictionary may be additional dictionaries.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "name": {
            "description": "Name or ID of the user",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "os_user_group": {
        "type": "object",
        "description": "Associate OpenStack Identity users and groups",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "group": {
            "description": "Name or id for the group.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "state": {
            "description": "Should the user be present or absent in the group",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "user": {
            "description": "Name or id for the user",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        },
        "required": [
          "group",
          "user"
        ]
      }
    },
    {
      "os_user_role": {
        "type": "object",
        "description": "Associate OpenStack Identity users and roles",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "domain": {
            "description": "ID of the domain to scope the role association to. Valid only with keystone version 3, and required if `project' is not specified.",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "group": {
            "description": "Name or ID for the group. Valid only with keystone version 3. If `group' is not specified, then `user' is required. Both may not be specified.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "project": {
            "description": "Name or ID of the project to scope the role assocation to. If you are using keystone version 2, then this value is required.",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "role": {
            "description": "Name or ID for the role.",
            "type": "string"
          },
          "state": {
            "description": "Should the roles be present or absent on the user.",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "user": {
            "description": "Name or ID for the user. If `user' is not specified, then `group' is required. Both may not be specified.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        },
        "required": "role"
      }
    },
    {
      "os_volume": {
        "type": "object",
        "description": "Create/Delete Cinder Volumes",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "display_description": {
            "description": "String describing the volume",
            "type": "string"
          },
          "display_name": {
            "description": "Name of volume",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "image": {
            "description": "Image name or id for boot from volume",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "size": {
            "description": "Size of volume in GB. This parameter is required when the `state' parameter is 'present'.",
            "type": "string"
          },
          "snapshot_id": {
            "description": "Volume snapshot id to create from",
            "type": "string"
          },
          "state": {
            "description": "Should the resource be present or absent.",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "volume_type": {
            "description": "Volume type for volume",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          }
        },
        "required": "display_name"
      }
    },
    {
      "os_zone": {
        "type": "object",
        "description": "Manage OpenStack DNS zones",
        "properties": {
          "api_timeout": {
            "description": "How long should the socket layer wait before timing out for API calls. If this is omitted, nothing will be passed to the requests library.",
            "type": "string"
          },
          "auth": {
            "description": "Dictionary containing auth information as needed by the cloud's auth plugin strategy. For the default `password' plugin, this would contain `auth_url', `username', `password', `project_name' and any information about domains if the cloud supports them. For other plugins, this param will need to contain whatever parameters that auth plugin requires. This parameter is not needed if a named cloud is provided or OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "auth_type": {
            "description": "Name of the auth plugin to use. If the cloud uses something other than password authentication, the name of the plugin should be indicated here and the contents of the `auth' parameter should be updated accordingly.",
            "type": "string"
          },
          "availability_zone": {
            "description": "Name of the availability zone.",
            "type": "string"
          },
          "cacert": {
            "description": "A path to a CA Cert bundle that can be used as part of verifying SSL API requests.",
            "type": "string"
          },
          "cert": {
            "description": "A path to a client certificate to use as part of the SSL transaction",
            "type": "string"
          },
          "cloud": {
            "description": "Named cloud to operate against. Provides default values for `auth' and `auth_type'. This parameter is not needed if `auth' is provided or if OpenStack OS_* environment variables are present.",
            "type": "string"
          },
          "description": {
            "description": "Zone description",
            "type": "string"
          },
          "email": {
            "description": "Email of the zone owner (only applies if zone_type is primary)",
            "type": "string"
          },
          "endpoint_type": {
            "description": "Endpoint URL type to fetch from the service catalog.",
            "type": "string"
          },
          "key": {
            "description": "A path to a client key to use as part of the SSL transaction",
            "type": "string"
          },
          "masters": {
            "description": "Master nameservers (only applies if zone_type is secondary)",
            "type": "string"
          },
          "name": {
            "description": "Zone name",
            "type": "string"
          },
          "region_name": {
            "description": "Name of the region.",
            "type": "string"
          },
          "state": {
            "description": "Should the resource be present or absent.",
            "type": "string"
          },
          "timeout": {
            "description": "How long should ansible wait for the requested resource.",
            "type": "string"
          },
          "ttl": {
            "description": "TTL (Time To Live) value in seconds",
            "type": "string"
          },
          "validate_certs": {
            "description": "Whether or not SSL API requests should be verified.",
            "type": "string"
          },
          "wait": {
            "description": "Should ansible wait until the requested resource is complete.",
            "type": "string"
          },
          "zone_type": {
            "description": "Zone type",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "osx_defaults": {
        "type": "object",
        "description": "osx_defaults allows users to read, write, and delete Mac OS X user defaults from Ansible",
        "properties": {
          "array_add": {
            "description": "Add new elements to the array for a key which has an array as its value.",
            "type": "string"
          },
          "domain": {
            "description": "The domain is a domain name of the form com.companyname.a ppname.",
            "type": "string"
          },
          "host": {
            "description": "The host on which the preference should apply. The special value \"currentHost\" corresponds to the \"-currentHost\" switch of the defaults commandline tool.",
            "type": "string"
          },
          "key": {
            "description": "The key of the user preference",
            "type": "string"
          },
          "state": {
            "description": "The state of the user defaults",
            "type": "string"
          },
          "type": {
            "description": "The type of value to write.",
            "type": "string"
          },
          "value": {
            "description": "The value to write. Only required when state = present.",
            "type": "string"
          }
        },
        "required": "key"
      }
    },
    {
      "osx_say": {
        "type": "object",
        "description": "Makes an OSX computer to speak.",
        "properties": {
          "msg": {
            "description": "W h a t   t o   s a y",
            "type": "string"
          },
          "voice": {
            "description": "W h a t   v o i c e   t o   u s e",
            "type": "string"
          }
        },
        "required": "msg"
      }
    },
    {
      "ovh_ip_loadbalancing_backend": {
        "type": "object",
        "description": "Manage OVH IP LoadBalancing backends",
        "properties": {
          "application_key": {
            "description": "The applicationKey to use",
            "type": "string"
          },
          "application_secret": {
            "description": "The application secret to use",
            "type": "string"
          },
          "backend": {
            "description": "The IP address of the backend to update / modify / delete",
            "type": "string"
          },
          "consumer_key": {
            "description": "The consumer key to use",
            "type": "string"
          },
          "endpoint": {
            "description": "The endpoint to use ( for instance ovh-eu)",
            "type": "string"
          },
          "name": {
            "description": "Name of the LoadBalancing internal name (ip-X.X.X.X)",
            "type": "string"
          },
          "probe": {
            "description": "Determines the type of probe to use for this backend",
            "type": "string"
          },
          "state": {
            "description": "Determines wether the backend is to be created/modified or deleted",
            "type": "string"
          },
          "timeout": {
            "description": "The timeout in seconds used to wait for a task to be completed. Default is 120 seconds.",
            "type": "string"
          },
          "weight": {
            "description": "Determines the weight for this backend",
            "type": "string"
          }
        },
        "required": [
          "application_key",
          "application_secret",
          "backend",
          "consumer_key",
          "endpoint",
          "name"
        ]
      }
    },
    {
      "ovirt": {
        "type": "object",
        "description": "oVirt/RHEV platform management",
        "properties": {
          "disk_alloc": {
            "description": "define if disk is thin or preallocated",
            "type": "string"
          },
          "disk_int": {
            "description": "interface type of the disk",
            "type": "string"
          },
          "image": {
            "description": "template to use for the instance",
            "type": "string"
          },
          "instance_cores": {
            "description": "define the instance's number of cores",
            "type": "string"
          },
          "instance_cpus": {
            "description": "the instance's number of cpu's",
            "type": "string"
          },
          "instance_disksize": {
            "description": "size of the instance's disk in GB",
            "type": "string"
          },
          "instance_dns": {
            "description": "define the instance's Primary DNS server",
            "type": "string"
          },
          "instance_domain": {
            "description": "define the instance's Domain",
            "type": "string"
          },
          "instance_hostname": {
            "description": "define the instance's Hostname",
            "type": "string"
          },
          "instance_ip": {
            "description": "define the instance's IP",
            "type": "string"
          },
          "instance_key": {
            "description": "define the instance's Authorized key",
            "type": "string"
          },
          "instance_mem": {
            "description": "the instance's amount of memory in MB",
            "type": "string"
          },
          "instance_name": {
            "description": "the name of the instance to use",
            "type": "string"
          },
          "instance_netmask": {
            "description": "define the instance's Netmask",
            "type": "string"
          },
          "instance_network": {
            "description": "the logical network the machine should belong to",
            "type": "string"
          },
          "instance_nic": {
            "description": "name of the network interface in oVirt/RHEV",
            "type": "string"
          },
          "instance_os": {
            "description": "type of Operating System",
            "type": "string"
          },
          "instance_rootpw": {
            "description": "define the instance's Root password",
            "type": "string"
          },
          "instance_type": {
            "description": "define if the instance is a server or desktop",
            "type": "string"
          },
          "password": {
            "description": "password of the user to authenticate with",
            "type": "string"
          },
          "region": {
            "description": "the oVirt/RHEV datacenter where you want to deploy to",
            "type": "string"
          },
          "resource_type": {
            "description": "whether you want to deploy an image or create an instance from scratch.",
            "type": "string"
          },
          "sdomain": {
            "description": "the Storage Domain where you want to create the instance's disk on.",
            "type": "string"
          },
          "state": {
            "description": "create, terminate or remove instances",
            "type": "string"
          },
          "url": {
            "description": "the url of the oVirt instance",
            "type": "string"
          },
          "user": {
            "description": "the user to authenticate with",
            "type": "string"
          },
          "zone": {
            "description": "deploy the image to this oVirt cluster",
            "type": "string"
          }
        },
        "required": [
          "instance_name",
          "password",
          "url",
          "user"
        ]
      }
    },
    {
      "ovirt_auth": {
        "type": "object",
        "description": "Module to manage authentication to oVirt.",
        "properties": {
          "ca_file": {
            "description": "A PEM file containing the trusted CA certificates. The certificate presented by the server will be verified using these CA certificates. If `ca_file' parameter is not set, system wide CA certificate store is used.",
            "type": "string"
          },
          "compress": {
            "description": "A boolean flag indicating if the SDK should ask the server to send compressed responses. The default is `True'. Note that this is a hint for the server, and that it may return uncompressed data even when this parameter is set to `True'.",
            "type": "string"
          },
          "insecure": {
            "description": "A boolean flag that indicates if the server TLS certificate and host name should be checked.",
            "type": "string"
          },
          "kerberos": {
            "description": "A boolean flag indicating if Kerberos authentication should be used instead of the default basic authentication.",
            "type": "string"
          },
          "password": {
            "description": "The password of the user.",
            "type": "string"
          },
          "state": {
            "description": "Specifies if a token should be created or revoked.",
            "type": "string"
          },
          "timeout": {
            "description": "The maximum total time to wait for the response, in seconds. A value of zero (the default) means wait forever. If the timeout expires before the response is received an exception will be raised.",
            "type": "string"
          },
          "url": {
            "description": "A string containing the base URL of the server. For example: `htt ps://server.examp le.com/ovirt- engine/api'.",
            "type": "string"
          },
          "username": {
            "description": "The name of the user. For example: `admin@internal'.",
            "type": "string"
          }
        },
        "required": [
          "password",
          "url",
          "username"
        ]
      }
    },
    {
      "ovirt_disks": {
        "type": "object",
        "description": "Module to manage Virtual Machine and floating disks in oVirt.",
        "properties": {
          "auth": {
            "description": "Dictionary with values needed to create HTTP/HTTPS connection to oVirt: `username' [`required'] - The name of the user, something like ``admin@inte rnal'`. `password '[`required'] - The password of the user. `url'[`required'] - A string containing the base URL of the server, usually something like `` https://server.ex ample.com/ovirt- engine/api'`. `token' - Token to be used instead of login with username/pas sword. `insecure' - A boolean flag that indicates if the server TLS certificate and host name should be checked. `ca_file' - A PEM file containing the trusted CA certificates. The certificate presented by the server will be verified using these CA certificates. If ``ca_file'` parameter is not set, system wide CA certificate store is used. `kerberos' - A boolean flag indicating if Kerberos authentication should be used instead of the default basic authentication.",
            "type": "string"
          },
          "bootable": {
            "description": "`True' if the disk should be bootable. By default when disk is created it isn't bootable.",
            "type": "string"
          },
          "format": {
            "description": "Format of the disk. Either copy-on-write or raw.",
            "type": "string"
          },
          "id": {
            "description": "ID of the disk to manage. Either `id' or `name' is required.",
            "type": "string"
          },
          "interface": {
            "description": "Driver of the storage interface.",
            "type": "string"
          },
          "logical_unit": {
            "description": "Dictionary which describes LUN to be directly attached to VM: `address' - Address of the storage server. Used by iSCSI. `port' - Port of the storage server. Used by iSCSI. `target' - iSCSI target. `lun_id' - LUN id. `username' - CHAP Username to be used to access storage server. Used by iSCSI. `password' - CHAP Password of the user to be used to access storage server. Used by iSCSI. `storage_type' - Storage type either `fcp' or `iscsi'.",
            "type": "string"
          },
          "name": {
            "description": "Name of the disk to manage. Either `id' or `name'/`alias' is required.",
            "type": "string"
          },
          "poll_interval": {
            "description": "Number of the seconds the module waits until another poll request on entity status is sent.",
            "type": "string"
          },
          "profile": {
            "description": "Disk profile name to be attached to disk. By default profile is chosen by oVirt engine.",
            "type": "string"
          },
          "shareable": {
            "description": "`True' if the disk should be shareable. By default when disk is created it isn't shareable.",
            "type": "string"
          },
          "size": {
            "description": "Size of the disk. Size should be specified using IEC standard units. For example 10GiB, 1024MiB, etc.",
            "type": "string"
          },
          "state": {
            "description": "Should the Virtual Machine disk be present/absent/at tached/detached.",
            "type": "string"
          },
          "storage_domain": {
            "description": "Storage domain name where disk should be created. By default storage is chosen by oVirt engine.",
            "type": "string"
          },
          "timeout": {
            "description": "The amount of time in seconds the module should wait for the instance to get into desired state.",
            "type": "string"
          },
          "vm_id": {
            "description": "ID of the Virtual Machine to manage. Either `vm_id' or `vm_name' is required if `state' is `attached' or `detached'.",
            "type": "string"
          },
          "vm_name": {
            "description": "Name of the Virtual Machine to manage. Either `vm_id' or `vm_name' is required if `state' is `attached' or `detached'.",
            "type": "string"
          },
          "wait": {
            "description": "True if the module should wait for the entity to get into desired state.",
            "type": "string"
          }
        },
        "required": "auth"
      }
    },
    {
      "ovirt_vms": {
        "type": "object",
        "description": "Module to manage Virtual Machines in oVirt.",
        "properties": {
          "auth": {
            "description": "Dictionary with values needed to create HTTP/HTTPS connection to oVirt: `username' [`required'] - The name of the user, something like ``admin@inte rnal'`. `password '[`required'] - The password of the user. `url'[`required'] - A string containing the base URL of the server, usually something like `` https://server.ex ample.com/ovirt- engine/api'`. `token' - Token to be used instead of login with username/pas sword. `insecure' - A boolean flag that indicates if the server TLS certificate and host name should be checked. `ca_file' - A PEM file containing the trusted CA certificates. The certificate presented by the server will be verified using these CA certificates. If ``ca_file'` parameter is not set, system wide CA certificate store is used. `kerberos' - A boolean flag indicating if Kerberos authentication should be used instead of the default basic authentication.",
            "type": "string"
          },
          "boot_devices": {
            "description": "List of boot devices which should be used to boot. Choices `network', `hd' and `cdrom'. For example: ['cdrom', 'hd']. Default value is set by oVirt engine.",
            "type": "string"
          },
          "cd_iso": {
            "description": "ISO file from ISO storage domain which should be attached to Virtual Machine. If you pass empty string the CD will be ejected from VM. If used with `state' `running' or `present' and VM is running the CD will be attached to VM. If used with `state' `running' or `present' and VM is down the CD will be attached to VM persistently.",
            "type": "string"
          },
          "clone": {
            "description": "If `True' then the disks of the created virtual machine will be cloned and independent of the template. This parameter is used only when `state' is `running' or `present' and VM didn't exist before.",
            "type": "string"
          },
          "clone_permissions": {
            "description": "If `True' then the permissions of the template (only the direct ones, not the inherited ones) will be copied to the created virtual machine. This parameter is used only when `state' is `running' or `present' and VM didn't exist before.",
            "type": "string"
          },
          "cloud_init": {
            "description": "Dictionary with values for Unix-like Virtual Machine initialization using cloud init: `host_name' - Hostname to be set to Virtual Machine when deployed. `timezone' - Timezone to be set to Virtual Machine when deployed. `user_name' - Username to be used to set password to Virtual Machine when deployed. `root_password' - Password to be set for user specified by `user_name' parameter. `autho rized_ssh_keys' - Use this SSH keys to login to Virtual Machine.  `regenerate_ssh_k eys' - If `True' SSH keys will be regenerated on Virtual Machine. `custom_script' - Cloud-init script which will be executed on Virtual Machine when deployed. `dns_servers' - DNS servers to be configured on Virtual Machine. `dns_search' - DNS search domains to be configured on Virtual Machine.  `nic_boot_protoco l' - Set boot protocol of the network interface of Virtual Machine. Can be one of None, DHCP or Static. `nic_ip_address' - If boot protocol is static, set this IP address to network interface of Virtual Machine. `nic_netmask' - If boot protocol is static, set this netmask to network interface of Virtual Machine. `nic_gateway' - If boot protocol is static, set this gateway to network interface of Virtual Machine. `nic_name' - Set name to network interface of Virtual Machine. `nic_on_boot' - If `True' network interface will be set to start on boot.",
            "type": "string"
          },
          "cluster": {
            "description": "Name of the cluster, where Virtual Machine should be created. Required if creating VM.",
            "type": "string"
          },
          "cpu_cores": {
            "description": "Number of virtual CPUs cores of the Virtual Machine. Default value is set by oVirt engine.",
            "type": "string"
          },
          "cpu_shares": {
            "description": "Set a CPU shares for this Virtual Machine. Default value is set by oVirt engine.",
            "type": "string"
          },
          "cpu_sockets": {
            "description": "Number of virtual CPUs sockets of the Virtual Machine. Default value is set by oVirt engine.",
            "type": "string"
          },
          "delete_protected": {
            "description": "If `True' Virtual Machine will be set as delete protected. If `False' Virtual Machine won't be set as delete protected. If no value is passed, default value is set by oVirt engine.",
            "type": "string"
          },
          "disks": {
            "description": "List of disks, which should be attached to Virtual Machine. Disk is described by following dictionary: `name' - Name of the disk. Either `name' or `id' is reuqired. `id' - ID of the disk. Either `name' or `id' is reuqired. `interface' - Interface of the disk, either `virtio' or `IDE', default is `virtio'. `bootable' - `True' if the disk should be bootable, default is non bootable. `activate' - `True' if the disk should be activated, default is activated. `Note:' This parameter is used only when `state' is `running' or `present' and is able to only attach disks. To manage disks of the VM in more depth please use [ovirt_disks] module instead.",
            "type": "string"
          },
          "force": {
            "description": "Please check to `Synopsis' to more detailed description of force parameter, it can behave differently in different situations.",
            "type": "string"
          },
          "high_availability": {
            "description": "If `True' Virtual Machine will be set as highly available. If `False' Virtual Machine won't be set as highly available. If no value is passed, default value is set by oVirt engine.",
            "type": "string"
          },
          "host": {
            "description": "Specify host where Virtual Machine should be running. By default the host is chosen by engine scheduler. This parameter is used only when `state' is `running' or `present'.",
            "type": "string"
          },
          "id": {
            "description": "ID of the the Virtual Machine to manage.",
            "type": "string"
          },
          "memory": {
            "description": "Amount of memory of the Virtual Machine. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB). Default value is set by engine.",
            "type": "string"
          },
          "memory_guaranteed": {
            "description": "Amount of minimal guaranteed memory of the Virtual Machine. Prefix uses IEC 60027-2 standard (for example 1GiB, 1024MiB). ` memory_guaranteed ' parameter can't be lower than `memory' parameter. Default value is set by engine.",
            "type": "string"
          },
          "name": {
            "description": "Name of the the Virtual Machine to manage. If VM don't exists `name' is required. Otherwise `id' or `name' can be used.",
            "type": "string"
          },
          "nics": {
            "description": "List of NICs, which should be attached to Virtual Machine. NIC is described by following dictionary: `name' - Name of the NIC. `profile_name' - Profile name where NIC should be attached. `interface' - Type of the network interface. One of following: `virtio', `e1000', `rtl8139', default is `virtio'. `mac_address' - Custom MAC address of the network interface, by default it's obtained from MAC pool. `Note:' This parameter is used only when `state' is `running' or `present' and is able to only create NICs. To manage NICs of the VM in more depth please use [ovirt_nics] module instead.",
            "type": "string"
          },
          "operating_system": {
            "description": "Operating system of the Virtual Machine. Default value is set by oVirt engine.",
            "type": "string"
          },
          "poll_interval": {
            "description": "Number of the seconds the module waits until another poll request on entity status is sent.",
            "type": "string"
          },
          "state": {
            "description": "Should the Virtual Machine be running/stopped/pr esent/absent/susp ended/next_run. `present' and `running' are equal states. `next_run' state updates the VM and if the VM has next run configuration it will be rebooted. Please check `notes' to more detailed description of states.",
            "type": "string"
          },
          "stateless": {
            "description": "If `True' Virtual Machine will be set as stateless. If `False' Virtual Machine will be unset as stateless. If no value is passed, default value is set by oVirt engine.",
            "type": "string"
          },
          "sysprep": {
            "description": "Dictionary with values for Windows Virtual Machine initialization using sysprep: `host_name' - Hostname to be set to Virtual Machine when deployed. `active _directory_ou' - Active Directory Organizational Unit, to be used for login of user. `org_name' - Organization name to be set to Windows Virtual Machine. `domain' - Domain to be set to Windows Virtual Machine. `timezone' - Timezone to be set to Windows Virtual Machine. `ui_language' - UI language of the Windows Virtual Machine. `system_locale' - System localization of the Windows Virtual Machine. `input_locale' - Input localization of the Windows Virtual Machine.  `windows_license_ key' - License key to be set to Windows Virtual Machine. `user_name' - Username to be used for set password to Windows Virtual Machine. `root_password' - Password to be set for username to Windows Virtual Machine.",
            "type": "string"
          },
          "template": {
            "description": "Name of the template, which should be used to create Virtual Machine. Required if creating VM. If template is not specified and VM doesn't exist, VM will be created from `Blank' template.",
            "type": "string"
          },
          "timeout": {
            "description": "The amount of time in seconds the module should wait for the instance to get into desired state.",
            "type": "string"
          },
          "type": {
            "description": "Type of the Virtual Machine. Default value is set by oVirt engine.",
            "type": "string"
          },
          "wait": {
            "description": "True if the module should wait for the entity to get into desired state.",
            "type": "string"
          }
        },
        "required": "auth"
      }
    },
    {
      "package": {
        "type": "object",
        "description": "Generic OS package manager",
        "properties": {
          "name": {
            "description": "Package name, or package specifier with version, like `name-1.0'. Be aware that packages are not always named the same and this module will not 'translate' them per distro.",
            "type": "string"
          },
          "state": {
            "description": "Whether to install (`present', `latest'), or remove (`absent') a package.",
            "type": "string"
          },
          "use": {
            "description": "The required package manager module to use (yum, apt, etc). The default 'auto' will use existing facts or try to autodetect it. You should only use this field if the automatic selection is not working for some reason.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "state"
        ]
      }
    },
    {
      "pacman": {
        "type": "object",
        "description": "Manage packages with `pacman'",
        "properties": {
          "force": {
            "description": "When removing package - force remove package, without any checks. When update_cache - force redownload repo databases.",
            "type": "string"
          },
          "name": {
            "description": "Name of the package to install, upgrade, or remove.",
            "type": "string"
          },
          "recurse": {
            "description": "When removing a package, also remove its dependencies, provided that they are not required by other packages and were not explicitly installed by a user.",
            "type": "string"
          },
          "state": {
            "description": "Desired state of the package.",
            "type": "string"
          },
          "update_cache": {
            "description": "Whether or not to refresh the master package lists. This can be run as part of a package installation or as a separate step.",
            "type": "string"
          },
          "upgrade": {
            "description": "Whether or not to upgrade whole system",
            "type": "string"
          }
        }
      }
    },
    {
      "pagerduty": {
        "type": "object",
        "description": "Create PagerDuty maintenance windows",
        "properties": {
          "desc": {
            "description": "Short description of maintenance window.",
            "type": "string"
          },
          "hours": {
            "description": "Length of maintenance window in hours.",
            "type": "string"
          },
          "minutes": {
            "description": "Maintenance window in minutes (this is added to the hours).",
            "type": "string"
          },
          "name": {
            "description": "PagerDuty unique subdomain.",
            "type": "string"
          },
          "passwd": {
            "description": "PagerDuty user password.",
            "type": "string"
          },
          "requester_id": {
            "description": "ID of user making the request. Only needed when using a token and creating a mainte nance_window.",
            "type": "string"
          },
          "service": {
            "description": "A comma separated list of PagerDuty service IDs.",
            "type": "string"
          },
          "state": {
            "description": "Create a maintenance window or get a list of ongoing windows.",
            "type": "string"
          },
          "token": {
            "description": "A pagerduty token, generated on the pagerduty site. Can be used instead of user/passwd combination.",
            "type": "string"
          },
          "user": {
            "description": "PagerDuty user ID.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "passwd",
          "requester_id",
          "state",
          "token",
          "user"
        ]
      }
    },
    {
      "pagerduty_alert": {
        "type": "object",
        "description": "Trigger, acknowledge or resolve PagerDuty incidents",
        "properties": {
          "api_key": {
            "description": "The pagerduty API key (readonly access), generated on the pagerduty site.",
            "type": "string"
          },
          "client": {
            "description": "The name of the monitoring client that is triggering this event.",
            "type": "string"
          },
          "client_url": {
            "description": "The URL of the monitoring client that is triggering this event.",
            "type": "string"
          },
          "desc": {
            "description": "For `triggered' `state' - Required. Short description of the problem that led to this trigger. This field (or a truncated version) will be used when generating phone calls, SMS messages and alert emails. It will also appear on the incidents tables in the PagerDuty UI. The maximum length is 1024 characters. For `acknowledged' or `resolved' `state' - Text that will appear in the incident's log associated with this event.",
            "type": "string"
          },
          "incident_key": {
            "description": "Identifies the incident to which this `state' should be applied. For `triggered' `state' - If there's no open (i.e. unresolved) incident with this key, a new one will be created. If there's already an open incident with a matching key, this event will be appended to that incident's log. The event key provides an easy way to \"de-dup\" problem reports. For `acknowledged' or `resolved' `state' - This should be the incident_key you received back when the incident was first opened by a trigger event. Acknowledge events referencing resolved or nonexistent incidents will be discarded.",
            "type": "string"
          },
          "name": {
            "description": "PagerDuty unique subdomain.",
            "type": "string"
          },
          "service_key": {
            "description": "The GUID of one of your \"Generic API\" services. This is the \"service key\" listed on a Generic API's service detail page.",
            "type": "string"
          },
          "state": {
            "description": "Type of event to be sent.",
            "type": "string"
          }
        },
        "required": [
          "api_key",
          "name",
          "service_key",
          "state"
        ]
      }
    },
    {
      "pam_limits": {
        "type": "object",
        "description": "Modify Linux PAM limits",
        "properties": {
          "backup": {
            "description": "Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.",
            "type": "string"
          },
          "comment": {
            "description": "Comment associated with the limit.",
            "type": "string"
          },
          "dest": {
            "description": "Modify the limits.conf path.",
            "type": "string"
          },
          "domain": {
            "description": "A username, @groupname, wildcard, uid/gid range.",
            "type": "string"
          },
          "limit_item": {
            "description": "The limit to be set",
            "type": "string"
          },
          "limit_type": {
            "description": "Limit type, see `man limits' for an explanation",
            "type": "string"
          },
          "use_max": {
            "description": "If set to `yes', the maximal value will be used or conserved. If the specified value is superior to the value in the file, file content is replaced with the new value, else content is not modified.",
            "type": "string"
          },
          "use_min": {
            "description": "If set to `yes', the minimal value will be used or conserved. If the specified value is inferior to the value in the file, file content is replaced with the new value, else content is not modified.",
            "type": "string"
          },
          "value": {
            "description": "The value of the limit.",
            "type": "string"
          }
        },
        "required": [
          "domain",
          "limit_item",
          "limit_type",
          "value"
        ]
      }
    },
    {
      "patch": {
        "type": "object",
        "description": "Apply patch files using the GNU patch tool.",
        "properties": {
          "backup": {
            "description": "passes --backup --version-control=numbered to patch, producing numbered backup copies",
            "type": "string"
          },
          "basedir": {
            "description": "Path of a base directory in which the patch file will be applied. May be ommitted when `dest' option is specified, otherwise required.",
            "type": "string"
          },
          "binary": {
            "description": "Setting to `yes' will disable patch's heuristic for transforming CRLF line endings into LF. Line endings of src and dest must match. If set to `no', patch will replace CRLF in src files on POSIX.",
            "type": "string"
          },
          "dest": {
            "description": "Path of the file on the remote machine to be patched. The names of the files to be patched are usually taken from the patch file, but if there's just one file to be patched it can specified with this option.",
            "type": "string"
          },
          "remote_src": {
            "description": "If `no', it will search for src at originating/maste r machine, if `yes' it will go to the remote/target machine for the src. Default is `no'.",
            "type": "string"
          },
          "src": {
            "description": "Path of the patch file as accepted by the GNU patch tool. If `remote_src' is 'no', the patch source file is looked up from the module's \"files\" directory.",
            "type": "string"
          },
          "strip": {
            "description": "Number that indicates the smallest prefix containing leading slashes that will be stripped from each file name found in the patch file. For more information see the strip parameter of the GNU patch tool.",
            "type": "string"
          }
        },
        "required": "src"
      }
    },
    {
      "pause": {
        "type": "object",
        "description": "Pause playbook execution",
        "properties": {
          "minutes": {
            "description": "A positive number of minutes to pause for.",
            "type": "string"
          },
          "prompt": {
            "description": "Optional text to use for the prompt message.",
            "type": "string"
          },
          "seconds": {
            "description": "A positive number of seconds to pause for.",
            "type": "string"
          }
        }
      }
    },
    {
      "pear": {
        "type": "object",
        "description": "Manage pear/pecl packages",
        "properties": {
          "name": {
            "description": "Name of the package to install, upgrade, or remove.",
            "type": "string"
          },
          "state": {
            "description": "Desired state of the package.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "ping": {
        "type": "object",
        "description": "Try to connect to host, verify a usable python and return `pong' on success.",
        "properties": null
      }
    },
    {
      "pingdom": {
        "type": "object",
        "description": "Pause/unpause Pingdom alerts",
        "properties": {
          "checkid": {
            "description": "Pingdom ID of the check.",
            "type": "string"
          },
          "key": {
            "description": "Pingdom API key.",
            "type": "string"
          },
          "passwd": {
            "description": "Pingdom user password.",
            "type": "string"
          },
          "state": {
            "description": "Define whether or not the check should be running or paused.",
            "type": "string"
          },
          "uid": {
            "description": "Pingdom user ID.",
            "type": "string"
          }
        },
        "required": [
          "checkid",
          "key",
          "passwd",
          "state",
          "uid"
        ]
      }
    },
    {
      "pip": {
        "type": "object",
        "description": "Manages Python library dependencies.",
        "properties": {
          "chdir": {
            "description": "cd into this directory before running the command",
            "type": "string"
          },
          "editable": {
            "description": "Pass the editable flag for versioning URLs.",
            "type": "string"
          },
          "executable": {
            "description": "The explicit executable or a pathname to the executable to be used to run pip for a specific version of Python installed in the system. For example `pip-3.3', if there are both Python 2.7 and 3.3 installations in the system and you want to run pip for the Python 3.3 installation. It cannot be specified together with the 'virtualenv' parameter (added in 2.1). By default, it will take the appropriate version for the python interpreter use by ansible, e.g. pip3 on python 3, and pip2 or pip on python 2.",
            "type": "string"
          },
          "extra_args": {
            "description": "Extra arguments passed to pip.",
            "type": "string"
          },
          "name": {
            "description": "The name of a Python library to install or the url of the remote package. As of 2.2 you can supply a list of names.",
            "type": "string"
          },
          "requirements": {
            "description": "The path to a pip requirements file, which should be local to the remote system. File can be specified as a relative path if using the chdir option.",
            "type": "string"
          },
          "state": {
            "description": "The state of module The 'forcereinstall' option is only available in Ansible 2.1 and above.",
            "type": "string"
          },
          "umask": {
            "description": "The system umask to apply before installing the pip package. This is useful, for example, when installing on systems that have a very restrictive umask by default (e.g., 0077) and you want to pip install packages which are to be used by all users. Note that this requires you to specify desired umask mode in octal, with a leading 0 (e.g., 0077).",
            "type": "string"
          },
          "version": {
            "description": "The version number to install of the Python library specified in the `name' parameter",
            "type": "string"
          },
          "virtualenv": {
            "description": "An optional path to a `virtualenv' directory to install into. It cannot be specified together with the 'executable' parameter (added in 2.1). If the virtualenv does not exist, it will be created before installing packages. The optional virtuale nv_site_packages, virtualenv_comman d, and virtualenv_python options affect the creation of the virtualenv.",
            "type": "string"
          },
          "virtualenv_command": {
            "description": "The command or a pathname to the command to create the virtual environment with. For example `pyvenv', `virtualenv', `virtualenv2', `~ /bin/virtualenv', `/usr/local/bin/v irtualenv'.",
            "type": "string"
          },
          "virtualenv_python": {
            "description": "The Python executable used for creating the virtual environment. For example `python3.5', `python2.7'. When not specified, the Python version used to run the ansible module is used.",
            "type": "string"
          },
          "virtualenv_site_packages": {
            "description": "Whether the virtual environment will inherit packages from the global site- packages directory.  Note that if this setting is changed on an already existing virtual environment it will not have any effect, the environment must be deleted and newly created.",
            "type": "string"
          }
        }
      }
    },
    {
      "pkg5": {
        "type": "object",
        "description": "Manages packages with the Solaris 11 Image Packaging System",
        "properties": {
          "accept_licenses": {
            "description": "Accept any licences.",
            "type": "string"
          },
          "name": {
            "description": "An FRMI of the package(s) to be installed/removed /updated. Multiple packages may be specified, separated by `,'.",
            "type": "string"
          },
          "state": {
            "description": "Whether to install (`present', `latest'), or remove (`absent') a package.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "pkg5_publisher": {
        "type": "object",
        "description": "Manages Solaris 11 Image Packaging System publishers",
        "properties": {
          "enabled": {
            "description": "Is the repository enabled or disabled?",
            "type": "string"
          },
          "mirror": {
            "description": "A path or URL to the repository mirror. Multiple values may be provided.",
            "type": "string"
          },
          "name": {
            "description": "The publisher's name.",
            "type": "string"
          },
          "origin": {
            "description": "A path or URL to the repository. Multiple values may be provided.",
            "type": "string"
          },
          "state": {
            "description": "Whether to ensure that a publisher is present or absent.",
            "type": "string"
          },
          "sticky": {
            "description": "Packages installed from a sticky repository can only receive updates from that repository.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "pkgin": {
        "type": "object",
        "description": "Package manager for SmartOS, NetBSD, et al.",
        "properties": {
          "clean": {
            "description": "Clean packages cache",
            "type": "string"
          },
          "force": {
            "description": "Force package reinstall",
            "type": "string"
          },
          "full_upgrade": {
            "description": "Upgrade all packages to their newer versions",
            "type": "string"
          },
          "name": {
            "description": "Name of package to install/remove; multiple names may be given, separated by commas",
            "type": "string"
          },
          "state": {
            "description": "Intended state of the package",
            "type": "string"
          },
          "update_cache": {
            "description": "Update repository database. Can be run with other steps or on it's own.",
            "type": "string"
          },
          "upgrade": {
            "description": "Upgrade main packages to their newer versions",
            "type": "string"
          }
        }
      }
    },
    {
      "pkgng": {
        "type": "object",
        "description": "Package manager for FreeBSD >= 9.0",
        "properties": {
          "annotation": {
            "description": "A comma-separated list of keyvalue-pairs of the form `<+/-/:><key >[=<value>]'. A `+' denotes adding an annotation, a `-' denotes removing an annotation, and `:' denotes modifying an annotation. If setting or modifying annotations, a value must be provided.",
            "type": "string"
          },
          "autoremove": {
            "description": "Remove automatically installed packages which are no longer needed.",
            "type": "string"
          },
          "cached": {
            "description": "Use local package base instead of fetching an updated one.",
            "type": "string"
          },
          "chroot": {
            "description": "Pkg will chroot in the specified environment. Can not be used together with `rootdir' option.",
            "type": "string"
          },
          "name": {
            "description": "Name of package to install/remove.",
            "type": "string"
          },
          "pkgsite": {
            "description": "For pkgng versions before 1.1.4, specify packagesite to use for downloading packages. If not specified, use settings from `/u sr/local/etc/pkg. conf'. For newer pkgng versions, specify a the name of a repository configured in `/u sr/local/etc/pkg/ repos'.",
            "type": "string"
          },
          "rootdir": {
            "description": "For pkgng versions 1.5 and later, pkg will install all packages within the specified root directory. Can not be used together with `chroot' option.",
            "type": "string"
          },
          "state": {
            "description": "State of the package.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "pkgutil": {
        "type": "object",
        "description": "Manage CSW-Packages on Solaris",
        "properties": {
          "name": {
            "description": "Package name, e.g. (`CSWnrpe')",
            "type": "string"
          },
          "site": {
            "description": "Specifies the repository path to install the package from. Its global definition is done in `/etc/ opt/csw/pkgutil.c onf'.",
            "type": "string"
          },
          "state": {
            "description": "Whether to install (`present'), or remove (`absent') a package. The upgrade (`latest') operation will update/install the package to the latest version available. Note: The module has a limitation that (`latest') only works for one package, not lists of them.",
            "type": "string"
          },
          "update_catalog": {
            "description": "If you want to refresh your catalog from the mirror, set this to (`yes').",
            "type": "string"
          }
        },
        "required": [
          "name",
          "state"
        ]
      }
    },
    {
      "pn_cluster": {
        "type": "object",
        "description": "CLI command to create/delete a cluster.",
        "properties": {
          "pn_clipassword": {
            "description": "Provide login password if user is not root.",
            "type": "string"
          },
          "pn_cliswitch": {
            "description": "Target switch to run the cli on.",
            "type": "string"
          },
          "pn_cliusername": {
            "description": "Provide login username if user is not root.",
            "type": "string"
          },
          "pn_cluster_node1": {
            "description": "Specify the name of the first switch in the cluster. Required for 'cluster- create'.",
            "type": "string"
          },
          "pn_cluster_node2": {
            "description": "Specify the name of the second switch in the cluster. Required for 'cluster- create'.",
            "type": "string"
          },
          "pn_name": {
            "description": "Specify the name of the cluster.",
            "type": "string"
          },
          "pn_validate": {
            "description": "Validate the inter-switch links and state of switches in the cluster.",
            "type": "string"
          },
          "state": {
            "description": "Specify action to perform. Use 'present' to create cluster and 'absent' to delete cluster.",
            "type": "string"
          }
        },
        "required": [
          "pn_name",
          "state"
        ]
      }
    },
    {
      "pn_ospf": {
        "type": "object",
        "description": "CLI command to add/remove ospf protocol to a vRouter.",
        "properties": {
          "pn_clipassword": {
            "description": "Provide login password if user is not root.",
            "type": "string"
          },
          "pn_cliswitch": {
            "description": "Target switch to run the CLI on.",
            "type": "string"
          },
          "pn_cliusername": {
            "description": "Provide login username if user is not root.",
            "type": "string"
          },
          "pn_network_ip": {
            "description": "Specify the network IP (IPv4 or IPv6) address.",
            "type": "string"
          },
          "pn_ospf_area": {
            "description": "Stub area number for the configuration. Required for vrouter-ospf- add.",
            "type": "string"
          },
          "pn_vrouter_name": {
            "description": "Specify the name of the vRouter.",
            "type": "string"
          },
          "state": {
            "description": "Assert the state of the ospf. Use 'present' to add ospf and 'absent' to remove ospf.",
            "type": "string"
          }
        },
        "required": [
          "pn_network_ip",
          "pn_vrouter_name",
          "state"
        ]
      }
    },
    {
      "pn_ospfarea": {
        "type": "object",
        "description": "CLI command to add/remove ospf area to/from a vrouter.",
        "properties": {
          "pn_clipassword": {
            "description": "Login password.",
            "type": "string"
          },
          "pn_cliswitch": {
            "description": "Target switch(es) to run the CLI on.",
            "type": "string"
          },
          "pn_cliusername": {
            "description": "Login username.",
            "type": "string"
          },
          "pn_ospf_area": {
            "description": "Specify the OSPF area number.",
            "type": "string"
          },
          "pn_prefix_listin": {
            "description": "OSPF prefix list for filtering incoming packets.",
            "type": "string"
          },
          "pn_prefix_listout": {
            "description": "OSPF prefix list for filtering outgoing packets.",
            "type": "string"
          },
          "pn_quiet": {
            "description": "Enable/disable system information.",
            "type": "string"
          },
          "pn_stub_type": {
            "description": "Specify the OSPF stub type.",
            "type": "string"
          },
          "pn_vrouter_name": {
            "description": "Specify the name of the vRouter.",
            "type": "string"
          },
          "state": {
            "description": "State the action to perform. Use 'present' to add ospf-area, 'absent' to remove ospf-area and 'update' to modify ospf-area.",
            "type": "string"
          }
        },
        "required": [
          "pn_clipassword",
          "pn_cliusername",
          "pn_ospf_area",
          "pn_vrouter_name",
          "state"
        ]
      }
    },
    {
      "pn_show": {
        "type": "object",
        "description": "Run show commands on nvOS device.",
        "properties": {
          "pn_clipassword": {
            "description": "Provide login password if user is not root.",
            "type": "string"
          },
          "pn_cliswitch": {
            "description": "Target switch(es) to run the cli on.",
            "type": "string"
          },
          "pn_cliusername": {
            "description": "Provide login username if user is not root.",
            "type": "string"
          },
          "pn_command": {
            "description": "The `pn_command' takes a CLI show command as value.",
            "type": "string"
          },
          "pn_options": {
            "description": "Specify formatting options.",
            "type": "string"
          },
          "pn_parameters": {
            "description": "Display output using a specific parameter. Use 'all' to display possible output. List of comma separated parameters.",
            "type": "string"
          }
        },
        "required": "pn_command"
      }
    },
    {
      "pn_trunk": {
        "type": "object",
        "description": "CLI command to create/delete/modify a trunk.",
        "properties": {
          "pn_broadcast_level": {
            "description": "Specify a broadcast level in percent. The default value is 100%.",
            "type": "string"
          },
          "pn_clipassword": {
            "description": "Provide login password if user is not root.",
            "type": "string"
          },
          "pn_cliswitch": {
            "description": "Target switch(es) to run the cli on.",
            "type": "string"
          },
          "pn_cliusername": {
            "description": "Provide login username if user is not root.",
            "type": "string"
          },
          "pn_description": {
            "description": "Specify a description for the trunk configuration.",
            "type": "string"
          },
          "pn_edge_switch": {
            "description": "Specify if the switch is an edge switch.",
            "type": "string"
          },
          "pn_egress_rate_limit": {
            "description": "Specify an egress port data rate limit for the configuration.",
            "type": "string"
          },
          "pn_host": {
            "description": "Host facing port control setting.",
            "type": "string"
          },
          "pn_jumbo": {
            "description": "Specify if the port can receive jumbo frames.",
            "type": "string"
          },
          "pn_lacp_fallback": {
            "description": "Specify the LACP fallback mode as bundles or individual.",
            "type": "string"
          },
          "pn_lacp_fallback_timeout": {
            "description": "Specify the LACP fallback timeout in seconds. The range is between 30 and 60 seconds with a default value of 50 seconds.",
            "type": "string"
          },
          "pn_lacp_mode": {
            "description": "Specify the LACP mode for the configuration.",
            "type": "string"
          },
          "pn_lacp_priority": {
            "description": "Specify the LACP priority. This is a number between 1 and 65535 with a default value of 32768.",
            "type": "string"
          },
          "pn_lacp_timeout": {
            "description": "Specify the LACP time out as slow (30 seconds) or fast (4seconds). The default value is slow.",
            "type": "string"
          },
          "pn_loopback": {
            "description": "Specify loopback if you want to use loopback.",
            "type": "string"
          },
          "pn_loopvlans": {
            "description": "Specify a list of looping vlans.",
            "type": "string"
          },
          "pn_mirror_receive": {
            "description": "Specify if the configuration receives mirrored traffic.",
            "type": "string"
          },
          "pn_name": {
            "description": "Specify the name for the trunk configuration.",
            "type": "string"
          },
          "pn_pause": {
            "description": "Specify if pause frames are sent.",
            "type": "string"
          },
          "pn_port_macaddr": {
            "description": "Specify the MAC address of the port.",
            "type": "string"
          },
          "pn_ports": {
            "description": "Specify the port number(s) for the link(s) to aggregate into the trunk. Required for trunk-create.",
            "type": "string"
          },
          "pn_routing": {
            "description": "Specify if the port participates in routing on the network.",
            "type": "string"
          },
          "pn_speed": {
            "description": "Specify the port speed or disable the port.",
            "type": "string"
          },
          "pn_unkown_mcast_level": {
            "description": "Specify an unkown multicast level in percent. The default value is 100%.",
            "type": "string"
          },
          "pn_unkown_ucast_level": {
            "description": "Specify an unkown unicast level in percent. The default value is 100%.",
            "type": "string"
          },
          "state": {
            "description": "State the action to perform. Use 'present' to create trunk, 'absent' to delete trunk and 'update' to modify trunk.",
            "type": "string"
          }
        },
        "required": [
          "pn_name",
          "state"
        ]
      }
    },
    {
      "pn_vlag": {
        "type": "object",
        "description": "CLI command to create/delete/modify vlag.",
        "properties": {
          "pn_clipassword": {
            "description": "Provide login password if user is not root.",
            "type": "string"
          },
          "pn_cliswitch": {
            "description": "Target switch(es) to run this command on.",
            "type": "string"
          },
          "pn_cliusername": {
            "description": "Provide login username if user is not root.",
            "type": "string"
          },
          "pn_failover_action": {
            "description": "Specify the failover action as move or ignore.",
            "type": "string"
          },
          "pn_lacp_fallback": {
            "description": "Specify the LACP fallback mode as bundles or individual.",
            "type": "string"
          },
          "pn_lacp_fallback_timeout": {
            "description": "Specify the LACP fallback timeout in seconds. The range is between 30 and 60 seconds with a default value of 50 seconds.",
            "type": "string"
          },
          "pn_lacp_mode": {
            "description": "Specify the LACP mode.",
            "type": "string"
          },
          "pn_lacp_timeout": {
            "description": "Specify the LACP timeout as slow(30 seconds) or fast(4 seconds).",
            "type": "string"
          },
          "pn_mode": {
            "description": "Specify the mode for the VLAG. Active-standby indicates one side is active and the other side is in standby mode. Active-active indicates that both sides of the vlag are up by default.",
            "type": "string"
          },
          "pn_name": {
            "description": "The `pn_name' takes a valid name for vlag configuration.",
            "type": "string"
          },
          "pn_peer_port": {
            "description": "Specify the peer VLAG port. Required for vlag- create.",
            "type": "string"
          },
          "pn_peer_switch": {
            "description": "Specify the fabric-name of the peer switch.",
            "type": "string"
          },
          "pn_port": {
            "description": "Specify the local VLAG port. Required for vlag- create.",
            "type": "string"
          },
          "state": {
            "description": "State the action to perform. Use 'present' to create vlag, 'absent' to delete vlag and 'update' to modify vlag.",
            "type": "string"
          }
        },
        "required": [
          "pn_name",
          "state"
        ]
      }
    },
    {
      "pn_vlan": {
        "type": "object",
        "description": "CLI command to create/delete a VLAN.",
        "properties": {
          "pn_clipassword": {
            "description": "Provide login password if user is not root.",
            "type": "string"
          },
          "pn_cliswitch": {
            "description": "Target switch(es) to run the cli on.",
            "type": "string"
          },
          "pn_cliusername": {
            "description": "Provide login username if user is not root.",
            "type": "string"
          },
          "pn_description": {
            "description": "Specify a description for the VLAN.",
            "type": "string"
          },
          "pn_ports": {
            "description": "Specifies the switch network data port number, list of ports, or range of ports. Port numbers must ne in the range of 1 to 64.",
            "type": "string"
          },
          "pn_scope": {
            "description": "Specify a scope for the VLAN. Required for vlan- create.",
            "type": "string"
          },
          "pn_stats": {
            "description": "Specify if you want to collect statistics for a VLAN. Statistic collection is enabled by default.",
            "type": "string"
          },
          "pn_untagged_ports": {
            "description": "Specifies the ports that should have untagged packets mapped to the VLAN. Untagged packets are packets that do not contain IEEE 802.1Q VLAN tags.",
            "type": "string"
          },
          "pn_vlanid": {
            "description": "Specify a VLAN identifier for the VLAN. This is a value between 2 and 4092.",
            "type": "string"
          },
          "state": {
            "description": "State the action to perform. Use 'present' to create vlan and 'absent' to delete vlan.",
            "type": "string"
          }
        },
        "required": [
          "pn_vlanid",
          "state"
        ]
      }
    },
    {
      "pn_vrouter": {
        "type": "object",
        "description": "CLI command to create/delete/modify a vrouter.",
        "properties": {
          "pn_bgp_as": {
            "description": "Specify the Autonomous System Number(ASN) if the vRouter runs Border Gateway Protocol(BGP).",
            "type": "string"
          },
          "pn_bgp_max_paths": {
            "description": "Specify the maximum number of paths for BGP. This is a number between 1 and 255 or 0 to unset.",
            "type": "string"
          },
          "pn_bgp_options": {
            "description": "Specify other BGP options as a whitespaces separated string within single quotes ''.",
            "type": "string"
          },
          "pn_bgp_redistribute": {
            "description": "Specify how BGP routes are redistributed.",
            "type": "string"
          },
          "pn_clipassword": {
            "description": "Provide login password if user is not root.",
            "type": "string"
          },
          "pn_cliswitch": {
            "description": "Target switch(es) to run the CLI on.",
            "type": "string"
          },
          "pn_cliusername": {
            "description": "Provide login username if user is not root.",
            "type": "string"
          },
          "pn_hw_vrrp_id": {
            "description": "Specifies the VRRP ID for a hardware vrouter.",
            "type": "string"
          },
          "pn_name": {
            "description": "Specify the name of the vRouter.",
            "type": "string"
          },
          "pn_ospf_options": {
            "description": "Specify other OSPF options as a whitespaces separated string within single quotes ''.",
            "type": "string"
          },
          "pn_ospf_redistribute": {
            "description": "Specify how OSPF routes are redistributed.",
            "type": "string"
          },
          "pn_rip_redistribute": {
            "description": "Specify how RIP routes are redistributed.",
            "type": "string"
          },
          "pn_router_id": {
            "description": "Specify the vRouter IP address.",
            "type": "string"
          },
          "pn_router_type": {
            "description": "Specify if the vRouter uses software or hardware. Note that if you specify hardware as router type, you cannot assign IP addresses using DHCP. You must specify a static IP address.",
            "type": "string"
          },
          "pn_service_state": {
            "description": "Specify to enable or disable vRouter service.",
            "type": "string"
          },
          "pn_service_type": {
            "description": "Specify if the vRouter is a dedicated or shared VNET service.",
            "type": "string"
          },
          "pn_vnet": {
            "description": "Specify the name of the VNET. Required for vrouter-create.",
            "type": "string"
          },
          "state": {
            "description": "State the action to perform. Use 'present' to create vrouter, 'absent' to delete vrouter and 'update' to modify vrouter.",
            "type": "string"
          }
        },
        "required": [
          "pn_name",
          "state"
        ]
      }
    },
    {
      "pn_vrouterbgp": {
        "type": "object",
        "description": "CLI command to add/remove/modify vrouter-bgp.",
        "properties": {
          "pn_bfd": {
            "description": "Specify if you want BFD protocol support for fault detection.",
            "type": "string"
          },
          "pn_clipassword": {
            "description": "Provide login password if user is not root.",
            "type": "string"
          },
          "pn_cliswitch": {
            "description": "Target switch(es) to run the cli on.",
            "type": "string"
          },
          "pn_cliusername": {
            "description": "Provide login username if user is not root.",
            "type": "string"
          },
          "pn_default_originate": {
            "description": "Specify if you want announce default routes to the neighbor or not.",
            "type": "string"
          },
          "pn_ebgp": {
            "description": "Specify a value for external BGP to accept or attempt BGP connections to external peers, not directly connected, on the network. This is a value between 1 and 255.",
            "type": "string"
          },
          "pn_holdtime": {
            "description": "Specify BGP neighbor holdtime in seconds.",
            "type": "string"
          },
          "pn_keepalive": {
            "description": "Specify BGP neighbor keepalive interval in seconds.",
            "type": "string"
          },
          "pn_max_prefix": {
            "description": "Specify the maximum number of prefixes.",
            "type": "string"
          },
          "pn_max_prefix_warn": {
            "description": "Specify if you want a warning message when the maximum number of prefixes is exceeded.",
            "type": "string"
          },
          "pn_multiprotocol": {
            "description": "Specify a multi-protocol for BGP.",
            "type": "string"
          },
          "pn_neighbor": {
            "description": "Specify a neighbor IP address to use for BGP. Required for vrouter-bgp-add.",
            "type": "string"
          },
          "pn_next_hop_self": {
            "description": "Specify if the next-hop is the same router or not.",
            "type": "string"
          },
          "pn_override_capability": {
            "description": "Specify if you want to override capability.",
            "type": "string"
          },
          "pn_password": {
            "description": "Specify a password, if desired.",
            "type": "string"
          },
          "pn_prefix_listin": {
            "description": "Specify the prefix list to filter traffic inbound.",
            "type": "string"
          },
          "pn_prefix_listout": {
            "description": "Specify the prefix list to filter traffic outbound.",
            "type": "string"
          },
          "pn_remote_as": {
            "description": "Specify the remote Autonomous System(AS) number. This value is between 1 and 4294967295. Required for vrouter-bgp-add.",
            "type": "string"
          },
          "pn_route_mapin": {
            "description": "Specify inbound route map for neighbor.",
            "type": "string"
          },
          "pn_route_mapout": {
            "description": "Specify outbound route map for neighbor.",
            "type": "string"
          },
          "pn_route_reflector": {
            "description": "Specify if a route reflector client is used.",
            "type": "string"
          },
          "pn_soft_reconfig": {
            "description": "Specify if you want a soft reconfiguration of inbound traffic.",
            "type": "string"
          },
          "pn_vrouter_name": {
            "description": "Specify a name for the vRouter service.",
            "type": "string"
          },
          "pn_weight": {
            "description": "Specify a default weight value between 0 and 65535 for the neighbor routes.",
            "type": "string"
          },
          "state": {
            "description": "State the action to perform. Use 'present' to add bgp, 'absent' to remove bgp and 'update' to modify bgp.",
            "type": "string"
          }
        },
        "required": [
          "pn_vrouter_name",
          "state"
        ]
      }
    },
    {
      "pn_vrouterif": {
        "type": "object",
        "description": "CLI command to add/remove/modify vrouter-interface.",
        "properties": {
          "pn_alias": {
            "description": "Specify an alias for the interface.",
            "type": "string"
          },
          "pn_assignment": {
            "description": "Specify the DHCP method for IP address assignment.",
            "type": "string"
          },
          "pn_clipassword": {
            "description": "Provide login password if user is not root.",
            "type": "string"
          },
          "pn_cliswitch": {
            "description": "Target switch to run the cli on.",
            "type": "string"
          },
          "pn_cliusername": {
            "description": "Provide login username if user is not root.",
            "type": "string"
          },
          "pn_exclusive": {
            "description": "Specify if the interface is exclusive to the configuration. Exclusive means that other configurations cannot use the interface. Exclusive is specified when you configure the interface as span interface and allows higher throughput through the interface.",
            "type": "string"
          },
          "pn_interface": {
            "description": "Specify if the interface is management, data or span interface.",
            "type": "string"
          },
          "pn_interface_ip": {
            "description": "Specify the IP address of the interface in x.x.x.x/n format.",
            "type": "string"
          },
          "pn_l3port": {
            "description": "Specify a Layer 3 port for the interface.",
            "type": "string"
          },
          "pn_nic_enable": {
            "description": "Specify if the NIC is enabled or not",
            "type": "string"
          },
          "pn_nic_str": {
            "description": "Specify the type of NIC. Used for vrouter- interface remove/modify.",
            "type": "string"
          },
          "pn_secondary_macs": {
            "description": "Specify a secondary MAC address for the interface.",
            "type": "string"
          },
          "pn_vlan": {
            "description": "Specify the VLAN identifier. This is a value between 1 and 4092.",
            "type": "string"
          },
          "pn_vrouter_name": {
            "description": "Specify the name of the vRouter interface.",
            "type": "string"
          },
          "pn_vrrp_adv_int": {
            "description": "Specify a VRRP advertisement interval in milliseconds. The range is from 30 to 40950 with a default value of 1000.",
            "type": "string"
          },
          "pn_vrrp_id": {
            "description": "Specify the ID for the VRRP interface. The IDs on both vRouters must be the same IS number.",
            "type": "string"
          },
          "pn_vrrp_priority": {
            "description": "Specify the priority for the VRRP interface. This is a value between 1 (lowest) and 255 (highest).",
            "type": "string"
          },
          "pn_vxlan": {
            "description": "Specify the VXLAN identifier. This is a value between 1 and 16777215.",
            "type": "string"
          },
          "state": {
            "description": "State the action to perform. Use 'present' to add vrouter interface, 'absent' to remove vrouter interface and 'update' to modify vrouter interface.",
            "type": "string"
          }
        },
        "required": [
          "pn_vrouter_name",
          "state"
        ]
      }
    },
    {
      "pn_vrouterlbif": {
        "type": "object",
        "description": "CLI command to add/remove vrouter-loopback-interface.",
        "properties": {
          "pn_clipassword": {
            "description": "Provide login password if user is not root.",
            "type": "string"
          },
          "pn_cliswitch": {
            "description": "Target switch(es) to run the cli on.",
            "type": "string"
          },
          "pn_cliusername": {
            "description": "Provide login username if user is not root.",
            "type": "string"
          },
          "pn_index": {
            "description": "Specify the interface index from 1 to 255.",
            "type": "string"
          },
          "pn_interface_ip": {
            "description": "Specify the IP address.",
            "type": "string"
          },
          "pn_vrouter_name": {
            "description": "Specify the name of the vRouter.",
            "type": "string"
          },
          "state": {
            "description": "State the action to perform. Use 'present' to add vrouter loopback interface and 'absent' to remove vrouter loopback interface.",
            "type": "string"
          }
        },
        "required": [
          "pn_interface_ip",
          "pn_vrouter_name",
          "state"
        ]
      }
    },
    {
      "portage": {
        "type": "object",
        "description": "Package manager for Gentoo",
        "properties": {
          "changed_use": {
            "description": "Include installed packages where USE flags have changed, except when flags that the user has not enabled are added or removed (--changed-use)",
            "type": "string"
          },
          "deep": {
            "description": "Consider the entire dependency tree of packages (--deep)",
            "type": "string"
          },
          "depclean": {
            "description": "Remove packages not needed by explicitly merged packages (--depclean) If no package is specified, clean up the world's dependencies Otherwise, --depclean serves as a dependency aware version of --unmerge",
            "type": "string"
          },
          "getbinpkg": {
            "description": "Prefer packages specified at PORTAGE_BINHOST in make.conf",
            "type": "string"
          },
          "newuse": {
            "description": "Include installed packages where USE flags have changed (--newuse)",
            "type": "string"
          },
          "nodeps": {
            "description": "Only merge packages but not their dependencies (--nodeps)",
            "type": "string"
          },
          "noreplace": {
            "description": "Do not re-emerge installed packages (--noreplace)",
            "type": "string"
          },
          "oneshot": {
            "description": "Do not add the packages to the world file (--oneshot)",
            "type": "string"
          },
          "onlydeps": {
            "description": "Only merge packages' dependencies but not the packages (--onlydeps)",
            "type": "string"
          },
          "package": {
            "description": "Package atom or set, e.g. `sys-apps/foo' or `>foo-2.13' or `@world'",
            "type": "string"
          },
          "quiet": {
            "description": "Run emerge in quiet mode (--quiet)",
            "type": "string"
          },
          "state": {
            "description": "State of the package atom",
            "type": "string"
          },
          "sync": {
            "description": "Sync package repositories first If yes, perform \"emerge --sync\" If web, perform \"emerge-webrsync\"",
            "type": "string"
          },
          "update": {
            "description": "Update packages to the best version available (--update)",
            "type": "string"
          },
          "usepkgonly": {
            "description": "Merge only binaries (no compiling). This sets getbinpkg=yes.",
            "type": "string"
          },
          "verbose": {
            "description": "Run emerge in verbose mode (--verbose)",
            "type": "string"
          }
        }
      }
    },
    {
      "portinstall": {
        "type": "object",
        "description": "Installing packages from FreeBSD's ports system",
        "properties": {
          "name": {
            "description": "name of package to install/remove",
            "type": "string"
          },
          "state": {
            "description": "state of the package",
            "type": "string"
          },
          "use_packages": {
            "description": "use packages instead of ports whenever available",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "postgresql_db": {
        "type": "object",
        "description": "Add or remove PostgreSQL databases from a remote host.",
        "properties": {
          "encoding": {
            "description": "Encoding of the database",
            "type": "string"
          },
          "lc_collate": {
            "description": "Collation order (LC_COLLATE) to use in the database. Must match collation order of template database unless `template0' is used as template.",
            "type": "string"
          },
          "lc_ctype": {
            "description": "Character classification (LC_CTYPE) to use in the database (e.g. lower, upper, ...) Must match LC_CTYPE of template database unless `template0' is used as template.",
            "type": "string"
          },
          "login_host": {
            "description": "Host running the database",
            "type": "string"
          },
          "login_password": {
            "description": "The password used to authenticate with",
            "type": "string"
          },
          "login_unix_socket": {
            "description": "Path to a Unix domain socket for local connections",
            "type": "string"
          },
          "login_user": {
            "description": "The username used to authenticate with",
            "type": "string"
          },
          "name": {
            "description": "name of the database to add or remove",
            "type": "string"
          },
          "owner": {
            "description": "Name of the role to set as owner of the database",
            "type": "string"
          },
          "port": {
            "description": "Database port to connect to.",
            "type": "string"
          },
          "state": {
            "description": "The database state",
            "type": "string"
          },
          "template": {
            "description": "Template used to create the database",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "postgresql_ext": {
        "type": "object",
        "description": "Add or remove PostgreSQL extensions from a database.",
        "properties": {
          "db": {
            "description": "name of the database to add or remove the extension to/from",
            "type": "string"
          },
          "login_host": {
            "description": "Host running the database",
            "type": "string"
          },
          "login_password": {
            "description": "The password used to authenticate with",
            "type": "string"
          },
          "login_user": {
            "description": "The username used to authenticate with",
            "type": "string"
          },
          "name": {
            "description": "name of the extension to add or remove",
            "type": "string"
          },
          "port": {
            "description": "Database port to connect to.",
            "type": "string"
          },
          "state": {
            "description": "The database extension state",
            "type": "string"
          }
        },
        "required": [
          "db",
          "name"
        ]
      }
    },
    {
      "postgresql_lang": {
        "type": "object",
        "description": "Adds, removes or changes procedural languages with a PostgreSQL database.",
        "properties": {
          "cascade": {
            "description": "when dropping a language, also delete object that depend on this language. only used when `state=absent'.",
            "type": "string"
          },
          "db": {
            "description": "name of database where the language will be added, removed or changed",
            "type": "string"
          },
          "fail_on_drop": {
            "description": "if `yes', fail when removing a language. Otherwise just log and continue in some cases, it is not possible to remove a language (used by the db-system). When dependencies block the removal, consider using `cascade'.",
            "type": "string"
          },
          "force_trust": {
            "description": "marks the language as trusted, even if it's marked as untrusted in pg_pltemplate. use with care!",
            "type": "string"
          },
          "lang": {
            "description": "name of the procedural language to add, remove or change",
            "type": "string"
          },
          "login_host": {
            "description": "Host running PostgreSQL where you want to execute the actions.",
            "type": "string"
          },
          "login_password": {
            "description": "Password used to authenticate with PostgreSQL (must match `login_user')",
            "type": "string"
          },
          "login_user": {
            "description": "User used to authenticate with PostgreSQL",
            "type": "string"
          },
          "port": {
            "description": "Database port to connect to.",
            "type": "string"
          },
          "state": {
            "description": "The state of the language for the selected database",
            "type": "string"
          },
          "trust": {
            "description": "make this language trusted for the selected db",
            "type": "string"
          }
        },
        "required": "lang"
      }
    },
    {
      "postgresql_privs": {
        "type": "object",
        "description": "Grant or revoke privileges on PostgreSQL database objects.",
        "properties": {
          "database": {
            "description": "Name of database to connect to. Alias: `db'",
            "type": "string"
          },
          "grant_option": {
            "description": "Whether `role' may grant/revoke the specified privileges/group memberships to others. Set to `no' to revoke GRANT OPTION, leave unspecified to make no changes. `grant_option' only has an effect if `state' is `present'. Alias: `admin_option'",
            "type": "string"
          },
          "host": {
            "description": "Database host address. If unspecified, connect via Unix socket. Alias: `login_host'",
            "type": "string"
          },
          "login": {
            "description": "The username to authenticate with. Alias: `login_user'",
            "type": "string"
          },
          "objs": {
            "description": "Comma separated list of database objects to set privileges on. If `type' is `table' or `sequence', the special value `ALL_IN_SCHEMA' can be provided instead to specify all database objects of type `type' in the schema specified via `schema'. (This also works with PostgreSQL < 9.0.) If `type' is `database', this parameter can be omitted, in which case privileges are set for the database specified via `database'. If `type' is `function', colons (\":\") in object names will be replaced with commas (needed to specify function signatures, see examples) Alias: `obj'",
            "type": "string"
          },
          "password": {
            "description": "The password to authenticate with. Alias: `login_password')",
            "type": "string"
          },
          "port": {
            "description": "Database port to connect to.",
            "type": "string"
          },
          "privs": {
            "description": "Comma separated list of privileges to grant/revoke. Alias: `priv'",
            "type": "string"
          },
          "roles": {
            "description": "Comma separated list of role (user/group) names to set permissions for. The special value `PUBLIC' can be provided instead to set permissions for the implicitly defined PUBLIC group. Alias: `role'",
            "type": "string"
          },
          "schema": {
            "description": "Schema that contains the database objects specified via `objs'. May only be provided if `type' is `table', `sequence' or `function'. Defaults to `public' in these cases.",
            "type": "string"
          },
          "state": {
            "description": "If `present', the specified privileges are granted, if `absent' they are revoked.",
            "type": "string"
          },
          "type": {
            "description": "Type of database object to set privileges on.",
            "type": "string"
          },
          "unix_socket": {
            "description": "Path to a Unix domain socket for local connections. Alias: `login_uni x_socket'",
            "type": "string"
          }
        },
        "required": [
          "database",
          "roles"
        ]
      }
    },
    {
      "postgresql_user": {
        "type": "object",
        "description": "Adds or removes a users (roles) from a PostgreSQL database.",
        "properties": {
          "db": {
            "description": "name of database where permissions will be granted",
            "type": "string"
          },
          "encrypted": {
            "description": "whether the password is stored hashed in the database. boolean. Passwords can be passed already hashed or unhashed, and postgresql ensures the stored password is hashed when encrypted is set.",
            "type": "string"
          },
          "expires": {
            "description": "sets the user's password expiration.",
            "type": "string"
          },
          "fail_on_user": {
            "description": "if `yes', fail when user can't be removed. Otherwise just log and continue",
            "type": "string"
          },
          "login_host": {
            "description": "Host running PostgreSQL.",
            "type": "string"
          },
          "login_password": {
            "description": "Password used to authenticate with PostgreSQL",
            "type": "string"
          },
          "login_unix_socket": {
            "description": "Path to a Unix domain socket for local connections",
            "type": "string"
          },
          "login_user": {
            "description": "User (role) used to authenticate with PostgreSQL",
            "type": "string"
          },
          "name": {
            "description": "name of the user (role) to add or remove",
            "type": "string"
          },
          "no_password_changes": {
            "description": "if `yes', don't inspect database for password changes. Effective when `pg_authid' is not accessible (such as AWS RDS). Otherwise, make password changes as necessary.",
            "type": "string"
          },
          "password": {
            "description": "set the user's password, before 1.4 this was required. When passing an encrypted password, the encrypted parameter must also be true, and it must be generated with the format `'str[\"md5\"] + md5[ password + username ]'', resulting in a total of 35 characters.  An easy way to do this is: `echo \"md5`echo -n \"ver ysecretpasswordJO E\" | md5`\"'. Note that if encrypted is set, the stored password will be hashed whether or not it is pre-encrypted.",
            "type": "string"
          },
          "port": {
            "description": "Database port to connect to.",
            "type": "string"
          },
          "priv": {
            "description": "PostgreSQL privileges string in the format: `table:priv1,priv 2'",
            "type": "string"
          },
          "role_attr_flags": {
            "description": "PostgreSQL role attributes string in the format: CREATEDB,CREATERO LE,SUPERUSER",
            "type": "string"
          },
          "state": {
            "description": "The user (role) state",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "profitbricks": {
        "type": "object",
        "description": "Create, destroy, start, stop, and reboot a ProfitBricks virtual machine.",
        "properties": {
          "assign_public_ip": {
            "description": "This will assign the machine to the public LAN. If no LAN exists with public Internet access it is created.",
            "type": "string"
          },
          "auto_increment": {
            "description": "Whether or not to increment a single number in the name for created virtual machines.",
            "type": "string"
          },
          "bus": {
            "description": "The bus type for the volume.",
            "type": "string"
          },
          "cores": {
            "description": "The number of CPU cores to allocate to the virtual machine.",
            "type": "string"
          },
          "count": {
            "description": "The number of virtual machines to create.",
            "type": "string"
          },
          "cpu_family": {
            "description": "The CPU family type to allocate to the virtual machine.",
            "type": "string"
          },
          "datacenter": {
            "description": "The datacenter to provision this virtual machine.",
            "type": "string"
          },
          "image": {
            "description": "The system image ID for creating the virtual machine, e.g. a3eae284-a2fe-11e 4-b187-5f1f641608 c8.",
            "type": "string"
          },
          "image_password": {
            "description": "Password set for the administrative user.",
            "type": "string"
          },
          "instance_ids": {
            "description": "list of instance ids, currently only used when state='absent' to remove instances.",
            "type": "string"
          },
          "lan": {
            "description": "The ID of the LAN you wish to add the servers to.",
            "type": "string"
          },
          "location": {
            "description": "The datacenter location. Use only if you want to create the Datacenter or else this value is ignored.",
            "type": "string"
          },
          "name": {
            "description": "The name of the virtual machine.",
            "type": "string"
          },
          "ram": {
            "description": "The amount of memory to allocate to the virtual machine.",
            "type": "string"
          },
          "remove_boot_volume": {
            "description": "remove the bootVolume of the virtual machine you're destroying.",
            "type": "string"
          },
          "ssh_keys": {
            "description": "Public SSH keys allowing access to the virtual machine.",
            "type": "string"
          },
          "state": {
            "description": "create or terminate instances",
            "type": "string"
          },
          "subscription_password": {
            "description": "THe ProfitBricks password. Overrides the PB_PASSWORD environement variable.",
            "type": "string"
          },
          "subscription_user": {
            "description": "The ProfitBricks username. Overrides the PB_SUBSCRIPTION_I D environement variable.",
            "type": "string"
          },
          "volume_size": {
            "description": "The size in GB of the boot volume.",
            "type": "string"
          },
          "wait": {
            "description": "wait for the instance to be in state 'running' before returning",
            "type": "string"
          },
          "wait_timeout": {
            "description": "how long before wait gives up, in seconds",
            "type": "string"
          }
        },
        "required": [
          "image",
          "name"
        ]
      }
    },
    {
      "profitbricks_datacenter": {
        "type": "object",
        "description": "Create or destroy a ProfitBricks Virtual Datacenter.",
        "properties": {
          "description": {
            "description": "The description of the virtual datacenter.",
            "type": "string"
          },
          "location": {
            "description": "The datacenter location.",
            "type": "string"
          },
          "name": {
            "description": "The name of the virtual datacenter.",
            "type": "string"
          },
          "state": {
            "description": "create or terminate datacenters",
            "type": "string"
          },
          "subscription_password": {
            "description": "THe ProfitBricks password. Overrides the PB_PASSWORD environement variable.",
            "type": "string"
          },
          "subscription_user": {
            "description": "The ProfitBricks username. Overrides the PB_SUBSCRIPTION_I D environement variable.",
            "type": "string"
          },
          "wait": {
            "description": "wait for the datacenter to be created before returning",
            "type": "string"
          },
          "wait_timeout": {
            "description": "how long before wait gives up, in seconds",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "profitbricks_nic": {
        "type": "object",
        "description": "Create or Remove a NIC.",
        "properties": {
          "datacenter": {
            "description": "The datacenter in which to operate.",
            "type": "string"
          },
          "lan": {
            "description": "The LAN to place the NIC on. You can pass a LAN that doesn't exist and it will be created. Required on create.",
            "type": "string"
          },
          "name": {
            "description": "The name or ID of the NIC. This is only required on deletes, but not on create.",
            "type": "string"
          },
          "server": {
            "description": "The server name or ID.",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the resource",
            "type": "string"
          },
          "subscription_password": {
            "description": "THe ProfitBricks password. Overrides the PB_PASSWORD environement variable.",
            "type": "string"
          },
          "subscription_user": {
            "description": "The ProfitBricks username. Overrides the PB_SUBSCRIPTION_I D environement variable.",
            "type": "string"
          },
          "wait": {
            "description": "wait for the operation to complete before returning",
            "type": "string"
          },
          "wait_timeout": {
            "description": "how long before wait gives up, in seconds",
            "type": "string"
          }
        },
        "required": [
          "datacenter",
          "lan",
          "name",
          "server"
        ]
      }
    },
    {
      "profitbricks_volume": {
        "type": "object",
        "description": "Create or destroy a volume.",
        "properties": {
          "auto_increment": {
            "description": "Whether or not to increment a single number in the name for created virtual machines.",
            "type": "string"
          },
          "bus": {
            "description": "The bus type.",
            "type": "string"
          },
          "count": {
            "description": "The number of volumes you wish to create.",
            "type": "string"
          },
          "datacenter": {
            "description": "The datacenter in which to create the volumes.",
            "type": "string"
          },
          "disk_type": {
            "description": "The disk type of the volume.",
            "type": "string"
          },
          "image": {
            "description": "The system image ID for the volume, e.g. a3eae284-a2fe-11e 4-b187-5f1f641608 c8. This can also be a snapshot image ID.",
            "type": "string"
          },
          "image_password": {
            "description": "Password set for the administrative user.",
            "type": "string"
          },
          "instance_ids": {
            "description": "list of instance ids, currently only used when state='absent' to remove instances.",
            "type": "string"
          },
          "licence_type": {
            "description": "The licence type for the volume. This is used when the image is non-standard.",
            "type": "string"
          },
          "name": {
            "description": "The name of the volumes. You can enumerate the names using auto_increment.",
            "type": "string"
          },
          "size": {
            "description": "The size of the volume.",
            "type": "string"
          },
          "ssh_keys": {
            "description": "Public SSH keys allowing access to the virtual machine.",
            "type": "string"
          },
          "state": {
            "description": "create or terminate datacenters",
            "type": "string"
          },
          "subscription_password": {
            "description": "THe ProfitBricks password. Overrides the PB_PASSWORD environement variable.",
            "type": "string"
          },
          "subscription_user": {
            "description": "The ProfitBricks username. Overrides the PB_SUBSCRIPTION_I D environement variable.",
            "type": "string"
          },
          "wait": {
            "description": "wait for the datacenter to be created before returning",
            "type": "string"
          },
          "wait_timeout": {
            "description": "how long before wait gives up, in seconds",
            "type": "string"
          }
        },
        "required": [
          "datacenter",
          "image",
          "name"
        ]
      }
    },
    {
      "profitbricks_volume_attachments": {
        "type": "object",
        "description": "Attach or detach a volume.",
        "properties": {
          "datacenter": {
            "description": "The datacenter in which to operate.",
            "type": "string"
          },
          "server": {
            "description": "The name of the server you wish to detach or attach the volume.",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the resource",
            "type": "string"
          },
          "subscription_password": {
            "description": "THe ProfitBricks password. Overrides the PB_PASSWORD environement variable.",
            "type": "string"
          },
          "subscription_user": {
            "description": "The ProfitBricks username. Overrides the PB_SUBSCRIPTION_I D environement variable.",
            "type": "string"
          },
          "volume": {
            "description": "The volume name or ID.",
            "type": "string"
          },
          "wait": {
            "description": "wait for the operation to complete before returning",
            "type": "string"
          },
          "wait_timeout": {
            "description": "how long before wait gives up, in seconds",
            "type": "string"
          }
        },
        "required": [
          "datacenter",
          "server",
          "volume"
        ]
      }
    },
    {
      "proxmox": {
        "type": "object",
        "description": "management of instances in Proxmox VE cluster",
        "properties": {
          "api_host": {
            "description": "the host of the Proxmox VE cluster",
            "type": "string"
          },
          "api_password": {
            "description": "the password to authenticate with you can use PROXMOX_PASSWORD environment variable",
            "type": "string"
          },
          "api_user": {
            "description": "the user to authenticate with",
            "type": "string"
          },
          "cpus": {
            "description": "numbers of allocated cpus for instance",
            "type": "string"
          },
          "cpuunits": {
            "description": "CPU weight for a VM",
            "type": "string"
          },
          "disk": {
            "description": "hard disk size in GB for instance",
            "type": "string"
          },
          "force": {
            "description": "forcing operations can be used only with states `present', `stopped', `restarted' with `state=present' force option allow to overwrite existing container with states `stopped' , `restarted' allow to force stop instance",
            "type": "string"
          },
          "hostname": {
            "description": "the instance hostname required only for `state=present'",
            "type": "string"
          },
          "ip_address": {
            "description": "specifies the address the container will be assigned",
            "type": "string"
          },
          "memory": {
            "description": "memory size in MB for instance",
            "type": "string"
          },
          "mounts": {
            "description": "specifies additional mounts (separate disks) for the container",
            "type": "string"
          },
          "nameserver": {
            "description": "sets DNS server IP address for a container",
            "type": "string"
          },
          "netif": {
            "description": "specifies network interfaces for the container",
            "type": "string"
          },
          "node": {
            "description": "Proxmox VE node, when new VM will be created required only for `state=present' for another states will be autodiscovered",
            "type": "string"
          },
          "onboot": {
            "description": "specifies whether a VM will be started during system bootup",
            "type": "string"
          },
          "ostemplate": {
            "description": "the template for VM creating required only for `state=present'",
            "type": "string"
          },
          "password": {
            "description": "the instance root password required only for `state=present'",
            "type": "string"
          },
          "searchdomain": {
            "description": "sets DNS search domain for a container",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the instance",
            "type": "string"
          },
          "storage": {
            "description": "target storage",
            "type": "string"
          },
          "swap": {
            "description": "swap memory size in MB for instance",
            "type": "string"
          },
          "timeout": {
            "description": "timeout for operations",
            "type": "string"
          },
          "validate_certs": {
            "description": "enable / disable https certificate verification",
            "type": "string"
          },
          "vmid": {
            "description": "the instance id",
            "type": "string"
          }
        },
        "required": [
          "api_host",
          "api_user",
          "vmid"
        ]
      }
    },
    {
      "proxmox_template": {
        "type": "object",
        "description": "management of OS templates in Proxmox VE cluster",
        "properties": {
          "api_host": {
            "description": "the host of the Proxmox VE cluster",
            "type": "string"
          },
          "api_password": {
            "description": "the password to authenticate with you can use PROXMOX_PASSWORD environment variable",
            "type": "string"
          },
          "api_user": {
            "description": "the user to authenticate with",
            "type": "string"
          },
          "content_type": {
            "description": "content type required only for `state=present'",
            "type": "string"
          },
          "force": {
            "description": "can be used only with `state=present', exists template will be overwritten",
            "type": "string"
          },
          "node": {
            "description": "Proxmox VE node, when you will operate with template",
            "type": "string"
          },
          "src": {
            "description": "path to uploaded file required only for `state=present'",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the template",
            "type": "string"
          },
          "storage": {
            "description": "target storage",
            "type": "string"
          },
          "template": {
            "description": "the template name required only for states `absent', `info'",
            "type": "string"
          },
          "timeout": {
            "description": "timeout for operations",
            "type": "string"
          },
          "validate_certs": {
            "description": "enable / disable https certificate verification",
            "type": "string"
          }
        },
        "required": [
          "api_host",
          "api_user",
          "node"
        ]
      }
    },
    {
      "puppet": {
        "type": "object",
        "description": "Runs puppet",
        "properties": {
          "certname": {
            "description": "The name to use when handling certificates.",
            "type": "string"
          },
          "environment": {
            "description": "Puppet environment to be used.",
            "type": "string"
          },
          "execute": {
            "description": "Execute a specific piece of Puppet code. It has no effect with a puppetmaster.",
            "type": "string"
          },
          "facter_basename": {
            "description": "Basename of the facter output file",
            "type": "string"
          },
          "facts": {
            "description": "A dict of values to pass in as persistent external facter facts",
            "type": "string"
          },
          "logdest": {
            "description": "Where the puppet logs should go, if puppet apply is being used",
            "type": "string"
          },
          "manifest": {
            "description": "Path to the manifest file to run puppet apply on.",
            "type": "string"
          },
          "puppetmaster": {
            "description": "The hostname of the puppetmaster to contact.",
            "type": "string"
          },
          "tags": {
            "description": "A comma-separated list of puppet tags to be used.",
            "type": "string"
          },
          "timeout": {
            "description": "How long to wait for `puppet' to finish.",
            "type": "string"
          }
        }
      }
    },
    {
      "pushbullet": {
        "type": "object",
        "description": "Sends notifications to Pushbullet",
        "properties": {
          "api_key": {
            "description": "Push bullet API token",
            "type": "string"
          },
          "body": {
            "description": "Body of the notification, e.g. Details of the fault you're alerting.",
            "type": "string"
          },
          "channel": {
            "description": "The channel TAG you wish to broadcast a push notification, as seen on the \"My Channels\" > \"Edit your channel\" at Pushbullet page.",
            "type": "string"
          },
          "device": {
            "description": "The device NAME you wish to send a push notification, as seen on the Pushbullet main page.",
            "type": "string"
          },
          "push_type": {
            "description": "Thing you wish to push.",
            "type": "string"
          },
          "title": {
            "description": "Title of the notification.",
            "type": "string"
          }
        },
        "required": [
          "api_key",
          "title"
        ]
      }
    },
    {
      "pushover": {
        "type": "object",
        "description": "Send notifications via https://pushover.net",
        "properties": {
          "app_token": {
            "description": "Pushover issued token identifying your pushover app.",
            "type": "string"
          },
          "msg": {
            "description": "What message you wish to send.",
            "type": "string"
          },
          "pri": {
            "description": "Message priority (see https://pushover.net for details.)",
            "type": "string"
          },
          "user_key": {
            "description": "Pushover issued authentication key for your user.",
            "type": "string"
          }
        },
        "required": [
          "app_token",
          "msg",
          "user_key"
        ]
      }
    },
    {
      "rabbitmq_binding": {
        "type": "object",
        "description": "This module manages rabbitMQ bindings",
        "properties": {
          "arguments": {
            "description": "extra arguments for exchange. If defined this argument is a key/value dictionary",
            "type": "string"
          },
          "destination": {
            "description": "destination exchange or queue for the binding",
            "type": "string"
          },
          "destination_type": {
            "description": "Either queue or exchange",
            "type": "string"
          },
          "login_host": {
            "description": "rabbitMQ host for connection",
            "type": "string"
          },
          "login_password": {
            "description": "rabbitMQ password for connection",
            "type": "string"
          },
          "login_port": {
            "description": "rabbitMQ management api port",
            "type": "string"
          },
          "login_user": {
            "description": "rabbitMQ user for connection",
            "type": "string"
          },
          "name": {
            "description": "source exchange to create binding on",
            "type": "string"
          },
          "routing_key": {
            "description": "routing key for the binding default is",
            "type": "string"
          },
          "state": {
            "description": "Whether the exchange should be present or absent Only present implemented atm",
            "type": "string"
          },
          "vhost": {
            "description": "rabbitMQ virtual host default vhost is /",
            "type": "string"
          }
        },
        "required": [
          "destination",
          "destination_type",
          "name"
        ]
      }
    },
    {
      "rabbitmq_exchange": {
        "type": "object",
        "description": "This module manages rabbitMQ exchanges",
        "properties": {
          "arguments": {
            "description": "extra arguments for exchange. If defined this argument is a key/value dictionary",
            "type": "string"
          },
          "auto_delete": {
            "description": "if the exchange should delete itself after all queues/exchanges unbound from it",
            "type": "string"
          },
          "durable": {
            "description": "whether exchange is durable or not",
            "type": "string"
          },
          "exchange_type": {
            "description": "type for the exchange",
            "type": "string"
          },
          "internal": {
            "description": "exchange is available only for other exchanges",
            "type": "string"
          },
          "login_host": {
            "description": "rabbitMQ host for connection",
            "type": "string"
          },
          "login_password": {
            "description": "rabbitMQ password for connection",
            "type": "string"
          },
          "login_port": {
            "description": "rabbitMQ management api port",
            "type": "string"
          },
          "login_user": {
            "description": "rabbitMQ user for connection",
            "type": "string"
          },
          "name": {
            "description": "Name of the exchange to create",
            "type": "string"
          },
          "state": {
            "description": "Whether the exchange should be present or absent Only present implemented atm",
            "type": "string"
          },
          "vhost": {
            "description": "rabbitMQ virtual host",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "rabbitmq_parameter": {
        "type": "object",
        "description": "Adds or removes parameters to RabbitMQ",
        "properties": {
          "component": {
            "description": "Name of the component of which the parameter is being set",
            "type": "string"
          },
          "name": {
            "description": "Name of the parameter being set",
            "type": "string"
          },
          "node": {
            "description": "erlang node name of the rabbit we wish to configure",
            "type": "string"
          },
          "state": {
            "description": "Specify if user is to be added or removed",
            "type": "string"
          },
          "value": {
            "description": "Value of the parameter, as a JSON term",
            "type": "string"
          },
          "vhost": {
            "description": "vhost to apply access privileges.",
            "type": "string"
          }
        },
        "required": [
          "component",
          "name"
        ]
      }
    },
    {
      "rabbitmq_plugin": {
        "type": "object",
        "description": "Adds or removes plugins to RabbitMQ",
        "properties": {
          "names": {
            "description": "Comma-separated list of plugin names",
            "type": "string"
          },
          "new_only": {
            "description": "Only enable missing plugins Does not disable plugins that are not in the names list",
            "type": "string"
          },
          "prefix": {
            "description": "Specify a custom install prefix to a Rabbit",
            "type": "string"
          },
          "state": {
            "description": "Specify if plugins are to be enabled or disabled",
            "type": "string"
          }
        },
        "required": "names"
      }
    },
    {
      "rabbitmq_policy": {
        "type": "object",
        "description": "Manage the state of policies in RabbitMQ.",
        "properties": {
          "apply_to": {
            "description": "What the policy applies to. Requires RabbitMQ 3.2.0 or later.",
            "type": "string"
          },
          "name": {
            "description": "The name of the policy to manage.",
            "type": "string"
          },
          "node": {
            "description": "Erlang node name of the rabbit we wish to configure.",
            "type": "string"
          },
          "pattern": {
            "description": "A regex of queues to apply the policy to.",
            "type": "string"
          },
          "priority": {
            "description": "The priority of the policy.",
            "type": "string"
          },
          "state": {
            "description": "The state of the policy.",
            "type": "string"
          },
          "tags": {
            "description": "A dict or string describing the policy.",
            "type": "string"
          },
          "vhost": {
            "description": "The name of the vhost to apply to.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "pattern",
          "tags"
        ]
      }
    },
    {
      "rabbitmq_queue": {
        "type": "object",
        "description": "This module manages rabbitMQ queues",
        "properties": {
          "arguments": {
            "description": "extra arguments for queue. If defined this argument is a key/value dictionary",
            "type": "string"
          },
          "auto_delete": {
            "description": "if the queue should delete itself after all queues/queues unbound from it",
            "type": "string"
          },
          "auto_expires": {
            "description": "How long a queue can be unused before it is automatically deleted (milliseconds)",
            "type": "string"
          },
          "dead_letter_exchange": {
            "description": "Optional name of an exchange to which messages will be republished if they are rejected or expire",
            "type": "string"
          },
          "dead_letter_routing_key": {
            "description": "Optional replacement routing key to use when a message is dead- lettered. Original routing key will be used if unset",
            "type": "string"
          },
          "durable": {
            "description": "whether queue is durable or not",
            "type": "string"
          },
          "login_host": {
            "description": "rabbitMQ host for connection",
            "type": "string"
          },
          "login_password": {
            "description": "rabbitMQ password for connection",
            "type": "string"
          },
          "login_port": {
            "description": "rabbitMQ management api port",
            "type": "string"
          },
          "login_user": {
            "description": "rabbitMQ user for connection",
            "type": "string"
          },
          "max_length": {
            "description": "How many messages can the queue contain before it starts rejecting",
            "type": "string"
          },
          "message_ttl": {
            "description": "How long a message can live in queue before it is discarded (milliseconds)",
            "type": "string"
          },
          "name": {
            "description": "Name of the queue to create",
            "type": "string"
          },
          "state": {
            "description": "Whether the queue should be present or absent Only present implemented atm",
            "type": "string"
          },
          "vhost": {
            "description": "rabbitMQ virtual host",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "rabbitmq_user": {
        "type": "object",
        "description": "Adds or removes users to RabbitMQ",
        "properties": {
          "configure_priv": {
            "description": "Regular expression to restrict configure actions on a resource for the specified vhost. By default all actions are restricted. This option will be ignored when permissions option is used.",
            "type": "string"
          },
          "force": {
            "description": "Deletes and recreates the user.",
            "type": "string"
          },
          "node": {
            "description": "erlang node name of the rabbit we wish to configure",
            "type": "string"
          },
          "password": {
            "description": "Password of user to add. To change the password of an existing user, you must also specify `force=yes'.",
            "type": "string"
          },
          "permissions": {
            "description": "a list of dicts, each dict contains vhost, configure_priv, write_priv, and read_priv, and represents a permission rule for that vhost. This option should be preferable when you care about all permissions of the user. You should use vhost, configure_priv, write_priv, and read_priv options instead if you care about permissions for just some vhosts.",
            "type": "string"
          },
          "read_priv": {
            "description": "Regular expression to restrict configure actions on a resource for the specified vhost. By default all actions are restricted. This option will be ignored when permissions option is used.",
            "type": "string"
          },
          "state": {
            "description": "Specify if user is to be added or removed",
            "type": "string"
          },
          "tags": {
            "description": "User tags specified as comma delimited",
            "type": "string"
          },
          "user": {
            "description": "Name of user to add",
            "type": "string"
          },
          "vhost": {
            "description": "vhost to apply access privileges. This option will be ignored when permissions option is used.",
            "type": "string"
          },
          "write_priv": {
            "description": "Regular expression to restrict configure actions on a resource for the specified vhost. By default all actions are restricted. This option will be ignored when permissions option is used.",
            "type": "string"
          }
        },
        "required": "user"
      }
    },
    {
      "rabbitmq_vhost": {
        "type": "object",
        "description": "Manage the state of a virtual host in RabbitMQ",
        "properties": {
          "name": {
            "description": "The name of the vhost to manage",
            "type": "string"
          },
          "node": {
            "description": "erlang node name of the rabbit we wish to configure",
            "type": "string"
          },
          "state": {
            "description": "The state of vhost",
            "type": "string"
          },
          "tracing": {
            "description": "Enable/disable tracing for a vhost",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "raw": {
        "type": "object",
        "description": "Executes a low-down and dirty SSH command",
        "properties": {
          "executable": {
            "description": "change the shell used to execute the command. Should be an absolute path to the executable. when using privilege escalation (`become'), a default shell will be assigned if one is not provided as privilege escalation requires a shell.",
            "type": "string"
          },
          "free_form": {
            "description": "the raw module takes a free form command to run",
            "type": "string"
          }
        },
        "required": "free_form"
      }
    },
    {
      "rax": {
        "type": "object",
        "description": "create / delete an instance in Rackspace Public Cloud",
        "properties": {
          "api_key": {
            "description": "Rackspace API key (overrides `credentials')",
            "type": "string"
          },
          "auth_endpoint": {
            "description": "The URI of the authentication service",
            "type": "string"
          },
          "auto_increment": {
            "description": "Whether or not to increment a single number with the name of the created servers. Only applicable when used with the `group' attribute or meta key.",
            "type": "string"
          },
          "boot_from_volume": {
            "description": "Whether or not to boot the instance from a Cloud Block Storage volume. If `yes' and `image' is specified a new volume will be created at boot time. `boot_volum e_size' is required with `image' to create a new volume at boot time.",
            "type": "string"
          },
          "boot_volume": {
            "description": "Cloud Block Storage ID or Name to use as the boot volume of the instance",
            "type": "string"
          },
          "boot_volume_size": {
            "description": "Size of the volume to create in Gigabytes. This is only required with `image' and  `boot_from_volume '.",
            "type": "string"
          },
          "boot_volume_terminate": {
            "description": "Whether the `boot_volume' or newly created volume from `image' will be terminated when the server is terminated",
            "type": "string"
          },
          "config_drive": {
            "description": "Attach read-only configuration drive to server as label config-2",
            "type": "string"
          },
          "count": {
            "description": "number of instances to launch",
            "type": "string"
          },
          "count_offset": {
            "description": "number count to start at",
            "type": "string"
          },
          "credentials": {
            "description": "File to find the Rackspace credentials in (ignored if `api_key' and `username' are provided)",
            "type": "string"
          },
          "disk_config": {
            "description": "Disk partitioning strategy",
            "type": "string"
          },
          "env": {
            "description": "Environment as configured in ~/.pyrax.cfg, see h ttps://github.com /rackspace/pyrax/ blob/master/docs/ getting_started.m d#pyrax- configuration",
            "type": "string"
          },
          "exact_count": {
            "description": "Explicitly ensure an exact count of instances, used with state=a ctive/present. If specified as `yes' and `count' is less than the servers matched, servers will be deleted to match the count. If the number of matched servers is fewer than specified in `count' additional servers will be added.",
            "type": "string"
          },
          "extra_client_args": {
            "description": "A hash of key/value pairs to be used when creating the cloudservers client. This is considered an advanced option, use it wisely and with caution.",
            "type": "string"
          },
          "extra_create_args": {
            "description": "A hash of key/value pairs to be used when creating a new server. This is considered an advanced option, use it wisely and with caution.",
            "type": "string"
          },
          "files": {
            "description": "Files to insert into the instance. remotefilename:lo calcontent",
            "type": "string"
          },
          "flavor": {
            "description": "flavor to use for the instance",
            "type": "string"
          },
          "group": {
            "description": "host group to assign to server, is also used for idempotent operations to ensure a specific number of instances",
            "type": "string"
          },
          "identity_type": {
            "description": "Authentication machanism to use, such as rackspace or keystone",
            "type": "string"
          },
          "image": {
            "description": "image to use for the instance. Can be an `id', `human_id' or `name'. With `boo t_from_volume', a Cloud Block Storage volume will be created with this image",
            "type": "string"
          },
          "instance_ids": {
            "description": "list of instance ids, currently only used when state='absent' to remove instances",
            "type": "string"
          },
          "key_name": {
            "description": "key pair to use on the instance",
            "type": "string"
          },
          "meta": {
            "description": "A hash of metadata to associate with the instance",
            "type": "string"
          },
          "name": {
            "description": "Name to give the instance",
            "type": "string"
          },
          "networks": {
            "description": "The network to attach to the instances. If specified, you must include ALL networks including the public and private interfaces. Can be `id' or `label'.",
            "type": "string"
          },
          "region": {
            "description": "Region to create an instance in",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the resource",
            "type": "string"
          },
          "tenant_id": {
            "description": "The tenant ID used for authentication",
            "type": "string"
          },
          "tenant_name": {
            "description": "The tenant name used for authentication",
            "type": "string"
          },
          "user_data": {
            "description": "Data to be uploaded to the servers config drive. This option implies `config_drive'. Can be a file path or a string",
            "type": "string"
          },
          "username": {
            "description": "Rackspace username (overrides `credentials')",
            "type": "string"
          },
          "verify_ssl": {
            "description": "Whether or not to require SSL validation of API endpoints",
            "type": "string"
          },
          "wait": {
            "description": "wait for the instance to be in state 'running' before returning",
            "type": "string"
          },
          "wait_timeout": {
            "description": "how long before wait gives up, in seconds",
            "type": "string"
          }
        }
      }
    },
    {
      "rax_cbs": {
        "type": "object",
        "description": "Manipulate Rackspace Cloud Block Storage Volumes",
        "properties": {
          "api_key": {
            "description": "Rackspace API key (overrides `credentials')",
            "type": "string"
          },
          "auth_endpoint": {
            "description": "The URI of the authentication service",
            "type": "string"
          },
          "credentials": {
            "description": "File to find the Rackspace credentials in (ignored if `api_key' and `username' are provided)",
            "type": "string"
          },
          "description": {
            "description": "Description to give the volume being created",
            "type": "string"
          },
          "env": {
            "description": "Environment as configured in ~/.pyrax.cfg, see h ttps://github.com /rackspace/pyrax/ blob/master/docs/ getting_started.m d#pyrax- configuration",
            "type": "string"
          },
          "identity_type": {
            "description": "Authentication machanism to use, such as rackspace or keystone",
            "type": "string"
          },
          "image": {
            "description": "image to use for bootable volumes. Can be an `id', `human_id' or `name'. This option requires `pyrax>=1.9.3'",
            "type": "string"
          },
          "meta": {
            "description": "A hash of metadata to associate with the volume",
            "type": "string"
          },
          "name": {
            "description": "Name to give the volume being created",
            "type": "string"
          },
          "region": {
            "description": "Region to create an instance in",
            "type": "string"
          },
          "size": {
            "description": "Size of the volume to create in Gigabytes",
            "type": "string"
          },
          "snapshot_id": {
            "description": "The id of the snapshot to create the volume from",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the resource",
            "type": "string"
          },
          "tenant_id": {
            "description": "The tenant ID used for authentication",
            "type": "string"
          },
          "tenant_name": {
            "description": "The tenant name used for authentication",
            "type": "string"
          },
          "username": {
            "description": "Rackspace username (overrides `credentials')",
            "type": "string"
          },
          "verify_ssl": {
            "description": "Whether or not to require SSL validation of API endpoints",
            "type": "string"
          },
          "volume_type": {
            "description": "Type of the volume being created",
            "type": "string"
          },
          "wait": {
            "description": "wait for the volume to be in state 'available' before returning",
            "type": "string"
          },
          "wait_timeout": {
            "description": "how long before wait gives up, in seconds",
            "type": "string"
          }
        },
        "required": [
          "name",
          "size",
          "state",
          "volume_type"
        ]
      }
    },
    {
      "rax_cbs_attachments": {
        "type": "object",
        "description": "Manipulate Rackspace Cloud Block Storage Volume Attachments",
        "properties": {
          "api_key": {
            "description": "Rackspace API key (overrides `credentials')",
            "type": "string"
          },
          "auth_endpoint": {
            "description": "The URI of the authentication service",
            "type": "string"
          },
          "credentials": {
            "description": "File to find the Rackspace credentials in (ignored if `api_key' and `username' are provided)",
            "type": "string"
          },
          "device": {
            "description": "The device path to attach the volume to, e.g. /dev/xvde",
            "type": "string"
          },
          "env": {
            "description": "Environment as configured in ~/.pyrax.cfg, see h ttps://github.com /rackspace/pyrax/ blob/master/docs/ getting_started.m d#pyrax- configuration",
            "type": "string"
          },
          "identity_type": {
            "description": "Authentication machanism to use, such as rackspace or keystone",
            "type": "string"
          },
          "region": {
            "description": "Region to create an instance in",
            "type": "string"
          },
          "server": {
            "description": "Name or id of the server to attach/detach",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the resource",
            "type": "string"
          },
          "tenant_id": {
            "description": "The tenant ID used for authentication",
            "type": "string"
          },
          "tenant_name": {
            "description": "The tenant name used for authentication",
            "type": "string"
          },
          "username": {
            "description": "Rackspace username (overrides `credentials')",
            "type": "string"
          },
          "verify_ssl": {
            "description": "Whether or not to require SSL validation of API endpoints",
            "type": "string"
          },
          "volume": {
            "description": "Name or id of the volume to attach/detach",
            "type": "string"
          },
          "wait": {
            "description": "wait for the volume to be in 'in- use'/'available' state before returning",
            "type": "string"
          },
          "wait_timeout": {
            "description": "how long before wait gives up, in seconds",
            "type": "string"
          }
        },
        "required": [
          "device",
          "server",
          "state",
          "volume"
        ]
      }
    },
    {
      "rax_cdb": {
        "type": "object",
        "description": "create/delete or resize a Rackspace Cloud Databases instance",
        "properties": {
          "api_key": {
            "description": "Rackspace API key (overrides `credentials')",
            "type": "string"
          },
          "cdb_type": {
            "description": "type of instance (i.e. MySQL, MariaDB, Percona)",
            "type": "string"
          },
          "cdb_version": {
            "description": "version of database (MySQL supports 5.1 and 5.6, MariaDB supports 10, Percona supports 5.6)",
            "type": "string"
          },
          "credentials": {
            "description": "File to find the Rackspace credentials in (ignored if `api_key' and `username' are provided)",
            "type": "string"
          },
          "env": {
            "description": "Environment as configured in ~/.pyrax.cfg, see h ttps://github.com /rackspace/pyrax/ blob/master/docs/ getting_started.m d#pyrax- configuration",
            "type": "string"
          },
          "flavor": {
            "description": "flavor to use for the instance 1 to 6 (i.e. 512MB to 16GB)",
            "type": "string"
          },
          "name": {
            "description": "Name of the databases server instance",
            "type": "string"
          },
          "region": {
            "description": "Region to create an instance in",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the resource",
            "type": "string"
          },
          "username": {
            "description": "Rackspace username (overrides `credentials')",
            "type": "string"
          },
          "verify_ssl": {
            "description": "Whether or not to require SSL validation of API endpoints",
            "type": "string"
          },
          "volume": {
            "description": "Volume size of the database 1-150GB",
            "type": "string"
          },
          "wait": {
            "description": "wait for the instance to be in state 'running' before returning",
            "type": "string"
          },
          "wait_timeout": {
            "description": "how long before wait gives up, in seconds",
            "type": "string"
          }
        }
      }
    },
    {
      "rax_cdb_database": {
        "type": "object",
        "description": "create / delete a database in the Cloud Databases",
        "properties": {
          "api_key": {
            "description": "Rackspace API key (overrides `credentials')",
            "type": "string"
          },
          "cdb_id": {
            "description": "The databases server UUID",
            "type": "string"
          },
          "character_set": {
            "description": "Set of symbols and encodings",
            "type": "string"
          },
          "collate": {
            "description": "Set of rules for comparing characters in a character set",
            "type": "string"
          },
          "credentials": {
            "description": "File to find the Rackspace credentials in (ignored if `api_key' and `username' are provided)",
            "type": "string"
          },
          "env": {
            "description": "Environment as configured in ~/.pyrax.cfg, see h ttps://github.com /rackspace/pyrax/ blob/master/docs/ getting_started.m d#pyrax- configuration",
            "type": "string"
          },
          "name": {
            "description": "Name to give to the database",
            "type": "string"
          },
          "region": {
            "description": "Region to create an instance in",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the resource",
            "type": "string"
          },
          "username": {
            "description": "Rackspace username (overrides `credentials')",
            "type": "string"
          },
          "verify_ssl": {
            "description": "Whether or not to require SSL validation of API endpoints",
            "type": "string"
          }
        }
      }
    },
    {
      "rax_cdb_user": {
        "type": "object",
        "description": "create / delete a Rackspace Cloud Database",
        "properties": {
          "api_key": {
            "description": "Rackspace API key (overrides `credentials')",
            "type": "string"
          },
          "cdb_id": {
            "description": "The databases server UUID",
            "type": "string"
          },
          "credentials": {
            "description": "File to find the Rackspace credentials in (ignored if `api_key' and `username' are provided)",
            "type": "string"
          },
          "databases": {
            "description": "Name of the databases that the user can access",
            "type": "string"
          },
          "db_password": {
            "description": "Database user password",
            "type": "string"
          },
          "db_username": {
            "description": "Name of the database user",
            "type": "string"
          },
          "env": {
            "description": "Environment as configured in ~/.pyrax.cfg, see h ttps://github.com /rackspace/pyrax/ blob/master/docs/ getting_started.m d#pyrax- configuration",
            "type": "string"
          },
          "host": {
            "description": "Specifies the host from which a user is allowed to connect to the database. Possible values are a string containing an IPv4 address or \"%\" to allow connecting from any host",
            "type": "string"
          },
          "region": {
            "description": "Region to create an instance in",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the resource",
            "type": "string"
          },
          "username": {
            "description": "Rackspace username (overrides `credentials')",
            "type": "string"
          },
          "verify_ssl": {
            "description": "Whether or not to require SSL validation of API endpoints",
            "type": "string"
          }
        }
      }
    },
    {
      "rax_clb": {
        "type": "object",
        "description": "create / delete a load balancer in Rackspace Public Cloud",
        "properties": {
          "algorithm": {
            "description": "algorithm for the balancer being created",
            "type": "string"
          },
          "api_key": {
            "description": "Rackspace API key (overrides `credentials')",
            "type": "string"
          },
          "credentials": {
            "description": "File to find the Rackspace credentials in (ignored if `api_key' and `username' are provided)",
            "type": "string"
          },
          "env": {
            "description": "Environment as configured in ~/.pyrax.cfg, see h ttps://github.com /rackspace/pyrax/ blob/master/docs/ getting_started.m d#pyrax- configuration",
            "type": "string"
          },
          "meta": {
            "description": "A hash of metadata to associate with the instance",
            "type": "string"
          },
          "name": {
            "description": "Name to give the load balancer",
            "type": "string"
          },
          "port": {
            "description": "Port for the balancer being created",
            "type": "string"
          },
          "protocol": {
            "description": "Protocol for the balancer being created",
            "type": "string"
          },
          "region": {
            "description": "Region to create an instance in",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the resource",
            "type": "string"
          },
          "timeout": {
            "description": "timeout for communication between the balancer and the node",
            "type": "string"
          },
          "type": {
            "description": "type of interface for the balancer being created",
            "type": "string"
          },
          "username": {
            "description": "Rackspace username (overrides `credentials')",
            "type": "string"
          },
          "verify_ssl": {
            "description": "Whether or not to require SSL validation of API endpoints",
            "type": "string"
          },
          "vip_id": {
            "description": "Virtual IP ID to use when creating the load balancer for purposes of sharing an IP with another load balancer of another protocol",
            "type": "string"
          },
          "wait": {
            "description": "wait for the balancer to be in state 'running' before returning",
            "type": "string"
          },
          "wait_timeout": {
            "description": "how long before wait gives up, in seconds",
            "type": "string"
          }
        }
      }
    },
    {
      "rax_clb_nodes": {
        "type": "object",
        "description": "add, modify and remove nodes from a Rackspace Cloud Load Balancer",
        "properties": {
          "address": {
            "description": "IP address or domain name of the node",
            "type": "string"
          },
          "api_key": {
            "description": "Rackspace API key (overrides `credentials')",
            "type": "string"
          },
          "condition": {
            "description": "Condition for the node, which determines its role within the load balancer",
            "type": "string"
          },
          "credentials": {
            "description": "File to find the Rackspace credentials in (ignored if `api_key' and `username' are provided)",
            "type": "string"
          },
          "env": {
            "description": "Environment as configured in ~/.pyrax.cfg, see h ttps://github.com /rackspace/pyrax/ blob/master/docs/ getting_started.m d#pyrax- configuration",
            "type": "string"
          },
          "load_balancer_id": {
            "description": "Load balancer id",
            "type": "string"
          },
          "node_id": {
            "description": "Node id",
            "type": "string"
          },
          "port": {
            "description": "Port number of the load balanced service on the node",
            "type": "string"
          },
          "region": {
            "description": "Region to create an instance in",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the node",
            "type": "string"
          },
          "type": {
            "description": "Type of node",
            "type": "string"
          },
          "username": {
            "description": "Rackspace username (overrides `credentials')",
            "type": "string"
          },
          "verify_ssl": {
            "description": "Whether or not to require SSL validation of API endpoints",
            "type": "string"
          },
          "wait": {
            "description": "Wait for the load balancer to become active before returning",
            "type": "string"
          },
          "wait_timeout": {
            "description": "How long to wait before giving up and returning an error",
            "type": "string"
          },
          "weight": {
            "description": "Weight of node",
            "type": "string"
          }
        },
        "required": "load_balancer_id"
      }
    },
    {
      "rax_clb_ssl": {
        "type": "object",
        "description": "Manage SSL termination for a Rackspace Cloud Load Balancer.",
        "properties": {
          "api_key": {
            "description": "Rackspace API key (overrides `credentials')",
            "type": "string"
          },
          "certificate": {
            "description": "The public SSL certificates as a string in PEM format.",
            "type": "string"
          },
          "credentials": {
            "description": "File to find the Rackspace credentials in (ignored if `api_key' and `username' are provided)",
            "type": "string"
          },
          "enabled": {
            "description": "If set to \"false\", temporarily disable SSL termination without discarding existing credentials.",
            "type": "string"
          },
          "env": {
            "description": "Environment as configured in ~/.pyrax.cfg, see h ttps://github.com /rackspace/pyrax/ blob/master/docs/ getting_started.m d#pyrax- configuration",
            "type": "string"
          },
          "https_redirect": {
            "description": "If \"true\", the load balancer will redirect HTTP traffic to HTTPS. Requires \"secure_ traffic_only\" to be true. Incurs an implicit wait if SSL termination is also applied or removed.",
            "type": "string"
          },
          "intermediate_certificate": {
            "description": "One or more intermediate certificate authorities as a string in PEM format, concatenated into a single string.",
            "type": "string"
          },
          "loadbalancer": {
            "description": "Name or ID of the load balancer on which to manage SSL termination.",
            "type": "string"
          },
          "private_key": {
            "description": "The private SSL key as a string in PEM format.",
            "type": "string"
          },
          "region": {
            "description": "Region to create an instance in",
            "type": "string"
          },
          "secure_port": {
            "description": "The port to listen for secure traffic.",
            "type": "string"
          },
          "secure_traffic_only": {
            "description": "If \"true\", the load balancer will *only* accept secure traffic.",
            "type": "string"
          },
          "state": {
            "description": "If set to \"present\", SSL termination will be added to this load balancer. If \"absent\", SSL termination will be removed instead.",
            "type": "string"
          },
          "username": {
            "description": "Rackspace username (overrides `credentials')",
            "type": "string"
          },
          "verify_ssl": {
            "description": "Whether or not to require SSL validation of API endpoints",
            "type": "string"
          },
          "wait": {
            "description": "Wait for the balancer to be in state \"running\" before turning.",
            "type": "string"
          },
          "wait_timeout": {
            "description": "How long before \"wait\" gives up, in seconds.",
            "type": "string"
          }
        },
        "required": "loadbalancer"
      }
    },
    {
      "rax_dns": {
        "type": "object",
        "description": "Manage domains on Rackspace Cloud DNS",
        "properties": {
          "api_key": {
            "description": "Rackspace API key (overrides `credentials')",
            "type": "string"
          },
          "comment": {
            "description": "Brief description of the domain. Maximum length of 160 characters",
            "type": "string"
          },
          "credentials": {
            "description": "File to find the Rackspace credentials in (ignored if `api_key' and `username' are provided)",
            "type": "string"
          },
          "email": {
            "description": "Email address of the domain administrator",
            "type": "string"
          },
          "env": {
            "description": "Environment as configured in ~/.pyrax.cfg, see h ttps://github.com /rackspace/pyrax/ blob/master/docs/ getting_started.m d#pyrax- configuration",
            "type": "string"
          },
          "name": {
            "description": "Domain name to create",
            "type": "string"
          },
          "region": {
            "description": "Region to create an instance in",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the resource",
            "type": "string"
          },
          "ttl": {
            "description": "Time to live of domain in seconds",
            "type": "string"
          },
          "username": {
            "description": "Rackspace username (overrides `credentials')",
            "type": "string"
          },
          "verify_ssl": {
            "description": "Whether or not to require SSL validation of API endpoints",
            "type": "string"
          }
        }
      }
    },
    {
      "rax_dns_record": {
        "type": "object",
        "description": "Manage DNS records on Rackspace Cloud DNS",
        "properties": {
          "api_key": {
            "description": "Rackspace API key (overrides `credentials')",
            "type": "string"
          },
          "comment": {
            "description": "Brief description of the domain. Maximum length of 160 characters",
            "type": "string"
          },
          "credentials": {
            "description": "File to find the Rackspace credentials in (ignored if `api_key' and `username' are provided)",
            "type": "string"
          },
          "data": {
            "description": "IP address for A/AAAA record, FQDN for CNAME/MX/NS, or text data for SRV/TXT",
            "type": "string"
          },
          "domain": {
            "description": "Domain name to create the record in. This is an invalid option when type=PTR",
            "type": "string"
          },
          "env": {
            "description": "Environment as configured in ~/.pyrax.cfg, see h ttps://github.com /rackspace/pyrax/ blob/master/docs/ getting_started.m d#pyrax- configuration",
            "type": "string"
          },
          "loadbalancer": {
            "description": "Load Balancer ID to create a PTR record for. Only used with type=PTR",
            "type": "string"
          },
          "name": {
            "description": "FQDN record name to create",
            "type": "string"
          },
          "overwrite": {
            "description": "Add new records if data doesn't match, instead of updating existing record with matching name. If there are already multiple records with matching name and overwrite=true, this module will fail.",
            "type": "string"
          },
          "priority": {
            "description": "Required for MX and SRV records, but forbidden for other record types. If specified, must be an integer from 0 to 65535.",
            "type": "string"
          },
          "region": {
            "description": "Region to create an instance in",
            "type": "string"
          },
          "server": {
            "description": "Server ID to create a PTR record for. Only used with type=PTR",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the resource",
            "type": "string"
          },
          "ttl": {
            "description": "Time to live of record in seconds",
            "type": "string"
          },
          "type": {
            "description": "DNS record type",
            "type": "string"
          },
          "username": {
            "description": "Rackspace username (overrides `credentials')",
            "type": "string"
          },
          "verify_ssl": {
            "description": "Whether or not to require SSL validation of API endpoints",
            "type": "string"
          }
        },
        "required": [
          "data",
          "name",
          "type"
        ]
      }
    },
    {
      "rax_facts": {
        "type": "object",
        "description": "Gather facts for Rackspace Cloud Servers",
        "properties": {
          "address": {
            "description": "Server IP address to retrieve facts for, will match any IP assigned to the server",
            "type": "string"
          },
          "api_key": {
            "description": "Rackspace API key (overrides `credentials')",
            "type": "string"
          },
          "auth_endpoint": {
            "description": "The URI of the authentication service",
            "type": "string"
          },
          "credentials": {
            "description": "File to find the Rackspace credentials in (ignored if `api_key' and `username' are provided)",
            "type": "string"
          },
          "env": {
            "description": "Environment as configured in ~/.pyrax.cfg, see h ttps://github.com /rackspace/pyrax/ blob/master/docs/ getting_started.m d#pyrax- configuration",
            "type": "string"
          },
          "id": {
            "description": "Server ID to retrieve facts for",
            "type": "string"
          },
          "identity_type": {
            "description": "Authentication machanism to use, such as rackspace or keystone",
            "type": "string"
          },
          "name": {
            "description": "Server name to retrieve facts for",
            "type": "string"
          },
          "region": {
            "description": "Region to create an instance in",
            "type": "string"
          },
          "tenant_id": {
            "description": "The tenant ID used for authentication",
            "type": "string"
          },
          "tenant_name": {
            "description": "The tenant name used for authentication",
            "type": "string"
          },
          "username": {
            "description": "Rackspace username (overrides `credentials')",
            "type": "string"
          },
          "verify_ssl": {
            "description": "Whether or not to require SSL validation of API endpoints",
            "type": "string"
          }
        }
      }
    },
    {
      "rax_files": {
        "type": "object",
        "description": "Manipulate Rackspace Cloud Files Containers",
        "properties": {
          "api_key": {
            "description": "Rackspace API key (overrides `credentials')",
            "type": "string"
          },
          "clear_meta": {
            "description": "Optionally clear existing metadata when applying metadata to existing containers. Selecting this option is only appropriate when setting type=meta",
            "type": "string"
          },
          "container": {
            "description": "The container to use for container or metadata operations.",
            "type": "string"
          },
          "credentials": {
            "description": "File to find the Rackspace credentials in (ignored if `api_key' and `username' are provided)",
            "type": "string"
          },
          "env": {
            "description": "Environment as configured in ~/.pyrax.cfg, see h ttps://github.com /rackspace/pyrax/ blob/master/docs/ getting_started.m d#pyrax- configuration",
            "type": "string"
          },
          "meta": {
            "description": "A hash of items to set as metadata values on a container",
            "type": "string"
          },
          "private": {
            "description": "Used to set a container as private, removing it from the CDN. *Warning!* Private containers, if previously made public, can have live objects available until the TTL on cached objects expires",
            "type": "string"
          },
          "public": {
            "description": "Used to set a container as public, available via the Cloud Files CDN",
            "type": "string"
          },
          "region": {
            "description": "Region to create an instance in",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the resource",
            "type": "string"
          },
          "ttl": {
            "description": "In seconds, set a container-wide TTL for all objects cached on CDN edge nodes. Setting a TTL is only appropriate for containers that are public",
            "type": "string"
          },
          "type": {
            "description": "Type of object to do work on, i.e. metadata object or a container object",
            "type": "string"
          },
          "username": {
            "description": "Rackspace username (overrides `credentials')",
            "type": "string"
          },
          "verify_ssl": {
            "description": "Whether or not to require SSL validation of API endpoints",
            "type": "string"
          },
          "web_error": {
            "description": "Sets an object to be presented as the HTTP error page when accessed by the CDN URL",
            "type": "string"
          },
          "web_index": {
            "description": "Sets an object to be presented as the HTTP index page when accessed by the CDN URL",
            "type": "string"
          }
        },
        "required": "container"
      }
    },
    {
      "rax_files_objects": {
        "type": "object",
        "description": "Upload, download, and delete objects in Rackspace Cloud Files",
        "properties": {
          "api_key": {
            "description": "Rackspace API key (overrides `credentials')",
            "type": "string"
          },
          "clear_meta": {
            "description": "Optionally clear existing metadata when applying metadata to existing objects. Selecting this option is only appropriate when setting type=meta",
            "type": "string"
          },
          "container": {
            "description": "The container to use for file object operations.",
            "type": "string"
          },
          "credentials": {
            "description": "File to find the Rackspace credentials in (ignored if `api_key' and `username' are provided)",
            "type": "string"
          },
          "dest": {
            "description": "The destination of a \"get\" operation; i.e. a local directory,  \"/home/user/myfol der\". Used to specify the destination of an operation on a remote object; i.e. a file name, \"file1\", or a comma-separated list of remote objects, \"file1,f ile2,file17\"",
            "type": "string"
          },
          "env": {
            "description": "Environment as configured in ~/.pyrax.cfg, see h ttps://github.com /rackspace/pyrax/ blob/master/docs/ getting_started.m d#pyrax- configuration",
            "type": "string"
          },
          "expires": {
            "description": "Used to set an expiration on a file or folder uploaded to Cloud Files. Requires an integer, specifying expiration in seconds",
            "type": "string"
          },
          "meta": {
            "description": "A hash of items to set as metadata values on an uploaded file or folder",
            "type": "string"
          },
          "method": {
            "description": "The method of operation to be performed.  For example, put to upload files to Cloud Files, get to download files from Cloud Files or delete to delete remote objects in Cloud Files",
            "type": "string"
          },
          "region": {
            "description": "Region to create an instance in",
            "type": "string"
          },
          "src": {
            "description": "Source from which to upload files.  Used to specify a remote object as a source for an operation, i.e. a file name, \"file1\", or a comma-separated list of remote objects, \"file1,f ile2,file17\". src and dest are mutually exclusive on remote-only object operations",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the resource",
            "type": "string"
          },
          "structure": {
            "description": "Used to specify whether to maintain nested directory structure when downloading objects from Cloud Files. Setting to false downloads the contents of a container to a single, flat directory",
            "type": "string"
          },
          "type": {
            "description": "Type of object to do work on Metadata object or a file object",
            "type": "string"
          },
          "username": {
            "description": "Rackspace username (overrides `credentials')",
            "type": "string"
          },
          "verify_ssl": {
            "description": "Whether or not to require SSL validation of API endpoints",
            "type": "string"
          }
        },
        "required": "container"
      }
    },
    {
      "rax_identity": {
        "type": "object",
        "description": "Load Rackspace Cloud Identity",
        "properties": {
          "api_key": {
            "description": "Rackspace API key (overrides `credentials')",
            "type": "string"
          },
          "auth_endpoint": {
            "description": "The URI of the authentication service",
            "type": "string"
          },
          "credentials": {
            "description": "File to find the Rackspace credentials in (ignored if `api_key' and `username' are provided)",
            "type": "string"
          },
          "env": {
            "description": "Environment as configured in ~/.pyrax.cfg, see h ttps://github.com /rackspace/pyrax/ blob/master/docs/ getting_started.m d#pyrax- configuration",
            "type": "string"
          },
          "identity_type": {
            "description": "Authentication machanism to use, such as rackspace or keystone",
            "type": "string"
          },
          "region": {
            "description": "Region to create an instance in",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the resource",
            "type": "string"
          },
          "tenant_id": {
            "description": "The tenant ID used for authentication",
            "type": "string"
          },
          "tenant_name": {
            "description": "The tenant name used for authentication",
            "type": "string"
          },
          "username": {
            "description": "Rackspace username (overrides `credentials')",
            "type": "string"
          },
          "verify_ssl": {
            "description": "Whether or not to require SSL validation of API endpoints",
            "type": "string"
          }
        }
      }
    },
    {
      "rax_keypair": {
        "type": "object",
        "description": "Create a keypair for use with Rackspace Cloud Servers",
        "properties": {
          "api_key": {
            "description": "Rackspace API key (overrides `credentials')",
            "type": "string"
          },
          "auth_endpoint": {
            "description": "The URI of the authentication service",
            "type": "string"
          },
          "credentials": {
            "description": "File to find the Rackspace credentials in (ignored if `api_key' and `username' are provided)",
            "type": "string"
          },
          "env": {
            "description": "Environment as configured in ~/.pyrax.cfg, see h ttps://github.com /rackspace/pyrax/ blob/master/docs/ getting_started.m d#pyrax- configuration",
            "type": "string"
          },
          "identity_type": {
            "description": "Authentication machanism to use, such as rackspace or keystone",
            "type": "string"
          },
          "name": {
            "description": "Name of keypair",
            "type": "string"
          },
          "public_key": {
            "description": "Public Key string to upload. Can be a file path or string",
            "type": "string"
          },
          "region": {
            "description": "Region to create an instance in",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the resource",
            "type": "string"
          },
          "tenant_id": {
            "description": "The tenant ID used for authentication",
            "type": "string"
          },
          "tenant_name": {
            "description": "The tenant name used for authentication",
            "type": "string"
          },
          "username": {
            "description": "Rackspace username (overrides `credentials')",
            "type": "string"
          },
          "verify_ssl": {
            "description": "Whether or not to require SSL validation of API endpoints",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "rax_meta": {
        "type": "object",
        "description": "Manipulate metadata for Rackspace Cloud Servers",
        "properties": {
          "address": {
            "description": "Server IP address to modify metadata for, will match any IP assigned to the server",
            "type": "string"
          },
          "api_key": {
            "description": "Rackspace API key (overrides `credentials')",
            "type": "string"
          },
          "auth_endpoint": {
            "description": "The URI of the authentication service",
            "type": "string"
          },
          "credentials": {
            "description": "File to find the Rackspace credentials in (ignored if `api_key' and `username' are provided)",
            "type": "string"
          },
          "env": {
            "description": "Environment as configured in ~/.pyrax.cfg, see h ttps://github.com /rackspace/pyrax/ blob/master/docs/ getting_started.m d#pyrax- configuration",
            "type": "string"
          },
          "id": {
            "description": "Server ID to modify metadata for",
            "type": "string"
          },
          "identity_type": {
            "description": "Authentication machanism to use, such as rackspace or keystone",
            "type": "string"
          },
          "meta": {
            "description": "A hash of metadata to associate with the instance",
            "type": "string"
          },
          "name": {
            "description": "Server name to modify metadata for",
            "type": "string"
          },
          "region": {
            "description": "Region to create an instance in",
            "type": "string"
          },
          "tenant_id": {
            "description": "The tenant ID used for authentication",
            "type": "string"
          },
          "tenant_name": {
            "description": "The tenant name used for authentication",
            "type": "string"
          },
          "username": {
            "description": "Rackspace username (overrides `credentials')",
            "type": "string"
          },
          "verify_ssl": {
            "description": "Whether or not to require SSL validation of API endpoints",
            "type": "string"
          }
        }
      }
    },
    {
      "rax_mon_alarm": {
        "type": "object",
        "description": "Create or delete a Rackspace Cloud Monitoring alarm.",
        "properties": {
          "api_key": {
            "description": "Rackspace API key (overrides `credentials')",
            "type": "string"
          },
          "auth_endpoint": {
            "description": "The URI of the authentication service",
            "type": "string"
          },
          "check_id": {
            "description": "ID of the check that should be alerted on. May be acquired by registering the value of a rax_mon_check task.",
            "type": "string"
          },
          "credentials": {
            "description": "File to find the Rackspace credentials in (ignored if `api_key' and `username' are provided)",
            "type": "string"
          },
          "criteria": {
            "description": "Alarm DSL that describes alerting conditions and their output states. Must be between 1 and 16384 characters long. See http:// docs.rackspace.co m/cm/api/v1.0/cm- devguide/content /alerts- language.html for a reference on the alerting language.",
            "type": "string"
          },
          "disabled": {
            "description": "If yes, create this alarm, but leave it in an inactive state. Defaults to no.",
            "type": "string"
          },
          "entity_id": {
            "description": "ID of the entity this alarm is attached to. May be acquired by registering the value of a rax_mon_entity task.",
            "type": "string"
          },
          "env": {
            "description": "Environment as configured in ~/.pyrax.cfg, see h ttps://github.com /rackspace/pyrax/ blob/master/docs/ getting_started.m d#pyrax- configuration",
            "type": "string"
          },
          "identity_type": {
            "description": "Authentication machanism to use, such as rackspace or keystone",
            "type": "string"
          },
          "label": {
            "description": "Friendly name for this alarm, used to achieve idempotence. Must be a String between 1 and 255 characters long.",
            "type": "string"
          },
          "metadata": {
            "description": "Arbitrary key/value pairs to accompany the alarm. Must be a hash of String keys and values between 1 and 255 characters long.",
            "type": "string"
          },
          "notification_plan_id": {
            "description": "ID of the notification plan to trigger if this alarm fires. May be acquired by registering the value of a rax_mo n_notification_pl an task.",
            "type": "string"
          },
          "region": {
            "description": "Region to create an instance in",
            "type": "string"
          },
          "state": {
            "description": "Ensure that the alarm with this `label' exists or does not exist.",
            "type": "string"
          },
          "tenant_id": {
            "description": "The tenant ID used for authentication",
            "type": "string"
          },
          "tenant_name": {
            "description": "The tenant name used for authentication",
            "type": "string"
          },
          "username": {
            "description": "Rackspace username (overrides `credentials')",
            "type": "string"
          },
          "verify_ssl": {
            "description": "Whether or not to require SSL validation of API endpoints",
            "type": "string"
          }
        },
        "required": [
          "check_id",
          "entity_id",
          "label",
          "notification_plan_id"
        ]
      }
    },
    {
      "rax_mon_check": {
        "type": "object",
        "description": "Create or delete a Rackspace Cloud Monitoring check for an existing entity.",
        "properties": {
          "api_key": {
            "description": "Rackspace API key (overrides `credentials')",
            "type": "string"
          },
          "auth_endpoint": {
            "description": "The URI of the authentication service",
            "type": "string"
          },
          "check_type": {
            "description": "The type of check to create. `remote.' checks may be created on any rax_mon_entity. `agent.' checks may only be created on rax_mon_entities that have a non- null `agent_id'.",
            "type": "string"
          },
          "credentials": {
            "description": "File to find the Rackspace credentials in (ignored if `api_key' and `username' are provided)",
            "type": "string"
          },
          "details": {
            "description": "Additional details specific to the check type. Must be a hash of strings between 1 and 255 characters long, or an array or object containing 0 to 256 items.",
            "type": "string"
          },
          "disabled": {
            "description": "If \"yes\", ensure the check is created, but don't actually use it yet.",
            "type": "string"
          },
          "entity_id": {
            "description": "ID of the rax_mon_entity to target with this check.",
            "type": "string"
          },
          "env": {
            "description": "Environment as configured in ~/.pyrax.cfg, see h ttps://github.com /rackspace/pyrax/ blob/master/docs/ getting_started.m d#pyrax- configuration",
            "type": "string"
          },
          "identity_type": {
            "description": "Authentication machanism to use, such as rackspace or keystone",
            "type": "string"
          },
          "label": {
            "description": "Defines a label for this check, between 1 and 64 characters long.",
            "type": "string"
          },
          "metadata": {
            "description": "Hash of arbitrary key-value pairs to accompany this check if it fires. Keys and values must be strings between 1 and 255 characters long.",
            "type": "string"
          },
          "monitoring_zones_poll": {
            "description": "Comma-separated list of the names of the monitoring zones the check should run from. Available monitoring zones include mzdfw, mzhkg, mziad, mzlon, mzord and mzsyd. Required for remote.* checks; prohibited for agent.* checks.",
            "type": "string"
          },
          "period": {
            "description": "The number of seconds between each time the check is performed. Must be greater than the minimum period set on your account.",
            "type": "string"
          },
          "region": {
            "description": "Region to create an instance in",
            "type": "string"
          },
          "state": {
            "description": "Ensure that a check with this `label' exists or does not exist.",
            "type": "string"
          },
          "target_alias": {
            "description": "One of `target_alias` and `target_hostname` is required for remote.* checks, but prohibited for agent.* checks. Use the corresponding key in the entity's `ip_addresses` hash to resolve an IP address to target.",
            "type": "string"
          },
          "target_hostname": {
            "description": "One of `target_hostname` and `target_alias` is required for remote.* checks, but prohibited for agent.* checks. The hostname this check should target. Must be a valid IPv4, IPv6, or FQDN.",
            "type": "string"
          },
          "tenant_id": {
            "description": "The tenant ID used for authentication",
            "type": "string"
          },
          "tenant_name": {
            "description": "The tenant name used for authentication",
            "type": "string"
          },
          "timeout": {
            "description": "The number of seconds this check will wait when attempting to collect results. Must be less than the period.",
            "type": "string"
          },
          "username": {
            "description": "Rackspace username (overrides `credentials')",
            "type": "string"
          },
          "verify_ssl": {
            "description": "Whether or not to require SSL validation of API endpoints",
            "type": "string"
          }
        },
        "required": [
          "check_type",
          "entity_id",
          "label"
        ]
      }
    },
    {
      "rax_mon_entity": {
        "type": "object",
        "description": "Create or delete a Rackspace Cloud Monitoring entity",
        "properties": {
          "agent_id": {
            "description": "Rackspace monitoring agent on the target device to which this entity is bound. Necessary to collect `agent.' rax_mon_checks against this entity.",
            "type": "string"
          },
          "api_key": {
            "description": "Rackspace API key (overrides `credentials')",
            "type": "string"
          },
          "auth_endpoint": {
            "description": "The URI of the authentication service",
            "type": "string"
          },
          "credentials": {
            "description": "File to find the Rackspace credentials in (ignored if `api_key' and `username' are provided)",
            "type": "string"
          },
          "env": {
            "description": "Environment as configured in ~/.pyrax.cfg, see h ttps://github.com /rackspace/pyrax/ blob/master/docs/ getting_started.m d#pyrax- configuration",
            "type": "string"
          },
          "identity_type": {
            "description": "Authentication machanism to use, such as rackspace or keystone",
            "type": "string"
          },
          "label": {
            "description": "Defines a name for this entity. Must be a non- empty string between 1 and 255 characters long.",
            "type": "string"
          },
          "metadata": {
            "description": "Hash of arbitrary `name', `value' pairs that are passed to associated rax_mon_alarms. Names and values must all be between 1 and 255 characters long.",
            "type": "string"
          },
          "named_ip_addresses": {
            "description": "Hash of IP addresses that may be referenced by name by rax_mon_checks added to this entity. Must be a dictionary of with keys that are names between 1 and 64 characters long, and values that are valid IPv4 or IPv6 addresses.",
            "type": "string"
          },
          "region": {
            "description": "Region to create an instance in",
            "type": "string"
          },
          "state": {
            "description": "Ensure that an entity with this `name' exists or does not exist.",
            "type": "string"
          },
          "tenant_id": {
            "description": "The tenant ID used for authentication",
            "type": "string"
          },
          "tenant_name": {
            "description": "The tenant name used for authentication",
            "type": "string"
          },
          "username": {
            "description": "Rackspace username (overrides `credentials')",
            "type": "string"
          },
          "verify_ssl": {
            "description": "Whether or not to require SSL validation of API endpoints",
            "type": "string"
          }
        },
        "required": "label"
      }
    },
    {
      "rax_mon_notification": {
        "type": "object",
        "description": "Create or delete a Rackspace Cloud Monitoring notification.",
        "properties": {
          "api_key": {
            "description": "Rackspace API key (overrides `credentials')",
            "type": "string"
          },
          "auth_endpoint": {
            "description": "The URI of the authentication service",
            "type": "string"
          },
          "credentials": {
            "description": "File to find the Rackspace credentials in (ignored if `api_key' and `username' are provided)",
            "type": "string"
          },
          "details": {
            "description": "Dictionary of key-value pairs used to initialize the notification. Required keys and meanings vary with notification type. See http:// docs.rackspace.co m/cm/api/v1.0/cm- devguide/content/ service- notification- types-crud.html for details.",
            "type": "string"
          },
          "env": {
            "description": "Environment as configured in ~/.pyrax.cfg, see h ttps://github.com /rackspace/pyrax/ blob/master/docs/ getting_started.m d#pyrax- configuration",
            "type": "string"
          },
          "identity_type": {
            "description": "Authentication machanism to use, such as rackspace or keystone",
            "type": "string"
          },
          "label": {
            "description": "Defines a friendly name for this notification. String between 1 and 255 characters long.",
            "type": "string"
          },
          "notification_type": {
            "description": "A supported notification type.",
            "type": "string"
          },
          "region": {
            "description": "Region to create an instance in",
            "type": "string"
          },
          "state": {
            "description": "Ensure that the notification with this `label' exists or does not exist.",
            "type": "string"
          },
          "tenant_id": {
            "description": "The tenant ID used for authentication",
            "type": "string"
          },
          "tenant_name": {
            "description": "The tenant name used for authentication",
            "type": "string"
          },
          "username": {
            "description": "Rackspace username (overrides `credentials')",
            "type": "string"
          },
          "verify_ssl": {
            "description": "Whether or not to require SSL validation of API endpoints",
            "type": "string"
          }
        },
        "required": [
          "details",
          "label",
          "notification_type"
        ]
      }
    },
    {
      "rax_mon_notification_plan": {
        "type": "object",
        "description": "Create or delete a Rackspace Cloud Monitoring notification plan.",
        "properties": {
          "api_key": {
            "description": "Rackspace API key (overrides `credentials')",
            "type": "string"
          },
          "auth_endpoint": {
            "description": "The URI of the authentication service",
            "type": "string"
          },
          "credentials": {
            "description": "File to find the Rackspace credentials in (ignored if `api_key' and `username' are provided)",
            "type": "string"
          },
          "critical_state": {
            "description": "Notification list to use when the alarm state is CRITICAL. Must be an array of valid rax_mon_notificat ion ids.",
            "type": "string"
          },
          "env": {
            "description": "Environment as configured in ~/.pyrax.cfg, see h ttps://github.com /rackspace/pyrax/ blob/master/docs/ getting_started.m d#pyrax- configuration",
            "type": "string"
          },
          "identity_type": {
            "description": "Authentication machanism to use, such as rackspace or keystone",
            "type": "string"
          },
          "label": {
            "description": "Defines a friendly name for this notification plan. String between 1 and 255 characters long.",
            "type": "string"
          },
          "ok_state": {
            "description": "Notification list to use when the alarm state is OK. Must be an array of valid ra x_mon_notificatio n ids.",
            "type": "string"
          },
          "region": {
            "description": "Region to create an instance in",
            "type": "string"
          },
          "state": {
            "description": "Ensure that the notification plan with this `label' exists or does not exist.",
            "type": "string"
          },
          "tenant_id": {
            "description": "The tenant ID used for authentication",
            "type": "string"
          },
          "tenant_name": {
            "description": "The tenant name used for authentication",
            "type": "string"
          },
          "username": {
            "description": "Rackspace username (overrides `credentials')",
            "type": "string"
          },
          "verify_ssl": {
            "description": "Whether or not to require SSL validation of API endpoints",
            "type": "string"
          },
          "warning_state": {
            "description": "Notification list to use when the alarm state is WARNING. Must be an array of valid rax_mon_notificat ion ids.",
            "type": "string"
          }
        },
        "required": "label"
      }
    },
    {
      "rax_network": {
        "type": "object",
        "description": "create / delete an isolated network in Rackspace Public Cloud",
        "properties": {
          "api_key": {
            "description": "Rackspace API key (overrides `credentials')",
            "type": "string"
          },
          "auth_endpoint": {
            "description": "The URI of the authentication service",
            "type": "string"
          },
          "cidr": {
            "description": "cidr of the network being created",
            "type": "string"
          },
          "credentials": {
            "description": "File to find the Rackspace credentials in (ignored if `api_key' and `username' are provided)",
            "type": "string"
          },
          "env": {
            "description": "Environment as configured in ~/.pyrax.cfg, see h ttps://github.com /rackspace/pyrax/ blob/master/docs/ getting_started.m d#pyrax- configuration",
            "type": "string"
          },
          "identity_type": {
            "description": "Authentication machanism to use, such as rackspace or keystone",
            "type": "string"
          },
          "label": {
            "description": "Label (name) to give the network",
            "type": "string"
          },
          "region": {
            "description": "Region to create an instance in",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the resource",
            "type": "string"
          },
          "tenant_id": {
            "description": "The tenant ID used for authentication",
            "type": "string"
          },
          "tenant_name": {
            "description": "The tenant name used for authentication",
            "type": "string"
          },
          "username": {
            "description": "Rackspace username (overrides `credentials')",
            "type": "string"
          },
          "verify_ssl": {
            "description": "Whether or not to require SSL validation of API endpoints",
            "type": "string"
          }
        }
      }
    },
    {
      "rax_queue": {
        "type": "object",
        "description": "create / delete a queue in Rackspace Public Cloud",
        "properties": {
          "api_key": {
            "description": "Rackspace API key (overrides `credentials')",
            "type": "string"
          },
          "credentials": {
            "description": "File to find the Rackspace credentials in (ignored if `api_key' and `username' are provided)",
            "type": "string"
          },
          "env": {
            "description": "Environment as configured in ~/.pyrax.cfg, see h ttps://github.com /rackspace/pyrax/ blob/master/docs/ getting_started.m d#pyrax- configuration",
            "type": "string"
          },
          "name": {
            "description": "Name to give the queue",
            "type": "string"
          },
          "region": {
            "description": "Region to create an instance in",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the resource",
            "type": "string"
          },
          "username": {
            "description": "Rackspace username (overrides `credentials')",
            "type": "string"
          },
          "verify_ssl": {
            "description": "Whether or not to require SSL validation of API endpoints",
            "type": "string"
          }
        }
      }
    },
    {
      "rax_scaling_group": {
        "type": "object",
        "description": "Manipulate Rackspace Cloud Autoscale Groups",
        "properties": {
          "api_key": {
            "description": "Rackspace API key (overrides `credentials')",
            "type": "string"
          },
          "config_drive": {
            "description": "Attach read-only configuration drive to server as label config-2",
            "type": "string"
          },
          "cooldown": {
            "description": "The period of time, in seconds, that must pass before any scaling can occur after the previous scaling. Must be an integer between 0 and 86400 (24 hrs).",
            "type": "string"
          },
          "credentials": {
            "description": "File to find the Rackspace credentials in (ignored if `api_key' and `username' are provided)",
            "type": "string"
          },
          "disk_config": {
            "description": "Disk partitioning strategy",
            "type": "string"
          },
          "env": {
            "description": "Environment as configured in ~/.pyrax.cfg, see h ttps://github.com /rackspace/pyrax/ blob/master/docs/ getting_started.m d#pyrax- configuration",
            "type": "string"
          },
          "files": {
            "description": "Files to insert into the instance. Hash of `remotepath: localpath'",
            "type": "string"
          },
          "flavor": {
            "description": "flavor to use for the instance",
            "type": "string"
          },
          "image": {
            "description": "image to use for the instance. Can be an `id', `human_id' or `name'",
            "type": "string"
          },
          "key_name": {
            "description": "key pair to use on the instance",
            "type": "string"
          },
          "loadbalancers": {
            "description": "List of load balancer `id' and `port' hashes",
            "type": "string"
          },
          "max_entities": {
            "description": "The maximum number of entities that are allowed in the scaling group. Must be an integer between 0 and 1000.",
            "type": "string"
          },
          "meta": {
            "description": "A hash of metadata to associate with the instance",
            "type": "string"
          },
          "min_entities": {
            "description": "The minimum number of entities that are allowed in the scaling group. Must be an integer between 0 and 1000.",
            "type": "string"
          },
          "name": {
            "description": "Name to give the scaling group",
            "type": "string"
          },
          "networks": {
            "description": "The network to attach to the instances. If specified, you must include ALL networks including the public and private interfaces. Can be `id' or `label'.",
            "type": "string"
          },
          "region": {
            "description": "Region to create an instance in",
            "type": "string"
          },
          "server_name": {
            "description": "The base name for servers created by Autoscale",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the resource",
            "type": "string"
          },
          "user_data": {
            "description": "Data to be uploaded to the servers config drive. This option implies `config_drive'. Can be a file path or a string",
            "type": "string"
          },
          "username": {
            "description": "Rackspace username (overrides `credentials')",
            "type": "string"
          },
          "verify_ssl": {
            "description": "Whether or not to require SSL validation of API endpoints",
            "type": "string"
          },
          "wait": {
            "description": "wait for the scaling group to finish provisioning the minimum amount of servers",
            "type": "string"
          },
          "wait_timeout": {
            "description": "how long before wait gives up, in seconds",
            "type": "string"
          }
        },
        "required": [
          "flavor",
          "image",
          "max_entities",
          "min_entities",
          "name",
          "server_name"
        ]
      }
    },
    {
      "rax_scaling_policy": {
        "type": "object",
        "description": "Manipulate Rackspace Cloud Autoscale Scaling Policy",
        "properties": {
          "api_key": {
            "description": "Rackspace API key (overrides `credentials')",
            "type": "string"
          },
          "at": {
            "description": "The UTC time when this policy will be executed. The time must be formatted according to `yyyy-MM-dd'T'HH: mm:ss.SSS' such as `2013-05-19T08 :07:08Z'",
            "type": "string"
          },
          "change": {
            "description": "The change, either as a number of servers or as a percentage, to make in the scaling group. If this is a percentage, you must set `is_percent' to `true' also.",
            "type": "string"
          },
          "cooldown": {
            "description": "The period of time, in seconds, that must pass before any scaling can occur after the previous scaling. Must be an integer between 0 and 86400 (24 hrs).",
            "type": "string"
          },
          "credentials": {
            "description": "File to find the Rackspace credentials in (ignored if `api_key' and `username' are provided)",
            "type": "string"
          },
          "cron": {
            "description": "The time when the policy will be executed, as a cron entry. For example, if this is parameter is set to `1 0 * * *'",
            "type": "string"
          },
          "desired_capacity": {
            "description": "The desired server capacity of the scaling the group; that is, how many servers should be in the scaling group.",
            "type": "string"
          },
          "env": {
            "description": "Environment as configured in ~/.pyrax.cfg, see h ttps://github.com /rackspace/pyrax/ blob/master/docs/ getting_started.m d#pyrax- configuration",
            "type": "string"
          },
          "is_percent": {
            "description": "Whether the value in `change' is a percent value",
            "type": "string"
          },
          "name": {
            "description": "Name to give the policy",
            "type": "string"
          },
          "policy_type": {
            "description": "The type of policy that will be executed for the current release.",
            "type": "string"
          },
          "region": {
            "description": "Region to create an instance in",
            "type": "string"
          },
          "scaling_group": {
            "description": "Name of the scaling group that this policy will be added to",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the resource",
            "type": "string"
          },
          "username": {
            "description": "Rackspace username (overrides `credentials')",
            "type": "string"
          },
          "verify_ssl": {
            "description": "Whether or not to require SSL validation of API endpoints",
            "type": "string"
          }
        },
        "required": [
          "name",
          "policy_type",
          "scaling_group"
        ]
      }
    },
    {
      "rds": {
        "type": "object",
        "description": "create, delete, or modify an Amazon rds instance",
        "properties": {
          "apply_immediately": {
            "description": "Used only when command=modify.  If enabled, the modifications will be applied as soon as possible rather than waiting for the next preferred maintenance window.",
            "type": "string"
          },
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "backup_retention": {
            "description": "Number of days backups are retained.  Set to 0 to disable backups.  Default is 1 day.  Valid range: 0-35. Used only when command=create or command=modify.",
            "type": "string"
          },
          "backup_window": {
            "description": "Backup window in format of hh24:mi-hh24:mi.  If not specified then a random backup window is assigned. Used only when command=create or command=modify.",
            "type": "string"
          },
          "character_set_name": {
            "description": "Associate the DB instance with a specified character set. Used with command=create.",
            "type": "string"
          },
          "command": {
            "description": "Specifies the action to take. The 'reboot' option is available starting at version 2.0",
            "type": "string"
          },
          "db_engine": {
            "description": "The type of database.  Used only when command=create. mariadb was added in version 2.2",
            "type": "string"
          },
          "db_name": {
            "description": "Name of a database to create within the instance.  If not specified then no database is created. Used only when command=create.",
            "type": "string"
          },
          "engine_version": {
            "description": "Version number of the database engine to use. Used only when command=create. If not specified then the current Amazon RDS default engine version is used.",
            "type": "string"
          },
          "force_failover": {
            "description": "Used only when command=reboot.  If enabled, the reboot is done using a MultiAZ failover.",
            "type": "string"
          },
          "instance_name": {
            "description": "Database instance identifier. Required except when using command=facts or command=delete on just a snapshot",
            "type": "string"
          },
          "instance_type": {
            "description": "The instance type of the database.  Must be specified when command=create. Optional when com mand=replicate, command=modify or command=restore. If not specified then the replica inherits the same instance type as the source instance.",
            "type": "string"
          },
          "iops": {
            "description": "Specifies the number of IOPS for the instance. Used only when command=create or command=modify. Must be an integer greater than 1000.",
            "type": "string"
          },
          "license_model": {
            "description": "The license model for this DB instance. Used only when command=create or command=restore.",
            "type": "string"
          },
          "maint_window": {
            "description": "Maintenance window in format of ddd:hh24:mi- ddd:hh24:mi. (Example: Mon:22: 00-Mon:23:15) If not specified then a random maintenance window is assigned. Used only when command=create or command=modify.",
            "type": "string"
          },
          "multi_zone": {
            "description": "Specifies if this is a Multi-availability-zone deployment. Can not be used in conjunction with zone parameter. Used only when command=create or command=modify.",
            "type": "string"
          },
          "new_instance_name": {
            "description": "Name to rename an instance to. Used only when command=modify.",
            "type": "string"
          },
          "option_group": {
            "description": "The name of the option group to use.  If not specified then the default option group is used. Used only when command=create.",
            "type": "string"
          },
          "parameter_group": {
            "description": "Name of the DB parameter group to associate with this instance. If omitted then the RDS default DBParameterGroup will be used. Used only when command=create or command=modify.",
            "type": "string"
          },
          "password": {
            "description": "Password for the master database username. Used only when command=create or command=modify.",
            "type": "string"
          },
          "port": {
            "description": "Port number that the DB instance uses for connections. Used only when command=create or command=replicate . Prior to 2.0 it always defaults to null and the API would use 3306, it had to be set to other DB default values when not using MySql. Starting at 2.0 it automatically defaults to what is expected for each c(db_engine).",
            "type": "string"
          },
          "publicly_accessible": {
            "description": "explicitly set whether the resource should be publicly accessible or not. Used with command=create, c ommand=replicate. Requires boto >= 2.26.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the EC2_REGION environment variable, if any, is used.",
            "type": "string"
          },
          "security_groups": {
            "description": "Comma separated list of one or more security groups.  Used only when command=create or command=modify.",
            "type": "string"
          },
          "size": {
            "description": "Size in gigabytes of the initial storage for the DB instance. Used only when command=create or command=modify.",
            "type": "string"
          },
          "snapshot": {
            "description": "Name of snapshot to take. When command=delete, if no snapshot name is provided then no snapshot is taken. If used with command=delete with no instance_name, the snapshot is deleted. Used with command=facts, command=delete or command=snapshot.",
            "type": "string"
          },
          "source_instance": {
            "description": "Name of the database to replicate. Used only when command=repl icate.",
            "type": "string"
          },
          "subnet": {
            "description": "VPC subnet group.  If specified then a VPC instance is created. Used only when command=create.",
            "type": "string"
          },
          "tags": {
            "description": "tags dict to apply to a resource. Used with command=create, c ommand=replicate, command=restore. Requires boto >= 2.26.0",
            "type": "string"
          },
          "upgrade": {
            "description": "Indicates that minor version upgrades should be applied automatically. Used only when command=create or command=replicate .",
            "type": "string"
          },
          "username": {
            "description": "Master database username. Used only when command=create.",
            "type": "string"
          },
          "vpc_security_groups": {
            "description": "Comma separated list of one or more vpc security group ids. Also requires `subnet` to be specified. Used only when command=create or command=modify.",
            "type": "string"
          },
          "wait": {
            "description": "When command=create, replicate, modify or restore then wait for the database to enter the 'available' state.  When command=delete wait for the database to be terminated.",
            "type": "string"
          },
          "wait_timeout": {
            "description": "how long before wait gives up, in seconds",
            "type": "string"
          },
          "zone": {
            "description": "availability zone in which to launch the instance. Used only when command=create, command=replicate or command=restore.",
            "type": "string"
          }
        },
        "required": [
          "command",
          "region"
        ]
      }
    },
    {
      "rds_param_group": {
        "type": "object",
        "description": "manage RDS parameter groups",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "description": {
            "description": "Database parameter group description. Only set when a new group is added.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "engine": {
            "description": "The type of database for this group. Required for state=present.",
            "type": "string"
          },
          "immediate": {
            "description": "Whether to apply the changes immediately, or after the next reboot of any associated instances.",
            "type": "string"
          },
          "name": {
            "description": "Database parameter group identifier.",
            "type": "string"
          },
          "params": {
            "description": "Map of parameter names and values. Numeric values may be represented as K for kilo (1024), M for mega (1024^2), G for giga (1024^3), or T for tera (1024^4), and these values will be expanded into the appropriate number before being set in the parameter group.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "Specifies whether the group should be present or absent.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "state"
        ]
      }
    },
    {
      "rds_subnet_group": {
        "type": "object",
        "description": "manage RDS database subnet groups",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "description": {
            "description": "Database subnet group description. Only set when a new group is added.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "name": {
            "description": "Database subnet group identifier.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "Specifies whether the subnet should be present or absent.",
            "type": "string"
          },
          "subnets": {
            "description": "List of subnet IDs that make up the database subnet group.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "state"
        ]
      }
    },
    {
      "redhat_subscription": {
        "type": "object",
        "description": "Manage registration and subscriptions to RHSM using the `subscription-manager' command",
        "properties": {
          "activationkey": {
            "description": "supply an activation key for use with registration",
            "type": "string"
          },
          "autosubscribe": {
            "description": "Upon successful registration, auto-consume available subscriptions",
            "type": "string"
          },
          "consumer_id": {
            "description": "References an existing consumer ID to resume using a previous registration for this system. If the  system's identity certificate is lost or corrupted, this option allows it to resume using its previous identity and subscriptions. The default is to not specify a consumer ID so a new ID is created.",
            "type": "string"
          },
          "consumer_name": {
            "description": "Name of the system to register, defaults to the hostname",
            "type": "string"
          },
          "consumer_type": {
            "description": "The type of unit to register, defaults to system",
            "type": "string"
          },
          "environment": {
            "description": "Register with a specific environment in the destination org. Used with Red Hat Satellite 6.x or Katello",
            "type": "string"
          },
          "force_register": {
            "description": "Register the system even if it is already registered",
            "type": "string"
          },
          "org_id": {
            "description": "Organization ID to use in conjunction with activationkey",
            "type": "string"
          },
          "password": {
            "description": "access.redhat.com or Sat6 password",
            "type": "string"
          },
          "pool": {
            "description": "Specify a subscription pool name to consume. Regular expressions accepted.",
            "type": "string"
          },
          "rhsm_baseurl": {
            "description": "Specify CDN baseurl",
            "type": "string"
          },
          "server_hostname": {
            "description": "Specify an alternative Red Hat Subscription Management or Sat6 server",
            "type": "string"
          },
          "server_insecure": {
            "description": "Enable or disable https server certificate verification when connecting to `server_hostname'",
            "type": "string"
          },
          "state": {
            "description": "whether to register and subscribe (`present'), or unregister (`absent') a system",
            "type": "string"
          },
          "username": {
            "description": "access.redhat.com or Sat6  username",
            "type": "string"
          }
        }
      }
    },
    {
      "redis": {
        "type": "object",
        "description": "Various redis commands, slave and flush",
        "properties": {
          "command": {
            "description": "The selected redis command",
            "type": "string"
          },
          "db": {
            "description": "The database to flush (used in db mode) [flush command]",
            "type": "string"
          },
          "flush_mode": {
            "description": "Type of flush (all the dbs in a redis instance or a specific one) [flush command]",
            "type": "string"
          },
          "login_host": {
            "description": "The host running the database",
            "type": "string"
          },
          "login_password": {
            "description": "The password used to authenticate with (usually not used)",
            "type": "string"
          },
          "login_port": {
            "description": "The port to connect to",
            "type": "string"
          },
          "master_host": {
            "description": "The host of the master instance [slave command]",
            "type": "string"
          },
          "master_port": {
            "description": "The port of the master instance [slave command]",
            "type": "string"
          },
          "name": {
            "description": "A redis config key.",
            "type": "string"
          },
          "slave_mode": {
            "description": "the mode of the redis instance [slave command]",
            "type": "string"
          },
          "value": {
            "description": "A redis config value.",
            "type": "string"
          }
        },
        "required": "command"
      }
    },
    {
      "redshift": {
        "type": "object",
        "description": "create, delete, or modify an Amazon Redshift instance",
        "properties": {
          "allow_version_upgrade": {
            "description": "flag to determinate if upgrade of version is possible",
            "type": "string"
          },
          "automated_snapshot_retention_period": {
            "description": "period when the snapshot take place",
            "type": "string"
          },
          "availability_zone": {
            "description": "availability zone in which to launch cluster",
            "type": "string"
          },
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "cluster_parameter_group_name": {
            "description": "name of the cluster parameter group",
            "type": "string"
          },
          "cluster_security_groups": {
            "description": "in which security group the cluster belongs",
            "type": "string"
          },
          "cluster_subnet_group_name": {
            "description": "which subnet to place the cluster",
            "type": "string"
          },
          "cluster_type": {
            "description": "The type of cluster.",
            "type": "string"
          },
          "cluster_version": {
            "description": "which version the cluster should have",
            "type": "string"
          },
          "command": {
            "description": "Specifies the action to take.",
            "type": "string"
          },
          "db_name": {
            "description": "Name of the database.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "elastic_ip": {
            "description": "if the cluster has an elastic IP or not",
            "type": "string"
          },
          "encrypted": {
            "description": "if the cluster is encrypted or not",
            "type": "string"
          },
          "identifier": {
            "description": "Redshift cluster identifier.",
            "type": "string"
          },
          "new_cluster_identifier": {
            "description": "Only used when command=modify.",
            "type": "string"
          },
          "node_type": {
            "description": "The node type of the cluster. Must be specified when command=create.",
            "type": "string"
          },
          "number_of_nodes": {
            "description": "Number of nodes. Only used when cluster_type =multi-node.",
            "type": "string"
          },
          "password": {
            "description": "Master database password. Used only when command=create.",
            "type": "string"
          },
          "port": {
            "description": "which port the cluster is listining",
            "type": "string"
          },
          "preferred_maintenance_window": {
            "description": "maintenance window",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "publicly_accessible": {
            "description": "if the cluster is accessible publicly or not",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "username": {
            "description": "Master database username. Used only when command=create.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "vpc_security_group_ids": {
            "description": "VPC security group",
            "type": "string"
          },
          "wait": {
            "description": "When command=create, modify or restore then wait for the database to enter the 'available' state. When command=delete wait for the database to be terminated.",
            "type": "string"
          },
          "wait_timeout": {
            "description": "how long before wait gives up, in seconds",
            "type": "string"
          }
        },
        "required": [
          "command",
          "identifier"
        ]
      }
    },
    {
      "redshift_subnet_group": {
        "type": "object",
        "description": "mange Redshift cluster subnet groups",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "group_description": {
            "description": "Database subnet group description.",
            "type": "string"
          },
          "group_name": {
            "description": "Cluster subnet group name.",
            "type": "string"
          },
          "group_subnets": {
            "description": "List of subnet IDs that make up the cluster subnet group.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "Specifies whether the subnet should be present or absent.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        },
        "required": "group_name"
      }
    },
    {
      "replace": {
        "type": "object",
        "description": "Replace all instances of a particular string in a file using a back-referenced regular expression.",
        "properties": {
          "backup": {
            "description": "Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.",
            "type": "string"
          },
          "dest": {
            "description": "The file to modify.",
            "type": "string"
          },
          "follow": {
            "description": "This flag indicates that filesystem links, if they exist, should be followed.",
            "type": "string"
          },
          "group": {
            "description": "name of the group that should own the file/directory, as would be fed to `chown'",
            "type": "string"
          },
          "mode": {
            "description": "mode the file or directory should be. For those used to `/usr/bin/chmod' remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, `u+rwx' or `u=rw,g=r,o=r').",
            "type": "string"
          },
          "others": {
            "description": "All arguments accepted by the [file] module also work here.",
            "type": "string"
          },
          "owner": {
            "description": "name of the user that should own the file/directory, as would be fed to `chown'",
            "type": "string"
          },
          "regexp": {
            "description": "The regular expression to look for in the contents of the file. Uses Python regular expressions; see  http://docs.pytho n.org/2/library/r e.html. Uses multiline mode, which means `^' and `$' match the beginning and end respectively of `each line' of the file.",
            "type": "string"
          },
          "replace": {
            "description": "The string to replace regexp matches. May contain backreferences that will get expanded with the regexp capture groups if the regexp matches. If not set, matches are removed entirely.",
            "type": "string"
          },
          "selevel": {
            "description": "level part of the SELinux file context. This is the MLS/MCS attribute, sometimes known as the `range'. `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "serole": {
            "description": "role part of SELinux file context, `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "setype": {
            "description": "type part of SELinux file context, `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "seuser": {
            "description": "user part of SELinux file context. Will default to system policy, if applicable. If set to `_default', it will use the `user' portion of the policy if available",
            "type": "string"
          },
          "unsafe_writes": {
            "description": "Normally this module uses atomic operations to prevent data corruption or inconsistent reads from the target files, sometimes systems are configured or just broken in ways that prevent this. One example are docker mounted files, they cannot be updated atomically and can only be done in an unsafe manner. This boolean option allows ansible to fall back to unsafe methods of updating files for those cases in which you do not have any other choice. Be aware that this is subject to race conditions and can lead to data corruption.",
            "type": "string"
          },
          "validate": {
            "description": "The validation command to run before copying into place. The path to the file to validate is passed in via '%s' which must be present as in the example below. The command is passed securely so shell features like expansion and pipes won't work.",
            "type": "string"
          }
        },
        "required": [
          "dest",
          "regexp"
        ]
      }
    },
    {
      "rhevm": {
        "type": "object",
        "description": "RHEV/oVirt automation",
        "properties": {
          "boot_order": {
            "description": "This option uses complex arguments and is a list of items that specify the bootorder.",
            "type": "string"
          },
          "cd_drive": {
            "description": "The CD you wish to have mounted on the VM when `state = 'CD''.",
            "type": "string"
          },
          "cluster": {
            "description": "The rhev/ovirt cluster in which you want you VM to start.",
            "type": "string"
          },
          "cpu_share": {
            "description": "This parameter is used to configure the cpu share.",
            "type": "string"
          },
          "datacenter": {
            "description": "The rhev/ovirt datacenter in which you want you VM to start.",
            "type": "string"
          },
          "del_prot": {
            "description": "This option sets the delete protection checkbox.",
            "type": "string"
          },
          "disks": {
            "description": "This option uses complex arguments and is a list of disks with the options name, size and domain.",
            "type": "string"
          },
          "ifaces": {
            "description": "This option uses complex arguments and is a list of interfaces with the options name and vlan.",
            "type": "string"
          },
          "image": {
            "description": "The template to use for the VM.",
            "type": "string"
          },
          "insecure_api": {
            "description": "A boolean switch to make a secure or insecure connection to the server.",
            "type": "string"
          },
          "mempol": {
            "description": "The minimum amount of memory you wish to reserve for this system.",
            "type": "string"
          },
          "name": {
            "description": "The name of the VM.",
            "type": "string"
          },
          "osver": {
            "description": "The operationsystem option in RHEV/oVirt.",
            "type": "string"
          },
          "port": {
            "description": "The port on which the API is reacheable.",
            "type": "string"
          },
          "server": {
            "description": "The name/ip of your RHEV-m/oVirt instance.",
            "type": "string"
          },
          "state": {
            "description": "This serves to create/remove/update or powermanage your VM.",
            "type": "string"
          },
          "timeout": {
            "description": "The timeout you wish to define for power actions. When `state = 'up'' When `state = 'down'' When `state = 'restarted''",
            "type": "string"
          },
          "type": {
            "description": "To define if the VM is a server or desktop.",
            "type": "string"
          },
          "user": {
            "description": "The user to authenticate with.",
            "type": "string"
          },
          "vm_ha": {
            "description": "To make your VM High Available.",
            "type": "string"
          },
          "vmcpu": {
            "description": "The number of CPUs you want in your VM.",
            "type": "string"
          },
          "vmhost": {
            "description": "The host you wish your VM to run on.",
            "type": "string"
          },
          "vmmem": {
            "description": "The amount of memory you want your VM to use (in GB).",
            "type": "string"
          }
        }
      }
    },
    {
      "rhn_channel": {
        "type": "object",
        "description": "Adds or removes Red Hat software channels",
        "properties": {
          "name": {
            "description": "name of the software channel",
            "type": "string"
          },
          "password": {
            "description": "the user's password",
            "type": "string"
          },
          "state": {
            "description": "whether the channel should be present or not",
            "type": "string"
          },
          "sysname": {
            "description": "name of the system as it is known in RHN/Satellite",
            "type": "string"
          },
          "url": {
            "description": "The full url to the RHN/Satellite api",
            "type": "string"
          },
          "user": {
            "description": "RHN/Satellite user",
            "type": "string"
          }
        },
        "required": [
          "name",
          "password",
          "sysname",
          "url",
          "user"
        ]
      }
    },
    {
      "rhn_register": {
        "type": "object",
        "description": "Manage Red Hat Network registration using the `rhnreg_ks' command",
        "properties": {
          "activationkey": {
            "description": "supply an activation key for use with registration",
            "type": "string"
          },
          "channels": {
            "description": "Optionally specify a list of comma-separated channels to subscribe to upon successful registration.",
            "type": "string"
          },
          "password": {
            "description": "Red Hat Network password",
            "type": "string"
          },
          "profilename": {
            "description": "supply an profilename for use with registration",
            "type": "string"
          },
          "server_url": {
            "description": "Specify an alternative Red Hat Network server URL",
            "type": "string"
          },
          "sslcacert": {
            "description": "supply a custom ssl CA certificate file for use with registration",
            "type": "string"
          },
          "state": {
            "description": "whether to register (`present'), or unregister (`absent') a system",
            "type": "string"
          },
          "systemorgid": {
            "description": "supply an organizational id for use with registration",
            "type": "string"
          },
          "username": {
            "description": "Red Hat Network username",
            "type": "string"
          }
        }
      }
    },
    {
      "riak": {
        "type": "object",
        "description": "This module handles some common Riak operations",
        "properties": {
          "command": {
            "description": "The command you would like to perform against the cluster.",
            "type": "string"
          },
          "config_dir": {
            "description": "The path to the riak configuration directory",
            "type": "string"
          },
          "http_conn": {
            "description": "The ip address and port that is listening for Riak HTTP queries",
            "type": "string"
          },
          "target_node": {
            "description": "The target node for certain operations (join, ping)",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          },
          "wait_for_handoffs": {
            "description": "Number of seconds to wait for handoffs to complete.",
            "type": "string"
          },
          "wait_for_ring": {
            "description": "Number of seconds to wait for all nodes to agree on the ring.",
            "type": "string"
          },
          "wait_for_service": {
            "description": "Waits for a riak service to come online before continuing.",
            "type": "string"
          }
        }
      }
    },
    {
      "rocketchat": {
        "type": "object",
        "description": "Send notifications to Rocket Chat",
        "properties": {
          "attachments": {
            "description": "Define a list of attachments.",
            "type": "string"
          },
          "channel": {
            "description": "Channel to send the message to. If absent, the message goes to the channel selected for the `token' specifed during the creation of webhook.",
            "type": "string"
          },
          "color": {
            "description": "Allow text to use default colors - use the default of 'normal' to not send a custom color bar at the start of the message",
            "type": "string"
          },
          "domain": {
            "description": "The domain for your environment without protocol. (i.e. ` subdomain.domain. com or chat.domain.tld')",
            "type": "string"
          },
          "icon_emoji": {
            "description": "Emoji for the message sender. The representation for the available emojis can be got from Rocket Chat. (for example :thumbsup:) (if `icon_emoji' is set, `icon_url' will not be used)",
            "type": "string"
          },
          "icon_url": {
            "description": "URL for the message sender's icon.",
            "type": "string"
          },
          "link_names": {
            "description": "Automatically create links for channels and usernames in `msg'.",
            "type": "string"
          },
          "msg": {
            "description": "Message to be sent.",
            "type": "string"
          },
          "protocol": {
            "description": "Specify the protocol used to send notification messages before the webhook url. (i.e. http or https)",
            "type": "string"
          },
          "token": {
            "description": "Rocket Chat Incoming Webhook integration token. This provides authentication to Rocket Chat's Incoming webhook for posting messages.",
            "type": "string"
          },
          "username": {
            "description": "This is the sender of the message.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": [
          "domain",
          "token"
        ]
      }
    },
    {
      "rollbar_deployment": {
        "type": "object",
        "description": "Notify Rollbar about app deployments",
        "properties": {
          "comment": {
            "description": "Deploy comment (e.g. what is being deployed).",
            "type": "string"
          },
          "environment": {
            "description": "Name of the environment being deployed, e.g. 'production'.",
            "type": "string"
          },
          "revision": {
            "description": "Revision number/sha being deployed.",
            "type": "string"
          },
          "rollbar_user": {
            "description": "Rollbar username of the user who deployed.",
            "type": "string"
          },
          "token": {
            "description": "Your project access token.",
            "type": "string"
          },
          "url": {
            "description": "Optional URL to submit the notification to.",
            "type": "string"
          },
          "user": {
            "description": "User who deployed.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates for the target url will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": [
          "environment",
          "revision",
          "token"
        ]
      }
    },
    {
      "route53": {
        "type": "object",
        "description": "add or delete entries in Amazons Route53 DNS service",
        "properties": {
          "alias": {
            "description": "Indicates if this is an alias record.",
            "type": "string"
          },
          "alias_evaluate_target_health": {
            "description": "Whether or not to evaluate an alias target health. Useful for aliases to Elastic Load Balancers.",
            "type": "string"
          },
          "alias_hosted_zone_id": {
            "description": "The hosted zone identifier.",
            "type": "string"
          },
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "command": {
            "description": "Specifies the action to take.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "failover": {
            "description": "Failover resource record sets only. Whether this is the primary or secondary resource record set. Allowed values are PRIMARY and SECONDARY",
            "type": "string"
          },
          "health_check": {
            "description": "Health check to associate with this record",
            "type": "string"
          },
          "hosted_zone_id": {
            "description": "The Hosted Zone ID of the DNS zone to modify",
            "type": "string"
          },
          "identifier": {
            "description": "Have to be specified for Weighted, latency-based and failover resource record sets only. An identifier that differentiates among multiple resource record sets that have the same combination of DNS name and type.",
            "type": "string"
          },
          "overwrite": {
            "description": "Whether an existing record should be overwritten on create if values do not match",
            "type": "string"
          },
          "private_zone": {
            "description": "If set to true, the private zone matching the requested name within the domain will be used if there are both public and private zones. The default is to use the public zone.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "record": {
            "description": "The full DNS record to create or delete",
            "type": "string"
          },
          "region": {
            "description": "Latency-based resource record sets only Among resource record sets that have the same combination of DNS name and type, a value that determines which region this should be associated with for the latency- based routing",
            "type": "string"
          },
          "retry_interval": {
            "description": "In the case that route53 is still servicing a prior request, this module will wait and try again after this many seconds. If you have many domain names, the default of 500 seconds may be too long.",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "ttl": {
            "description": "The TTL to give the new record",
            "type": "string"
          },
          "type": {
            "description": "The type of DNS record to create",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "value": {
            "description": "The new value when creating a DNS record. Multiple comma- spaced values are allowed for non- alias records. When deleting a record all values for the record must be specified or Route53 will not delete it.",
            "type": "string"
          },
          "vpc_id": {
            "description": "When used in conjunction with private_zone: true, this will only modify records in the private hosted zone attached to this VPC. This allows you to have multiple private hosted zones, all with the same name, attached to different VPCs.",
            "type": "string"
          },
          "wait": {
            "description": "Wait until the changes have been replicated to all Amazon Route 53 DNS servers.",
            "type": "string"
          },
          "wait_timeout": {
            "description": "How long to wait for the changes to be replicated, in seconds.",
            "type": "string"
          },
          "weight": {
            "description": "Weighted resource record sets only. Among resource record sets that have the same combination of DNS name and type, a value that determines what portion of traffic for the current resource record set is routed to the associated location.",
            "type": "string"
          },
          "zone": {
            "description": "The DNS zone to modify",
            "type": "string"
          }
        },
        "required": [
          "command",
          "record",
          "type",
          "zone"
        ]
      }
    },
    {
      "route53_facts": {
        "type": "object",
        "description": "Retrieves route53 details using AWS methods",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "change_id": {
            "description": "The ID of the change batch request. The value that you specify here is the value that ChangeResour ceRecordSets returned in the Id element when you submitted the request.",
            "type": "string"
          },
          "delegation_set_id": {
            "description": "The DNS Zone delegation set ID",
            "type": "string"
          },
          "dns_name": {
            "description": "The first name in the lexicographic ordering of domain names that you want the list_command to start listing from",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "health_check_id": {
            "description": "The ID of the health check",
            "type": "string"
          },
          "health_check_method": {
            "description": "This is used in conjunction with query: health_check. It allows for listing details, counts or tags of various health check details.",
            "type": "string"
          },
          "hosted_zone_id": {
            "description": "The Hosted Zone ID of the DNS zone",
            "type": "string"
          },
          "hosted_zone_method": {
            "description": "This is used in conjunction with query: hosted_zone. It allows for listing details, counts or tags of various hosted zone details.",
            "type": "string"
          },
          "max_items": {
            "description": "Maximum number of items to return for various get/list requests",
            "type": "string"
          },
          "next_marker": {
            "description": "Some requests such as list_command: hosted_zones will return a maximum number of entries - EG 100. If the number of entries exceeds this maximum another request can be sent using the NextMarker entry from the first response to get the next page of results",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "query": {
            "description": "specifies the query action to take",
            "type": "string"
          },
          "resource_id": {
            "description": "The ID/s of the specified resource/s",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "start_record_name": {
            "description": "The first name in the lexicographic ordering of domain names that you want the list_command: record_sets to start listing from",
            "type": "string"
          },
          "type": {
            "description": "The type of DNS record",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        },
        "required": "query"
      }
    },
    {
      "route53_health_check": {
        "type": "object",
        "description": "add or delete health-checks in Amazons Route53 DNS service",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "failure_threshold": {
            "description": "The number of consecutive health checks that an endpoint must pass or fail for Amazon Route 53 to change the current status of the endpoint from unhealthy to healthy or vice versa.",
            "type": "string"
          },
          "fqdn": {
            "description": "Domain name of the endpoint to check. Either this or `ip_address` has to be provided. When both are given the `fqdn` is used in the `Host:` header of the HTTP request.",
            "type": "string"
          },
          "ip_address": {
            "description": "IP address of the end-point to check. Either this or `fqdn` has to be provided.",
            "type": "string"
          },
          "port": {
            "description": "The port on the endpoint on which you want Amazon Route 53 to perform health checks. Required for TCP checks.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "request_interval": {
            "description": "The number of seconds between the time that Amazon Route 53 gets a response from your endpoint and the time that it sends the next health-check request.",
            "type": "string"
          },
          "resource_path": {
            "description": "The path that you want Amazon Route 53 to request when performing health checks. The path can be any value for which your endpoint will return an HTTP status code of 2xx or 3xx when the endpoint is healthy, for example the file /docs/route53 -health- check.html. Required for all checks except TCP. The path must begin with a / Maximum 255 characters.",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "Specifies the action to take.",
            "type": "string"
          },
          "string_match": {
            "description": "If the check type is HTTP_STR_MATCH or HTTP_STR_MATCH, the string that you want Amazon Route 53 to search for in the response body from the specified resource. If the string appears in the first 5120 bytes of the response body, Amazon Route 53 considers the resource healthy.",
            "type": "string"
          },
          "type": {
            "description": "The type of health check that you want to create, which indicates how Amazon Route 53 determines whether an endpoint is healthy.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        },
        "required": [
          "failure_threshold",
          "request_interval",
          "state",
          "type"
        ]
      }
    },
    {
      "route53_zone": {
        "type": "object",
        "description": "add or delete Route53 zones",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "comment": {
            "description": "Comment associated with the zone",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "whether or not the zone should exist or not",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "vpc_id": {
            "description": "The VPC ID the zone should be a part of (if this is going to be a private zone)",
            "type": "string"
          },
          "vpc_region": {
            "description": "The VPC Region the zone should be a part of (if this is going to be a private zone)",
            "type": "string"
          },
          "zone": {
            "description": "The DNS zone record (eg: foo.com.)",
            "type": "string"
          }
        },
        "required": "zone"
      }
    },
    {
      "rpm_key": {
        "type": "object",
        "description": "Adds or removes a gpg key from the rpm db",
        "properties": {
          "key": {
            "description": "Key that will be modified. Can be a url, a file, or a keyid if the key already exists in the database.",
            "type": "string"
          },
          "state": {
            "description": "If the key will be imported or removed from the rpm db.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no' and the `key' is a url starting with https, SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": "key"
      }
    },
    {
      "s3": {
        "type": "object",
        "description": "manage objects in S3.",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "bucket": {
            "description": "Bucket name.",
            "type": "string"
          },
          "dest": {
            "description": "The destination file path when downloading an object/key with a GET operation.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "encrypt": {
            "description": "When set for PUT mode, asks for server-side encryption",
            "type": "string"
          },
          "expiration": {
            "description": "Time limit (in seconds) for the URL generated and returned by S3/Walrus when performing a mode=put or mode=geturl operation.",
            "type": "string"
          },
          "headers": {
            "description": "Custom headers for PUT operation, as a dictionary of 'key=value' and ' key=value,key=val ue'.",
            "type": "string"
          },
          "marker": {
            "description": "Specifies the key to start with when using list mode. Object keys are returned in alphabetical order, starting with key after the marker in order.",
            "type": "string"
          },
          "max_keys": {
            "description": "Max number of results to return in list mode, set this if you want to retrieve fewer than the default 1000 keys.",
            "type": "string"
          },
          "metadata": {
            "description": "Metadata for PUT operation, as a dictionary of 'key=value' and ' key=value,key=val ue'.",
            "type": "string"
          },
          "mode": {
            "description": "Switches the module behaviour between put (upload), get (download), geturl (return download url, Ansible 1.3+), getstr (download object as string (1.3+)), list (list keys, Ansible 2.0+), create (bucket), delete (bucket), and delobj (delete object, Ansible 2.0+).",
            "type": "string"
          },
          "object": {
            "description": "Keyname of the object inside the bucket. Can be used to create \"virtual directories\", see examples.",
            "type": "string"
          },
          "overwrite": {
            "description": "Force overwrite either locally on the filesystem or remotely with the object/key. Used with PUT and GET operations. Boolean or one of [always, never, different], true is equal to 'always' and false is equal to 'never', new in 2.0",
            "type": "string"
          },
          "permission": {
            "description": "This option lets the user set the canned permissions on the object/bucket that are created. The permissions that can be set are 'private', 'public-read', 'public-read- write', 'authenticated- read'. Multiple permissions can be specified as a list.",
            "type": "string"
          },
          "prefix": {
            "description": "Limits the response to keys that begin with the specified prefix for list mode",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "AWS region to create the bucket in. If not set then the value of the AWS_REGION and EC2_REGION environment variables are checked, followed by the aws_region and ec2_region settings in the Boto config file. If none of those are set the region defaults to the S3 Location: US Standard.  Prior to ansible 1.8 this parameter could be specified but had no effect.",
            "type": "string"
          },
          "retries": {
            "description": "On recoverable failure, how many times to retry before actually failing.",
            "type": "string"
          },
          "rgw": {
            "description": "Enable Ceph RGW S3 support. This option requires an explicit url via s3_url.",
            "type": "string"
          },
          "s3_url": {
            "description": "S3 URL endpoint for usage with Ceph, Eucalypus, fakes3, etc. Otherwise assumes AWS",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "src": {
            "description": "The source file path when performing a PUT operation.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "version": {
            "description": "Version ID of the object inside the bucket. Can be used to get a specific version of a file if versioning is enabled in the target bucket.",
            "type": "string"
          }
        },
        "required": [
          "bucket",
          "mode"
        ]
      }
    },
    {
      "s3_bucket": {
        "type": "object",
        "description": "Manage S3 buckets in AWS, Ceph, Walrus and FakeS3",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ceph": {
            "description": "Enable API compatibility with Ceph. It takes into account the S3 API subset working with Ceph in order to provide the same module behaviour where possible.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "force": {
            "description": "When trying to delete a bucket, delete all keys in the bucket first (an s3 bucket must be empty for a successful deletion)",
            "type": "string"
          },
          "name": {
            "description": "Name of the s3 bucket",
            "type": "string"
          },
          "policy": {
            "description": "The JSON policy as a string.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "requester_pays": {
            "description": "With Requester Pays buckets, the requester instead of the bucket owner pays the cost of the request and the data download from the bucket.",
            "type": "string"
          },
          "s3_url": {
            "description": "S3 URL endpoint for usage with Ceph, Eucalypus, fakes3, etc. Otherwise assumes AWS",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "Create or remove the s3 bucket",
            "type": "string"
          },
          "tags": {
            "description": "tags dict to apply to bucket",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          },
          "versioning": {
            "description": "Whether versioning is enabled or disabled (note that once versioning is enabled, it can only be suspended)",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "s3_lifecycle": {
        "type": "object",
        "description": "Manage s3 bucket lifecycle rules in AWS",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "expiration_date": {
            "description": "Indicates the lifetime of the objects that are subject to the rule by the date they will expire. The value must be ISO-8601 format, the time must be midnight and a GMT timezone must be specified.",
            "type": "string"
          },
          "expiration_days": {
            "description": "Indicates the lifetime, in days, of the objects that are subject to the rule. The value must be a non-zero positive integer.",
            "type": "string"
          },
          "name": {
            "description": "Name of the s3 bucket",
            "type": "string"
          },
          "prefix": {
            "description": "Prefix identifying one or more objects to which the rule applies. If no prefix is specified, the rule will apply to the whole bucket.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "rule_id": {
            "description": "Unique identifier for the rule. The value cannot be longer than 255 characters. A unique value for the rule will be generated if no value is provided.",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "Create or remove the lifecycle rule",
            "type": "string"
          },
          "status": {
            "description": "If 'enabled', the rule is currently being applied. If 'disabled', the rule is not currently being applied.",
            "type": "string"
          },
          "storage_class": {
            "description": "The storage class to transition to. Currently there are two supported values - 'glacier' or 'standard_ia'. The 'standard_ia' class is only being available from Ansible version 2.2.",
            "type": "string"
          },
          "transition_date": {
            "description": "Indicates the lifetime of the objects that are subject to the rule by the date they will transition to a different storage class. The value must be ISO-8601 format, the time must be midnight and a GMT timezone must be specified. If transition_days is not specified, this parameter is required.",
            "type": "string"
          },
          "transition_days": {
            "description": "Indicates when, in days, an object transitions to a different storage class. If transition_date is not specified, this parameter is required.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "s3_logging": {
        "type": "object",
        "description": "Manage logging facility of an s3 bucket in AWS",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "name": {
            "description": "Name of the s3 bucket.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "Enable or disable logging.",
            "type": "string"
          },
          "target_bucket": {
            "description": "The bucket to log to. Required when state=present.",
            "type": "string"
          },
          "target_prefix": {
            "description": "The prefix that should be prepended to the generated log files written to the target_bucket.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "s3_website": {
        "type": "object",
        "description": "Configure an s3 bucket as a website",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "error_key": {
            "description": "The object key name to use when a 4XX class error occurs. To remove an error key, set to None.",
            "type": "string"
          },
          "name": {
            "description": "Name of the s3 bucket",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "redirect_all_requests": {
            "description": "Describes the redirect behavior for every request to this s3 bucket website endpoint",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "Add or remove s3 website configuration",
            "type": "string"
          },
          "suffix": {
            "description": "Suffix that is appended to a request that is for a directory on the website endpoint (e.g. if the suffix is index.html and you make a request to sample bucket/images/ the data that is returned will be for the object with the key name images/index.html ). The suffix must not include a slash character.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "script": {
        "type": "object",
        "description": "Runs a local script on a remote node after transferring it",
        "properties": {
          "creates": {
            "description": "a filename, when it already exists, this step will *not* be run.",
            "type": "string"
          },
          "free_form": {
            "description": "path to the local script file followed by optional arguments.",
            "type": "string"
          },
          "removes": {
            "description": "a filename, when it does not exist, this step will *not* be run.",
            "type": "string"
          }
        },
        "required": "free_form"
      }
    },
    {
      "seboolean": {
        "type": "object",
        "description": "Toggles SELinux booleans.",
        "properties": {
          "name": {
            "description": "Name of the boolean to configure",
            "type": "string"
          },
          "persistent": {
            "description": "Set to `yes' if the boolean setting should survive a reboot",
            "type": "string"
          },
          "state": {
            "description": "Desired boolean value",
            "type": "string"
          }
        },
        "required": [
          "name",
          "state"
        ]
      }
    },
    {
      "sefcontext": {
        "type": "object",
        "description": "Manages SELinux file context mapping definitions",
        "properties": {
          "ftype": {
            "description": "File type.",
            "type": "string"
          },
          "reload": {
            "description": "Reload SELinux policy after commit.",
            "type": "string"
          },
          "selevel": {
            "description": "SELinux range for the specified target.",
            "type": "string"
          },
          "setype": {
            "description": "SELinux type for the specified target.",
            "type": "string"
          },
          "seuser": {
            "description": "SELinux user for the specified target.",
            "type": "string"
          },
          "state": {
            "description": "Desired boolean value.",
            "type": "string"
          },
          "target": {
            "description": "Target path (expression).",
            "type": "string"
          }
        },
        "required": [
          "setype",
          "target"
        ]
      }
    },
    {
      "selinux": {
        "type": "object",
        "description": "Change policy and state of SELinux",
        "properties": {
          "conf": {
            "description": "path to the SELinux configuration file, if non- standard",
            "type": "string"
          },
          "policy": {
            "description": "name of the SELinux policy to use (example: `targeted') will be required if state is not `disabled'",
            "type": "string"
          },
          "state": {
            "description": "The SELinux mode",
            "type": "string"
          }
        },
        "required": "state"
      }
    },
    {
      "selinux_permissive": {
        "type": "object",
        "description": "Change permissive domain in SELinux policy",
        "properties": {
          "domain": {
            "description": "the domain that will be added or removed from the list of permissive domains",
            "type": "string"
          },
          "no_reload": {
            "description": "automatically reload the policy after a change default is set to 'false' as that's what most people would want after changing one domain Note that this doesn't work on older version of the library (example EL 6), the module will silently ignore it in this case",
            "type": "string"
          },
          "permissive": {
            "description": "indicate if the domain should or should not be set as permissive",
            "type": "string"
          },
          "store": {
            "description": "name of the SELinux policy store to use",
            "type": "string"
          }
        },
        "required": [
          "domain",
          "permissive"
        ]
      }
    },
    {
      "sendgrid": {
        "type": "object",
        "description": "Sends an email with the SendGrid API",
        "properties": {
          "api_key": {
            "description": "sendgrid API key to use instead of username/password",
            "type": "string"
          },
          "attachments": {
            "description": "a list of relative or explicit paths of files you want to attach (7MB limit as per SendGrid docs)",
            "type": "string"
          },
          "bcc": {
            "description": "a list of email addresses to bcc",
            "type": "string"
          },
          "cc": {
            "description": "a list of email addresses to cc",
            "type": "string"
          },
          "from_address": {
            "description": "the address in the \"from\" field for the email",
            "type": "string"
          },
          "from_name": {
            "description": "the name you want to appear in the from field, i.e 'John Doe'",
            "type": "string"
          },
          "headers": {
            "description": "a dict to pass on as headers",
            "type": "string"
          },
          "html_body": {
            "description": "whether the body is html content that should be rendered",
            "type": "string"
          },
          "password": {
            "description": "password that corresponds to the username Since 2.2 it is only required if api_key is not supplied.",
            "type": "string"
          },
          "subject": {
            "description": "the desired subject for the email",
            "type": "string"
          },
          "to_addresses": {
            "description": "a list with one or more recipient email addresses",
            "type": "string"
          },
          "username": {
            "description": "username for logging into the SendGrid account. Since 2.2 it is only required if api_key is not supplied.",
            "type": "string"
          }
        },
        "required": [
          "from_address",
          "subject",
          "to_addresses"
        ]
      }
    },
    {
      "sensu_check": {
        "type": "object",
        "description": "Manage Sensu checks",
        "properties": {
          "aggregate": {
            "description": "Classifies the check as an aggregate check, making it available via the aggregate API",
            "type": "string"
          },
          "backup": {
            "description": "Create a backup file (if yes), including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.",
            "type": "string"
          },
          "command": {
            "description": "Path to the sensu check to run (not required when `state=absent')",
            "type": "string"
          },
          "custom": {
            "description": "A hash/dictionary of custom parameters for mixing to the configuration. You can't rewrite others module parameters using this",
            "type": "string"
          },
          "dependencies": {
            "description": "Other checks this check depends on, if dependencies fail, handling of this check will be disabled",
            "type": "string"
          },
          "handle": {
            "description": "Whether the check should be handled or not",
            "type": "string"
          },
          "handlers": {
            "description": "List of handlers to notify when the check fails",
            "type": "string"
          },
          "high_flap_threshold": {
            "description": "The high threshhold for flap detection",
            "type": "string"
          },
          "interval": {
            "description": "Check interval in seconds",
            "type": "string"
          },
          "low_flap_threshold": {
            "description": "The low threshhold for flap detection",
            "type": "string"
          },
          "metric": {
            "description": "Whether the check is a metric",
            "type": "string"
          },
          "name": {
            "description": "The name of the check This is the key that is used to determine whether a check exists",
            "type": "string"
          },
          "occurrences": {
            "description": "Number of event occurrences before the handler should take action",
            "type": "string"
          },
          "path": {
            "description": "Path to the json file of the check to be added/removed. Will be created if it does not exist (unless `state=absent'). The parent folders need to exist when `state=present', otherwise an error will be thrown",
            "type": "string"
          },
          "publish": {
            "description": "Whether the check should be scheduled at all. You can still issue it via the sensu api",
            "type": "string"
          },
          "refresh": {
            "description": "Number of seconds handlers should wait before taking second action",
            "type": "string"
          },
          "source": {
            "description": "The check source, used to create a JIT Sensu client for an external resource (e.g. a network switch).",
            "type": "string"
          },
          "standalone": {
            "description": "Whether the check should be scheduled by the sensu client or server This option obviates the need for specifying the `subscribers' option",
            "type": "string"
          },
          "state": {
            "description": "Whether the check should be present or not",
            "type": "string"
          },
          "subdue_begin": {
            "description": "When to disable handling of check failures",
            "type": "string"
          },
          "subdue_end": {
            "description": "When to enable handling of check failures",
            "type": "string"
          },
          "subscribers": {
            "description": "List of subscribers/channels this check should run for See sensu_subscribers to subscribe a machine to a channel",
            "type": "string"
          },
          "timeout": {
            "description": "Timeout for the check",
            "type": "string"
          }
        },
        "required": [
          "command",
          "name"
        ]
      }
    },
    {
      "sensu_subscription": {
        "type": "object",
        "description": "Manage Sensu subscriptions",
        "properties": {
          "backup": {
            "description": "Create a backup file (if yes), including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.",
            "type": "string"
          },
          "name": {
            "description": "The name of the channel",
            "type": "string"
          },
          "path": {
            "description": "Path to the subscriptions json file",
            "type": "string"
          },
          "state": {
            "description": "Whether the machine should subscribe or unsubscribe from the channel",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "seport": {
        "type": "object",
        "description": "Manages SELinux network port type definitions",
        "properties": {
          "ports": {
            "description": "Ports or port ranges, separated by a comma",
            "type": "string"
          },
          "proto": {
            "description": "Protocol for the specified port.",
            "type": "string"
          },
          "reload": {
            "description": "Reload SELinux policy after commit.",
            "type": "string"
          },
          "setype": {
            "description": "SELinux type for the specified port.",
            "type": "string"
          },
          "state": {
            "description": "Desired boolean value.",
            "type": "string"
          }
        },
        "required": [
          "ports",
          "proto",
          "setype",
          "state"
        ]
      }
    },
    {
      "service": {
        "type": "object",
        "description": "Manage services.",
        "properties": {
          "arguments": {
            "description": "Additional arguments provided on the command line",
            "type": "string"
          },
          "enabled": {
            "description": "Whether the service should start on boot. *At least one of state and enabled are required.*",
            "type": "string"
          },
          "name": {
            "description": "Name of the service.",
            "type": "string"
          },
          "pattern": {
            "description": "If the service does not respond to the status command, name a substring to look for as would be found in the output of the `ps' command as a stand-in for a status result. If the string is found, the service will be assumed to be running.",
            "type": "string"
          },
          "runlevel": {
            "description": "For OpenRC init scripts (ex: Gentoo) only.  The runlevel that this service belongs to.",
            "type": "string"
          },
          "sleep": {
            "description": "If the service is being `restarted' then sleep this many seconds between the stop and start command. This helps to workaround badly behaving init scripts that exit immediately after signaling a process to stop.",
            "type": "string"
          },
          "state": {
            "description": "`started'/`stopped' are idempotent actions that will not run commands unless necessary. `restarted' will always bounce the service. `reloaded' will always reload. *At least one of state and enabled are required.*",
            "type": "string"
          },
          "use": {
            "description": "The service module actually uses system specific modules, normally through auto detection, this setting can force a specific module. Normally it uses the value of the 'ansible_s ervice_mgr' fact and falls back to the old 'service' module when none matching is found.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "set_fact": {
        "type": "object",
        "description": "Set host facts from a task",
        "properties": {
          "key_value": {
            "description": "The `set_fact' module takes key=value pairs as variables to set in the playbook scope. Or alternatively, accepts complex arguments using the `args:' statement.",
            "type": "string"
          }
        },
        "required": "key_value"
      }
    },
    {
      "setup": {
        "type": "object",
        "description": "Gathers facts about remote hosts",
        "properties": {
          "fact_path": {
            "description": "path used for local ansible facts (*.fact) - files in this dir will be run (if executable) and their results be added to ansible_local facts if a file is not executable it is read. Check notes for Windows options. (from 2.1 on) File/results format can be json or ini- format",
            "type": "string"
          },
          "filter": {
            "description": "if supplied, only return facts that match this shell-style (fnmatch) wildcard.",
            "type": "string"
          },
          "gather_subset": {
            "description": "if supplied, restrict the additional facts collected to the given subset. Possible values: all, hardware, network, virtual, ohai, and facter Can specify a list of values to specify a larger subset. Values can also be used with an initial `!' to specify that that specific subset should not be collected.  For instance: !hardware, !network, !virtual, !ohai, !facter.  Note that a few facts are always collected.  Use the filter parameter if you do not want to display those.",
            "type": "string"
          },
          "gather_timeout": {
            "description": "Set the default timeout in seconds for individual fact gathering",
            "type": "string"
          }
        }
      }
    },
    {
      "shell": {
        "type": "object",
        "description": "Execute commands in nodes.",
        "properties": {
          "chdir": {
            "description": "cd into this directory before running the command",
            "type": "string"
          },
          "creates": {
            "description": "a filename, when it already exists, this step will *not* be run.",
            "type": "string"
          },
          "executable": {
            "description": "change the shell used to execute the command. Should be an absolute path to the executable.",
            "type": "string"
          },
          "free_form": {
            "description": "The shell module takes a free form command to run, as a string. There's not an actual option named \"free form\".  See the examples!",
            "type": "string"
          },
          "removes": {
            "description": "a filename, when it does not exist, this step will *not* be run.",
            "type": "string"
          },
          "warn": {
            "description": "if command warnings are on in ansible.cfg, do not warn about this particular line if set to no/false.",
            "type": "string"
          }
        },
        "required": "free_form"
      }
    },
    {
      "sl_vm": {
        "type": "object",
        "description": "create or cancel a virtual instance in SoftLayer",
        "properties": {
          "cpus": {
            "description": "Count of cpus to be assigned to new virtual instance",
            "type": "string"
          },
          "datacenter": {
            "description": "Datacenter for the virtual instance to be deployed",
            "type": "string"
          },
          "dedicated": {
            "description": "Falg to determine if the instance should be deployed in dedicated space",
            "type": "string"
          },
          "disks": {
            "description": "List of disk sizes to be assigned to new virtual instance",
            "type": "string"
          },
          "domain": {
            "description": "Domain name to be provided to a virtual instance",
            "type": "string"
          },
          "hostname": {
            "description": "Hostname to be provided to a virtual instance",
            "type": "string"
          },
          "hourly": {
            "description": "Flag to determine if the instance should be hourly billed",
            "type": "string"
          },
          "image_id": {
            "description": "Image Template to be used for new virtual instance",
            "type": "string"
          },
          "instance_id": {
            "description": "Instance Id of the virtual instance to perform action option",
            "type": "string"
          },
          "local_disk": {
            "description": "Flag to determine if local disk should be used for the new instance",
            "type": "string"
          },
          "memory": {
            "description": "Amount of memory to be assigned to new virtual instance",
            "type": "string"
          },
          "nic_speed": {
            "description": "NIC Speed to be assigned to new virtual instance",
            "type": "string"
          },
          "os_code": {
            "description": "OS Code to be used for new virtual instance",
            "type": "string"
          },
          "post_uri": {
            "description": "URL of a post provisioning script ot be loaded and exectued on virtual instance",
            "type": "string"
          },
          "private": {
            "description": "Flag to determine if the instance should be private only",
            "type": "string"
          },
          "private_vlan": {
            "description": "VLAN by its Id to be assigned to the private NIC",
            "type": "string"
          },
          "public_vlan": {
            "description": "VLAN by its Id to be assigned to the public NIC",
            "type": "string"
          },
          "ssh_keys": {
            "description": "List of ssh keys by their Id to be assigned to a virtual instance",
            "type": "string"
          },
          "state": {
            "description": "Create, or cancel a virtual instance. Specify \"present\" for create, \"absent\" to cancel.",
            "type": "string"
          },
          "tags": {
            "description": "Tag or list of tags to be provided to a virtual instance",
            "type": "string"
          },
          "wait": {
            "description": "Flag used to wait for active status before returning",
            "type": "string"
          },
          "wait_timeout": {
            "description": "time in seconds before wait returns",
            "type": "string"
          }
        },
        "required": [
          "cpus",
          "disks",
          "memory"
        ]
      }
    },
    {
      "slack": {
        "type": "object",
        "description": "Send Slack notifications",
        "properties": {
          "attachments": {
            "description": "Define a list of attachments. This list mirrors the Slack JSON API. For more information, see  https://api.slack .com/docs/attachm ents",
            "type": "string"
          },
          "channel": {
            "description": "Channel to send the message to. If absent, the message goes to the channel selected for the `token'.",
            "type": "string"
          },
          "color": {
            "description": "Allow text to use default colors - use the default of 'normal' to not send a custom color bar at the start of the message",
            "type": "string"
          },
          "domain": {
            "description": "Slack (sub)domain for your environment without protocol. (i.e. ` future500.slack.c om') In 1.8 and beyond, this is deprecated and may be ignored. See token documentation for information.",
            "type": "string"
          },
          "icon_emoji": {
            "description": "Emoji for the message sender. See Slack documentation for options. (if `icon_emoji' is set, `icon_url' will not be used)",
            "type": "string"
          },
          "icon_url": {
            "description": "Url for the message sender's icon (default `https://www.ansi ble.com/favicon.i co')",
            "type": "string"
          },
          "link_names": {
            "description": "Automatically create links for channels and usernames in `msg'.",
            "type": "string"
          },
          "msg": {
            "description": "Message to send.",
            "type": "string"
          },
          "parse": {
            "description": "Setting for the message parser at Slack",
            "type": "string"
          },
          "token": {
            "description": "Slack integration token.  This authenticates you to the slack service. Prior to 1.8, a token looked like `3Ffe 373sfhRE6y42Fg3rv f4GlK'.  In 1.8 and above, ansible adapts to the new slack API where tokens look like `G922VJP24/D 921DW937/3Ffe373s fhRE6y42Fg3rvf4Gl K'.  If tokens are in the new format then slack will ignore any value of domain. If the token is in the old format the domain is required. Ansible has no control of when slack will get rid of the old API.  When slack does that the old format will stop working.",
            "type": "string"
          },
          "username": {
            "description": "This is the sender of the message.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.",
            "type": "string"
          }
        },
        "required": "token"
      }
    },
    {
      "slackpkg": {
        "type": "object",
        "description": "Package manager for Slackware >= 12.2",
        "properties": {
          "name": {
            "description": "name of package to install/remove",
            "type": "string"
          },
          "state": {
            "description": "state of the package, you can use \"installed\" as an alias for `present' and removed as one for c(absent).",
            "type": "string"
          },
          "update_cache": {
            "description": "update the package database first",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "slurp": {
        "type": "object",
        "description": "Slurps a file from remote nodes",
        "properties": {
          "src": {
            "description": "The file on the remote system to fetch. This `must' be a file, not a directory.",
            "type": "string"
          }
        },
        "required": "src"
      }
    },
    {
      "smartos_image_facts": {
        "type": "object",
        "description": "Get SmartOS image details.",
        "properties": {
          "filters": {
            "description": "Criteria for selecting image. Can be any value from image manifest and 'published_date', 'published', 'source', 'clones', and 'size'. More informaton can be found at https:// smartos.org/man/1 m/imgadm under 'imgadm list'.",
            "type": "string"
          }
        }
      }
    },
    {
      "snmp_facts": {
        "type": "object",
        "description": "Retrieve facts for a device using SNMP.",
        "properties": {
          "authkey": {
            "description": "Authentication key, required if version is v3",
            "type": "string"
          },
          "community": {
            "description": "The SNMP community string, required if version is v2/v2c",
            "type": "string"
          },
          "host": {
            "description": "Set to target snmp server (normally {{inventory_hostn ame}})",
            "type": "string"
          },
          "integrity": {
            "description": "Hashing algoritm, required if version is v3",
            "type": "string"
          },
          "level": {
            "description": "Authentication level, required if version is v3",
            "type": "string"
          },
          "privacy": {
            "description": "Encryption algoritm, required if level is authPriv",
            "type": "string"
          },
          "privkey": {
            "description": "Encryption key, required if version is authPriv",
            "type": "string"
          },
          "username": {
            "description": "Username for SNMPv3, required if version is v3",
            "type": "string"
          },
          "version": {
            "description": "SNMP Version to use, v2/v2c or v3",
            "type": "string"
          }
        },
        "required": [
          "host",
          "version"
        ]
      }
    },
    {
      "sns": {
        "type": "object",
        "description": "Send Amazon Simple Notification Service (SNS) messages",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "email": {
            "description": "Message to send to email-only subscription",
            "type": "string"
          },
          "http": {
            "description": "Message to send to HTTP-only subscription",
            "type": "string"
          },
          "https": {
            "description": "Message to send to HTTPS-only subscription",
            "type": "string"
          },
          "msg": {
            "description": "Default message to send.",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the EC2_REGION environment variable, if any, is used.",
            "type": "string"
          },
          "sms": {
            "description": "Message to send to SMS-only subscription",
            "type": "string"
          },
          "sqs": {
            "description": "Message to send to SQS-only subscription",
            "type": "string"
          },
          "subject": {
            "description": "Subject line for email delivery.",
            "type": "string"
          },
          "topic": {
            "description": "The topic you want to publish to.",
            "type": "string"
          }
        },
        "required": [
          "msg",
          "topic"
        ]
      }
    },
    {
      "sns_topic": {
        "type": "object",
        "description": "Manages AWS SNS topics and subscriptions",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "delivery_policy": {
            "description": "Delivery policy to apply to the SNS topic",
            "type": "string"
          },
          "display_name": {
            "description": "Display name of the topic",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "name": {
            "description": "The name or ARN of the SNS topic to converge",
            "type": "string"
          },
          "policy": {
            "description": "Policy to apply to the SNS topic",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "purge_subscriptions": {
            "description": "Whether to purge any subscriptions not listed here. NOTE: AWS does not allow you to purge any  PendingConfirmati on subscriptions, so if any exist and would be purged, they are silently skipped. This means that somebody could come back later and confirm the subscription. Sorry. Blame Amazon.",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "Whether to create or destroy an SNS topic",
            "type": "string"
          },
          "subscriptions": {
            "description": "List of subscriptions to apply to the topic. Note that AWS requires subscriptions to be confirmed, so you will need to confirm any new subscriptions.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "solaris_zone": {
        "type": "object",
        "description": "Manage Solaris zones",
        "properties": {
          "attach_options": {
            "description": "Extra options to the zoneadm attach command. For example, this can be used to specify whether a minimum or full update of packages is required and if any packages need to be deleted. For valid values, see zoneadm(1M)",
            "type": "string"
          },
          "config": {
            "description": "The zonecfg configuration commands for this zone. See zonecfg(1M) for the valid options and syntax. Typically this is a list of options separated by semi-colons or new lines, e.g. \"set auto- boot=true;add net;set physical=bge0;set address=10.1.1.1; end\"",
            "type": "string"
          },
          "create_options": {
            "description": "Extra options to the zonecfg(1M) create command.",
            "type": "string"
          },
          "install_options": {
            "description": "Extra options to the zoneadm(1M) install command. To automate Solaris 11 zone creation, use this to specify the profile XML file, e.g. install_opti ons=\"-c sc_profile.xml\"",
            "type": "string"
          },
          "name": {
            "description": "Zone name.",
            "type": "string"
          },
          "path": {
            "description": "The path where the zone will be created. This is required when the zone is created, but not used otherwise.",
            "type": "string"
          },
          "root_password": {
            "description": "The password hash for the root account. If not specified, the zone's root account will not have a password.",
            "type": "string"
          },
          "sparse": {
            "description": "Whether to create a sparse (`true') or whole root (`false') zone.",
            "type": "string"
          },
          "state": {
            "description": "`present', configure and install the zone. `installed', synonym for `present'. `running', if the zone already exists, boot it, otherwise, configure and install the zone first, then boot it. `started', synonym for `running'. `stopped', shutdown a zone. `absent', destroy the zone. `configured', configure the ready so that it's to be attached. `attached', attach a zone, but do not boot it. `detached', shutdown and detach a zone",
            "type": "string"
          },
          "timeout": {
            "description": "Timeout, in seconds, for zone to boot.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "state"
        ]
      }
    },
    {
      "sqs_queue": {
        "type": "object",
        "description": "Creates or deletes AWS SQS queues.",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "default_visibility_timeout": {
            "description": "The default visibility timeout in seconds.",
            "type": "string"
          },
          "delivery_delay": {
            "description": "The delivery delay in seconds.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "maximum_message_size": {
            "description": "The maximum message size in bytes.",
            "type": "string"
          },
          "message_retention_period": {
            "description": "The message retention period in seconds.",
            "type": "string"
          },
          "name": {
            "description": "Name of the queue.",
            "type": "string"
          },
          "policy": {
            "description": "The json dict policy to attach to queue",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "receive_message_wait_time": {
            "description": "The receive message wait time in seconds.",
            "type": "string"
          },
          "redrive_policy": {
            "description": "json dict with the redrive_policy (see example)",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "state": {
            "description": "Create or delete the queue",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "sros_command": {
        "type": "object",
        "description": "Run commands on remote devices running Nokia SR OS",
        "properties": {
          "commands": {
            "description": "List of commands to send to the remote SR OS device over the configured provider. The resulting output from the command is returned. If the `wait_for' argument is provided, the module is not returned until the condition is satisfied or the number of retries has expired.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "interval": {
            "description": "Configures the interval in seconds to wait between retries of the command. If the command does not pass the specified conditions, the interval indicates how long to wait before trying the command again.",
            "type": "string"
          },
          "match": {
            "description": "The `match' argument is used in conjunction with the `wait_for' argument to specify the match policy.  Valid values are `all' or `any'.  If the value is set to `all' then all conditionals in the wait_for must be satisfied.  If the value is set to `any' then only one of the values must be satisfied.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.   The value of `password' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_PASSWORD will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. The port value will default to the well known SSH port of 22",
            "type": "string"
          },
          "provider": {
            "description": "Convenience argument that allows connection arguments to be passed as a dict object.  These include `host', `port', `username', `password', `ssh_keyfile', and `timeout'. All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "retries": {
            "description": "Specifies the number of retries a command should by tried before it is considered failed. The command is run on the target device every retry and evaluated against the `wait_for' conditions.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. The value of `ssh_keyfile' is the path to the key used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_SSH_KEYFILE will be used instead.",
            "type": "string"
          },
          "timeout": {
            "description": "Specifies idle timeout for the connection. Useful if the console freezes before continuing. For example when saving configurations.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_USERNAME will be used instead.",
            "type": "string"
          },
          "wait_for": {
            "description": "List of conditions to evaluate against the output of the command. The task will wait for each condition to be true before moving forward. If the conditional is not true within the configured number of retries, the task fails. See examples.",
            "type": "string"
          }
        },
        "required": [
          "commands",
          "host"
        ]
      }
    },
    {
      "sros_config": {
        "type": "object",
        "description": "Manage Nokia SR OS device configuration",
        "properties": {
          "after": {
            "description": "The ordered set of commands to append to the end of the command stack if a change needs to be made. Just like with `before' this allows the playbook designer to append a set of commands to be executed after the command set.",
            "type": "string"
          },
          "backup": {
            "description": "This argument will cause the module to create a full backup of the current `running-config' from the remote device before any changes are made. The backup file is written to the `backup' folder in the playbook root directory. If the directory does not exist, it is created.",
            "type": "string"
          },
          "before": {
            "description": "The ordered set of commands to push on to the command stack if a change needs to be made.  This allows the playbook designer the opportunity to perform configuration commands prior to pushing any changes without affecting how the set of commands are matched against the system.",
            "type": "string"
          },
          "config": {
            "description": "The `config' argument allows the playbook designer to supply the base configuration to be used to validate configuration changes necessary.  If this argument is provided, the module will not download the running-config from the remote node.",
            "type": "string"
          },
          "defaults": {
            "description": "This argument specifies whether or not to collect all defaults when getting the remote device running config. When enabled, the module will get the current config by issuing the command `show running-config all'.",
            "type": "string"
          },
          "force": {
            "description": "The force argument instructs the module to not consider the current devices running-config. When set to true, this will cause the module to push the contents of `src' into the device without first checking if already configured. Note this argument should be considered deprecated.  To achieve the equivalent, set the `match=none' which is idempotent.  This argument will be removed in a future release.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "lines": {
            "description": "The ordered set of commands that should be configured in the section.  The commands must be the exact same commands as found in the device running-config. Be sure to note the configuration command syntax as some commands are automatically modified by the device config parser.",
            "type": "string"
          },
          "match": {
            "description": "Instructs the module on the way to perform the matching of the set of commands against the current device config.  If match is set to `line', commands are matched line by line.  If match is set to `strict', command lines are matched with respect to position.  If match is set to `exact', command lines must be an equal match. Finally, if match is set to `none', the module will not attempt to compare the source configuration with the running configuration on the remote device.",
            "type": "string"
          },
          "parents": {
            "description": "The ordered set of parents that uniquely identify the section the commands should be checked against.  If the parents argument is omitted, the commands are checked against the set of top level or global commands.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.   The value of `password' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_PASSWORD will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. The port value will default to the well known SSH port of 22",
            "type": "string"
          },
          "provider": {
            "description": "Convenience argument that allows connection arguments to be passed as a dict object.  These include `host', `port', `username', `password', `ssh_keyfile', and `timeout'. All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "replace": {
            "description": "Instructs the module on the way to perform the configuration on the device.  If the replace argument is set to `line' then the modified lines are pushed to the device in configuration mode.  If the replace argument is set to `block' then the entire command block is pushed to the device in configuration mode if any line is not correct.",
            "type": "string"
          },
          "save": {
            "description": "The `save' argument instructs the module to save the running- config to the startup-config at the conclusion of the module running.  If check mode is specified, this argument is ignored.",
            "type": "string"
          },
          "src": {
            "description": "Specifies the source path to the file that contains the configuration or configuration template to load. The path to the source file can either be the full path on the Ansible control host or a relative path from the playbook or role root directory.  This argument is mutually exclusive with `lines'.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. The value of `ssh_keyfile' is the path to the key used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_SSH_KEYFILE will be used instead.",
            "type": "string"
          },
          "timeout": {
            "description": "Specifies idle timeout for the connection. Useful if the console freezes before continuing. For example when saving configurations.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_USERNAME will be used instead.",
            "type": "string"
          }
        },
        "required": "host"
      }
    },
    {
      "sros_rollback": {
        "type": "object",
        "description": "Configure Nokia SR OS rollback",
        "properties": {
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "local_max_checkpoints": {
            "description": "The `local_max_checkpoints' argument configures the maximum number of rollback files that can be saved on the devices local compact flash.  Valid values for this argument are in the range of 1 to 50",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.   The value of `password' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_PASSWORD will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device. The port value will default to the well known SSH port of 22",
            "type": "string"
          },
          "provider": {
            "description": "Convenience argument that allows connection arguments to be passed as a dict object.  These include `host', `port', `username', `password', `ssh_keyfile', and `timeout'. All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "remote_max_checkpoints": {
            "description": "The `remote_max_checkpoints' argument configures the maximum number of rollback files that can be transfered and saved to a remote location.  Valid values for this argument are in the range of 1 to 50",
            "type": "string"
          },
          "rescue_location": {
            "description": "The `rescue_location' specifies the location of the rescue file. This argument supports any valid local or remote URL as specified in SR OS",
            "type": "string"
          },
          "rollback_location": {
            "description": "The `rollback_location' specifies the location and filename of the rollback checkpoint files. This argument supports any valid local or remote URL as specified in SR OS",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. The value of `ssh_keyfile' is the path to the key used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_SSH_KEYFILE will be used instead.",
            "type": "string"
          },
          "state": {
            "description": "The `state' argument specifies the state of the configuration entries in the devices active configuration. When the state value is set to `true' the configuration is present in the devices active configuration. When the state value is set to `false' the configuration values are removed from the devices active configuration.",
            "type": "string"
          },
          "timeout": {
            "description": "Specifies idle timeout for the connection. Useful if the console freezes before continuing. For example when saving configurations.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable ANSIBLE_ NET_USERNAME will be used instead.",
            "type": "string"
          }
        },
        "required": "host"
      }
    },
    {
      "stackdriver": {
        "type": "object",
        "description": "Send code deploy and annotation events to stackdriver",
        "properties": {
          "annotated_by": {
            "description": "The person or robotwho the annotation should be attributed to.",
            "type": "string"
          },
          "deployed_by": {
            "description": "The person or robot responsible for deploying the code",
            "type": "string"
          },
          "deployed_to": {
            "description": "The environment code was deployed to. (ie: development, staging, production)",
            "type": "string"
          },
          "event": {
            "description": "The type of event to send, either annotation or deploy",
            "type": "string"
          },
          "event_epoch": {
            "description": "Unix timestamp of where the event should appear in the timeline, defaults to now. Be careful with this.",
            "type": "string"
          },
          "instance_id": {
            "description": "id of an EC2 instance that this event should be attached to, which will limit the contexts where this event is shown",
            "type": "string"
          },
          "key": {
            "description": "API key.",
            "type": "string"
          },
          "level": {
            "description": "one of INFO/WARN/ERROR, defaults to INFO if not supplied. May affect display.",
            "type": "string"
          },
          "msg": {
            "description": "The contents of the annotation message, in plain text. Limited to 256 characters. Required for annotation.",
            "type": "string"
          },
          "repository": {
            "description": "The repository (or project) deployed",
            "type": "string"
          },
          "revision_id": {
            "description": "The revision of the code that was deployed. Required for deploy events",
            "type": "string"
          }
        },
        "required": "key"
      }
    },
    {
      "stat": {
        "type": "object",
        "description": "retrieve file or file system status",
        "properties": {
          "checksum_algorithm": {
            "description": "Algorithm to determine checksum of file. Will throw an error if the host is unable to use specified algorithm.",
            "type": "string"
          },
          "follow": {
            "description": "Whether to follow symlinks",
            "type": "string"
          },
          "get_checksum": {
            "description": "Whether to return a checksum of the file (default sha1)",
            "type": "string"
          },
          "get_md5": {
            "description": "Whether to return the md5 sum of the file.  Will return None if we're unable to use md5 (Common for FIPS-140 compliant systems)",
            "type": "string"
          },
          "mime": {
            "description": "Use file magic and return data about the nature of the file. this uses the 'file' utility found on most Linux/Unix systems. This will add both `mime_type` and 'charset' fields to the return, if possible.",
            "type": "string"
          },
          "path": {
            "description": "The full path of the file/object to get the facts of",
            "type": "string"
          }
        },
        "required": "path"
      }
    },
    {
      "statusio_maintenance": {
        "type": "object",
        "description": "Create maintenance windows for your status.io dashboard",
        "properties": {
          "all_infrastructure_affected": {
            "description": "If it affects all components and containers",
            "type": "string"
          },
          "api_id": {
            "description": "Your unique API ID from status.io",
            "type": "string"
          },
          "api_key": {
            "description": "Your unique API Key from status.io",
            "type": "string"
          },
          "automation": {
            "description": "Automatically start and end the maintenance window",
            "type": "string"
          },
          "components": {
            "description": "The given name of your component (server name)",
            "type": "string"
          },
          "containers": {
            "description": "The given name of your container (data center)",
            "type": "string"
          },
          "desc": {
            "description": "Message describing the maintenance window",
            "type": "string"
          },
          "maintenance_id": {
            "description": "The maintenance id number when deleting a maintenance window",
            "type": "string"
          },
          "maintenance_notify_1_hr": {
            "description": "Notify subscribers 1 hour before maintenance start time",
            "type": "string"
          },
          "maintenance_notify_24_hr": {
            "description": "Notify subscribers 24 hours before maintenance start time",
            "type": "string"
          },
          "maintenance_notify_72_hr": {
            "description": "Notify subscribers 72 hours before maintenance start time",
            "type": "string"
          },
          "maintenance_notify_now": {
            "description": "Notify subscribers now",
            "type": "string"
          },
          "minutes": {
            "description": "The length of time in UTC that the maintenance will run (starting from playbook runtime)",
            "type": "string"
          },
          "start_date": {
            "description": "Date maintenance is expected to start (Month/Day/Year) (UTC) End Date is worked out from start_date + minutes",
            "type": "string"
          },
          "start_time": {
            "description": "Time maintenance is expected to start (Hour:Minutes) (UTC) End Time is worked out from start_time + minutes",
            "type": "string"
          },
          "state": {
            "description": "Desired state of the package.",
            "type": "string"
          },
          "statuspage": {
            "description": "Your unique StatusPage ID from status.io",
            "type": "string"
          },
          "title": {
            "description": "A descriptive title for the maintenance window",
            "type": "string"
          },
          "url": {
            "description": "Status.io API URL. A private apiary can be used instead.",
            "type": "string"
          }
        },
        "required": [
          "api_id",
          "api_key",
          "statuspage"
        ]
      }
    },
    {
      "sts_assume_role": {
        "type": "object",
        "description": "Assume a role using AWS Security Token Service and obtain temporary credentials",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "duration_seconds": {
            "description": "The duration, in seconds, of the role session. The value can range from 900 seconds (15 minutes) to 3600 seconds (1 hour). By default, the value is set to 3600 seconds.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "external_id": {
            "description": "A unique identifier that is used by third parties to assume a role in their customers' accounts.",
            "type": "string"
          },
          "mfa_serial_number": {
            "description": "he identification number of the MFA device that is associated with the user who is making the AssumeRole call.",
            "type": "string"
          },
          "mfa_token": {
            "description": "The value provided by the MFA device, if the trust policy of the role being assumed requires MFA.",
            "type": "string"
          },
          "policy": {
            "description": "Supplemental policy to use in addition to assumed role's policies.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "role_arn": {
            "description": "The Amazon Resource Name (ARN) of the role that the caller is assuming (http:// docs.aws.amazon.c om/IAM/latest/Use rGuide/Using_Iden tifiers.html#Iden tifiers_ARNs)",
            "type": "string"
          },
          "role_session_name": {
            "description": "Name of the role's session - will be used by CloudTrail",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        },
        "required": [
          "role_arn",
          "role_session_name"
        ]
      }
    },
    {
      "sts_session_token": {
        "type": "object",
        "description": "Obtain a session token from the AWS Security Token Service",
        "properties": {
          "aws_access_key": {
            "description": "AWS access key. If not set then the value of the AWS_ACCESS_KEY_ID , AWS_ACCESS_KEY or EC2_ACCESS_KEY environment variable is used.",
            "type": "string"
          },
          "aws_secret_key": {
            "description": "AWS secret key. If not set then the value of the AWS_SECRET_ACCESS _KEY, AWS_SECRET_KEY, or EC2_SECRET_KEY environment variable is used.",
            "type": "string"
          },
          "duration_seconds": {
            "description": "The duration, in seconds, of the session token. See http://docs.a ws.amazon.com/STS /latest/APIRefere nce/API_GetSessio nToken.html#API_G etSessionToken_Re questParameters for acceptable and default values.",
            "type": "string"
          },
          "ec2_url": {
            "description": "Url to use to connect to EC2 or your Eucalyptus cloud (by default the module will use EC2 endpoints). Ignored for modules where region is required.  Must be specified for all other modules if region is not used. If not set then the value of the EC2_URL environment variable, if any, is used.",
            "type": "string"
          },
          "mfa_serial_number": {
            "description": "The identification number of the MFA device that is associated with the user who is making the GetSessionToken call.",
            "type": "string"
          },
          "mfa_token": {
            "description": "The value provided by the MFA device, if the trust policy of the user requires MFA.",
            "type": "string"
          },
          "profile": {
            "description": "uses a boto profile. Only works with boto >= 2.24.0",
            "type": "string"
          },
          "region": {
            "description": "The AWS region to use. If not specified then the value of the AWS_REGION or EC2_REGION environment variable, if any, is used. See http ://docs.aws.amazo n.com/general/lat est/gr/rande.html #ec2_region",
            "type": "string"
          },
          "security_token": {
            "description": "AWS STS security token. If not set then the value of the AWS_ SECURITY_TOKEN or EC2_SECURITY_TOKE N environment variable is used.",
            "type": "string"
          },
          "validate_certs": {
            "description": "When set to \"no\", SSL certificates will not be validated for boto versions >= 2.6.0.",
            "type": "string"
          }
        }
      }
    },
    {
      "subversion": {
        "type": "object",
        "description": "Deploys a subversion repository.",
        "properties": {
          "checkout": {
            "description": "If no, do not check out the repository if it does not exist locally",
            "type": "string"
          },
          "dest": {
            "description": "Absolute path where the repository should be deployed.",
            "type": "string"
          },
          "executable": {
            "description": "Path to svn executable to use. If not supplied, the normal mechanism for resolving binary paths will be used.",
            "type": "string"
          },
          "export": {
            "description": "If `yes', do export instead of checkout/update.",
            "type": "string"
          },
          "force": {
            "description": "If `yes', modified files will be discarded. If `no', module will fail if it encounters modified files. Prior to 1.9 the default was `yes`.",
            "type": "string"
          },
          "password": {
            "description": "--password parameter passed to svn.",
            "type": "string"
          },
          "repo": {
            "description": "The subversion URL to the repository.",
            "type": "string"
          },
          "revision": {
            "description": "Specific revision to checkout.",
            "type": "string"
          },
          "switch": {
            "description": "If `no', do not call svn switch before update.",
            "type": "string"
          },
          "update": {
            "description": "If no, do not retrieve new revisions from the origin repository",
            "type": "string"
          },
          "username": {
            "description": "--username parameter passed to svn.",
            "type": "string"
          }
        },
        "required": [
          "dest",
          "repo"
        ]
      }
    },
    {
      "supervisorctl": {
        "type": "object",
        "description": "Manage the state of a program or group of programs running via supervisord",
        "properties": {
          "config": {
            "description": "The supervisor configuration file path",
            "type": "string"
          },
          "name": {
            "description": "The name of the supervisord program or group to manage. The name will be taken as group name when it ends with a colon `:' Group support is only available in Ansible version 1.6 or later.",
            "type": "string"
          },
          "password": {
            "description": "password to use for authentication",
            "type": "string"
          },
          "server_url": {
            "description": "URL on which supervisord server is listening",
            "type": "string"
          },
          "state": {
            "description": "The desired state of program/group.",
            "type": "string"
          },
          "supervisorctl_path": {
            "description": "path to supervisorctl executable",
            "type": "string"
          },
          "username": {
            "description": "username to use for authentication",
            "type": "string"
          }
        },
        "required": [
          "name",
          "state"
        ]
      }
    },
    {
      "svc": {
        "type": "object",
        "description": "Manage daemontools services.",
        "properties": {
          "downed": {
            "description": "Should a 'down' file exist or not, if it exists it disables auto startup. defaults to no. Downed does not imply stopped.",
            "type": "string"
          },
          "enabled": {
            "description": "Wheater the service is enabled or not, if disabled it also implies stopped. Make note that a service can be enabled and downed (no auto restart).",
            "type": "string"
          },
          "name": {
            "description": "Name of the service to manage.",
            "type": "string"
          },
          "service_dir": {
            "description": "directory svscan watches for services",
            "type": "string"
          },
          "service_src": {
            "description": "directory where services are defined, the source of symlinks to service_dir.",
            "type": "string"
          },
          "state": {
            "description": "`Started'/`stopped' are idempotent actions that will not run commands unless necessary. `restarted' will always bounce the svc (svc -t) and `killed' will always bounce the svc (svc -k). `reloaded' will send a sigusr1 (svc -1). `once' will run a normally downed svc once (svc -o), not really an idempotent operation.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "svr4pkg": {
        "type": "object",
        "description": "Manage Solaris SVR4 packages",
        "properties": {
          "category": {
            "description": "Install/Remove category instead of a single package.",
            "type": "string"
          },
          "name": {
            "description": "Package name, e.g. `SUNWcsr'",
            "type": "string"
          },
          "proxy": {
            "description": "HTTP[s] proxy to be used if `src' is a URL.",
            "type": "string"
          },
          "response_file": {
            "description": "Specifies the location of a response file to be used if package expects input on install. (added in Ansible 1.4)",
            "type": "string"
          },
          "src": {
            "description": "Specifies the location to install the package from. Required when `state=present'. Can be any path acceptable to the `pkgadd' command's `-d' option. e.g.: `somefile.pkg', `/dir/with/pkgs', `http:/server/myp kgs.pkg'. If using a file or directory, they must already be accessible by the host. See the [copy] module for a way to get them there.",
            "type": "string"
          },
          "state": {
            "description": "Whether to install (`present'), or remove (`absent') a package. If the package is to be installed, then `src' is required. The SVR4 package system doesn't provide an upgrade operation. You need to uninstall the old, then install the new package.",
            "type": "string"
          },
          "zone": {
            "description": "Whether to install the package only in the current zone, or install it into all zones. The installation into all zones works only if you are working with the global zone.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "state"
        ]
      }
    },
    {
      "swdepot": {
        "type": "object",
        "description": "Manage packages with swdepot package manager (HP-UX)",
        "properties": {
          "depot": {
            "description": "The source repository from which install or upgrade a package.",
            "type": "string"
          },
          "name": {
            "description": "package name.",
            "type": "string"
          },
          "state": {
            "description": "whether to install (`present', `latest'), or remove (`absent') a package.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "state"
        ]
      }
    },
    {
      "synchronize": {
        "type": "object",
        "description": "Uses rsync to make synchronizing file paths in your playbooks quick and easy.",
        "properties": {
          "archive": {
            "description": "Mirrors the rsync archive flag, enables recursive, links, perms, times, owner, group flags and -D.",
            "type": "string"
          },
          "checksum": {
            "description": "Skip based on checksum, rather than mod-time & size; Note that that \"archive\" option is still enabled by default - the \"checksum\" option will not disable it.",
            "type": "string"
          },
          "compress": {
            "description": "Compress file data during the transfer. In most cases, leave this enabled unless it causes problems.",
            "type": "string"
          },
          "copy_links": {
            "description": "Copy symlinks as the item that they point to (the referent) is copied, rather than the symlink.",
            "type": "string"
          },
          "delete": {
            "description": "Delete files in `dest' that don't exist (after transfer, not before) in the `src' path. This option requires `recursive=yes'.",
            "type": "string"
          },
          "dest": {
            "description": "Path on the destination host that will be synchronized from the source; The path can be absolute or relative.",
            "type": "string"
          },
          "dest_port": {
            "description": "Port number for ssh on the destination host. Prior to ansible 2.0, the ansible_ssh_port inventory var took precedence over this value.",
            "type": "string"
          },
          "dirs": {
            "description": "Transfer directories without recursing",
            "type": "string"
          },
          "existing_only": {
            "description": "Skip creating new files on receiver.",
            "type": "string"
          },
          "group": {
            "description": "Preserve group",
            "type": "string"
          },
          "links": {
            "description": "Copy symlinks as symlinks.",
            "type": "string"
          },
          "mode": {
            "description": "Specify the direction of the synchronization. In push mode the localhost or delegate is the source; In pull mode the remote host in context is the source.",
            "type": "string"
          },
          "owner": {
            "description": "Preserve owner (super user only)",
            "type": "string"
          },
          "partial": {
            "description": "Tells rsync to keep the partial file which should make a subsequent transfer of the rest of the file much faster.",
            "type": "string"
          },
          "perms": {
            "description": "Preserve permissions.",
            "type": "string"
          },
          "recursive": {
            "description": "Recurse into directories.",
            "type": "string"
          },
          "rsync_opts": {
            "description": "Specify additional rsync options by passing in an array.",
            "type": "string"
          },
          "rsync_path": {
            "description": "Specify the rsync command to run on the remote host. See `--rsync-path' on the rsync man page.",
            "type": "string"
          },
          "rsync_timeout": {
            "description": "Specify a --timeout for the rsync command in seconds.",
            "type": "string"
          },
          "set_remote_user": {
            "description": "put user@ for the remote paths. If you have a custom ssh config to define the remote user for a host that does not match the inventory user, you should set this parameter to \"no\".",
            "type": "string"
          },
          "src": {
            "description": "Path on the source host that will be synchronized to the destination; The path can be absolute or relative.",
            "type": "string"
          },
          "times": {
            "description": "Preserve modification times",
            "type": "string"
          },
          "use_ssh_args": {
            "description": "Use the ssh_args specified in ansible.cfg",
            "type": "string"
          },
          "verify_host": {
            "description": "Verify destination host key.",
            "type": "string"
          }
        },
        "required": [
          "dest",
          "src"
        ]
      }
    },
    {
      "sysctl": {
        "type": "object",
        "description": "Manage entries in sysctl.conf.",
        "properties": {
          "ignoreerrors": {
            "description": "Use this option to ignore errors about unknown keys.",
            "type": "string"
          },
          "name": {
            "description": "The dot-separated path (aka `key') specifying the sysctl variable.",
            "type": "string"
          },
          "reload": {
            "description": "If `yes', performs a `/sbin/sysctl -p' if the `sysctl_file' is updated. If `no', does not reload `sysctl' even if the `sysctl_file' is updated.",
            "type": "string"
          },
          "state": {
            "description": "Whether the entry should be present or absent in the sysctl file.",
            "type": "string"
          },
          "sysctl_file": {
            "description": "Specifies the absolute path to `sysctl.conf', if not `/etc/sysctl. conf'.",
            "type": "string"
          },
          "sysctl_set": {
            "description": "Verify token value with the sysctl command and set with -w if necessary",
            "type": "string"
          },
          "value": {
            "description": "Desired value of the sysctl key.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "systemd": {
        "type": "object",
        "description": "Manage services.",
        "properties": {
          "daemon_reload": {
            "description": "run daemon-reload before doing any other operations, to make sure systemd has read any changes.",
            "type": "string"
          },
          "enabled": {
            "description": "Whether the service should start on boot. *At least one of state and enabled are required.*",
            "type": "string"
          },
          "masked": {
            "description": "Whether the unit should be masked or not, a masked unit is impossible to start.",
            "type": "string"
          },
          "name": {
            "description": "Name of the service.",
            "type": "string"
          },
          "state": {
            "description": "`started'/`stopped' are idempotent actions that will not run commands unless necessary. `restarted' will always bounce the service. `reloaded' will always reload.",
            "type": "string"
          },
          "user": {
            "description": "run systemctl talking to the service manager of the calling user, rather than the service manager of the system.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "taiga_issue": {
        "type": "object",
        "description": "Creates/deletes an issue in a Taiga Project Management Platform",
        "properties": {
          "attachment": {
            "description": "Path to a file to be attached to the issue.",
            "type": "string"
          },
          "attachment_description": {
            "description": "A string describing the file to be attached to the issue.",
            "type": "string"
          },
          "description": {
            "description": "The issue description.",
            "type": "string"
          },
          "issue_type": {
            "description": "The issue type. Must exist previously.",
            "type": "string"
          },
          "priority": {
            "description": "The issue priority. Must exist previously.",
            "type": "string"
          },
          "project": {
            "description": "Name of the project containing the issue. Must exist previously.",
            "type": "string"
          },
          "severity": {
            "description": "The issue severity. Must exist previously.",
            "type": "string"
          },
          "state": {
            "description": "Whether the issue should be present or not.",
            "type": "string"
          },
          "status": {
            "description": "The issue status. Must exist previously.",
            "type": "string"
          },
          "subject": {
            "description": "The issue subject.",
            "type": "string"
          },
          "tags": {
            "description": "A lists of tags to be assigned to the issue.",
            "type": "string"
          },
          "taiga_host": {
            "description": "The hostname of the Taiga instance.",
            "type": "string"
          }
        },
        "required": [
          "issue_type",
          "project",
          "subject"
        ]
      }
    },
    {
      "telegram": {
        "type": "object",
        "description": "module for sending notifications via telegram",
        "properties": {
          "chat_id": {
            "description": "Telegram group or user chat_id",
            "type": "string"
          },
          "msg": {
            "description": "What message you wish to send.",
            "type": "string"
          },
          "token": {
            "description": "Token identifying your telegram bot.",
            "type": "string"
          }
        },
        "required": [
          "chat_id",
          "msg",
          "token"
        ]
      }
    },
    {
      "template": {
        "type": "object",
        "description": "Templates a file out to a remote server.",
        "properties": {
          "backup": {
            "description": "Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.",
            "type": "string"
          },
          "dest": {
            "description": "Location to render the template to on the remote machine.",
            "type": "string"
          },
          "force": {
            "description": "the default is `yes', which will replace the remote file when contents are different than the source.  If `no', the file will only be transferred if the destination does not exist.",
            "type": "string"
          },
          "group": {
            "description": "name of the group that should own the file/directory, as would be fed to `chown'",
            "type": "string"
          },
          "mode": {
            "description": "mode the file or directory should be. For those used to `/usr/bin/chmod' remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, `u+rwx' or `u=rw,g=r,o=r').",
            "type": "string"
          },
          "owner": {
            "description": "name of the user that should own the file/directory, as would be fed to `chown'",
            "type": "string"
          },
          "selevel": {
            "description": "level part of the SELinux file context. This is the MLS/MCS attribute, sometimes known as the `range'. `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "serole": {
            "description": "role part of SELinux file context, `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "setype": {
            "description": "type part of SELinux file context, `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "seuser": {
            "description": "user part of SELinux file context. Will default to system policy, if applicable. If set to `_default', it will use the `user' portion of the policy if available",
            "type": "string"
          },
          "src": {
            "description": "Path of a Jinja2 formatted template on the Ansible controller. This can be a relative or absolute path.",
            "type": "string"
          },
          "unsafe_writes": {
            "description": "Normally this module uses atomic operations to prevent data corruption or inconsistent reads from the target files, sometimes systems are configured or just broken in ways that prevent this. One example are docker mounted files, they cannot be updated atomically and can only be done in an unsafe manner. This boolean option allows ansible to fall back to unsafe methods of updating files for those cases in which you do not have any other choice. Be aware that this is subject to race conditions and can lead to data corruption.",
            "type": "string"
          },
          "validate": {
            "description": "The validation command to run before copying into place. The path to the file to validate is passed in via '%s' which must be present as in the example below. The command is passed securely so shell features like expansion and pipes won't work.",
            "type": "string"
          }
        },
        "required": [
          "dest",
          "src"
        ]
      }
    },
    {
      "timezone": {
        "type": "object",
        "description": "Configure timezone setting",
        "properties": {
          "hwclock": {
            "description": "Whether the hardware clock is in UTC or in local timezone. Default is to keep current setting. Note that this option is recommended not to change and may fail to configure, especially on virtual environments such as AWS.",
            "type": "string"
          },
          "name": {
            "description": "Name of the timezone for the system clock. Default is to keep current setting.",
            "type": "string"
          }
        }
      }
    },
    {
      "twilio": {
        "type": "object",
        "description": "Sends a text message to a mobile phone through Twilio.",
        "properties": {
          "account_sid": {
            "description": "u s e r ' s   T w i l i o   a c c o u n t   t o k e n   f o u n d o n   t h e   a c c o u n t   p a g e",
            "type": "string"
          },
          "auth_token": {
            "description": "u s e r ' s   T w i l i o   a u t h e n t i c a t i o n   t o k e n",
            "type": "string"
          },
          "from_number": {
            "description": "t h e   T w i l i o   n u m b e r   t o   s e n d   t h e   t e x t   m e s s a g e f r o m ,   f o r m a t   + 1 5 5 5 1 1 1 2 2 2 2",
            "type": "string"
          },
          "media_url": {
            "description": "a   U R L   w i t h   a   p i c t u r e ,   v i d e o   o r   s o u n d   c l i p t o   s e n d   w i t h   a n   M M S   ( m u l t i m e d i a   m e s s a g e )   i n s t e a d   o f   a p l a i n   S M S",
            "type": "string"
          },
          "msg": {
            "description": "t h e   b o d y   o f   t h e   t e x t   m e s s a g e",
            "type": "string"
          },
          "to_number": {
            "description": "o n e   o r   m o r e   p h o n e   n u m b e r s   t o   s e n d t h e   t e x t m e s s a g e   t o ,   f o r m a t + 1 5 5 5 1 1 1 2 2 2 2",
            "type": "string"
          }
        },
        "required": [
          "account_sid",
          "auth_token",
          "from_number",
          "msg",
          "to_number"
        ]
      }
    },
    {
      "typetalk": {
        "type": "object",
        "description": "Send a message to typetalk",
        "properties": {
          "client_id": {
            "description": "OAuth2 client ID",
            "type": "string"
          },
          "client_secret": {
            "description": "OAuth2 client secret",
            "type": "string"
          },
          "msg": {
            "description": "message body",
            "type": "string"
          },
          "topic": {
            "description": "topic id to post message",
            "type": "string"
          }
        },
        "required": [
          "client_id",
          "client_secret",
          "msg",
          "topic"
        ]
      }
    },
    {
      "udm_dns_record": {
        "type": "object",
        "description": "Manage dns entries on a univention corporate server",
        "properties": {
          "data": {
            "description": "Additional data for this record, e.g. ['a': '192.0.2.1']. Required if `state=present'.",
            "type": "string"
          },
          "name": {
            "description": "Name of the record, this is also the DNS record. E.g. www for www.example.com.",
            "type": "string"
          },
          "state": {
            "description": "Whether the dns record is present or not.",
            "type": "string"
          },
          "type": {
            "description": "Define the record type. `host_record' is a A or AAAA record, `alias' is a CNAME, `ptr_record' is a PTR record, `srv_record' is a SRV record and `txt_record' is a TXT record.",
            "type": "string"
          },
          "zone": {
            "description": "Corresponding DNS zone for this record, e.g. example.com.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "type",
          "zone"
        ]
      }
    },
    {
      "udm_dns_zone": {
        "type": "object",
        "description": "Manage dns zones on a univention corporate server",
        "properties": {
          "contact": {
            "description": "Contact person in the SOA record.",
            "type": "string"
          },
          "expire": {
            "description": "Specifies the upper limit on the time interval that can elapse before the zone is no longer authoritative.",
            "type": "string"
          },
          "interfaces": {
            "description": "List of interface IP addresses, on which the server should response this zone. Required if `state=present'.",
            "type": "string"
          },
          "mx": {
            "description": "List of MX servers. (Must declared as A or AAAA records).",
            "type": "string"
          },
          "nameserver": {
            "description": "List of appropriate name servers. Required if `state=present'.",
            "type": "string"
          },
          "refresh": {
            "description": "Interval before the zone should be refreshed.",
            "type": "string"
          },
          "retry": {
            "description": "Interval that should elapse before a failed refresh should be retried.",
            "type": "string"
          },
          "state": {
            "description": "Whether the dns zone is present or not.",
            "type": "string"
          },
          "ttl": {
            "description": "Minimum TTL field that should be exported with any RR from this zone.",
            "type": "string"
          },
          "type": {
            "description": "Define if the zone is a forward or reverse DNS zone.",
            "type": "string"
          },
          "zone": {
            "description": "DNS zone name, e.g. `example.com'.",
            "type": "string"
          }
        },
        "required": [
          "type",
          "zone"
        ]
      }
    },
    {
      "udm_group": {
        "type": "object",
        "description": "Manage of the posix group",
        "properties": {
          "description": {
            "description": "Group description.",
            "type": "string"
          },
          "name": {
            "description": "Name of the posix group.",
            "type": "string"
          },
          "ou": {
            "description": "LDAP OU, e.g. school for LDAP OU `ou=school,dc=exa mple,dc=com'.",
            "type": "string"
          },
          "position": {
            "description": "define the whole ldap position of the group, e.g. `cn=g123m-1A ,cn=classes,cn=sc hueler,cn=groups, ou=schule,dc=exam ple,dc=com'.",
            "type": "string"
          },
          "state": {
            "description": "Whether the group is present or not.",
            "type": "string"
          },
          "subpath": {
            "description": "Subpath inside the OU, e.g. `cn=classes,cn=st udents,cn=groups' .",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "udm_share": {
        "type": "object",
        "description": "Manage samba shares on a univention corporate server",
        "properties": {
          "directorymode": {
            "description": "Permissions for the share's root directory.",
            "type": "string"
          },
          "group": {
            "description": "Directory owner group of the share's root directory.",
            "type": "string"
          },
          "host": {
            "description": "Host FQDN (server which provides the share), e.g. `{{ ansible_fqdn }}'. Required if `state=present'.",
            "type": "string"
          },
          "name": {
            "description": "Name",
            "type": "string"
          },
          "nfs_custom_settings": {
            "description": "Option name in exports file.",
            "type": "string"
          },
          "nfs_hosts": {
            "description": "Only allow access for this host, IP address or network.",
            "type": "string"
          },
          "ou": {
            "description": "Organisational unit, inside the LDAP Base DN.",
            "type": "string"
          },
          "owner": {
            "description": "Directory owner of the share's root directory.",
            "type": "string"
          },
          "path": {
            "description": "Directory on the providing server, e.g. `/home'. Required if `state=present'.",
            "type": "string"
          },
          "root_squash": {
            "description": "Modify user ID for root user (root squashing).",
            "type": "string"
          },
          "samba_block_size": {
            "description": "Blocking size.",
            "type": "string"
          },
          "samba_blocking_locks": {
            "description": "Blocking locks.",
            "type": "string"
          },
          "samba_browseable": {
            "description": "Show in Windows network environment.",
            "type": "string"
          },
          "samba_create_mode": {
            "description": "File mode.",
            "type": "string"
          },
          "samba_csc_policy": {
            "description": "Client-side caching policy.",
            "type": "string"
          },
          "samba_custom_settings": {
            "description": "Option name in smb.conf and its value.",
            "type": "string"
          },
          "samba_directory_mode": {
            "description": "Directory mode.",
            "type": "string"
          },
          "samba_directory_security_mode": {
            "description": "Directory security mode.",
            "type": "string"
          },
          "samba_dos_filemode": {
            "description": "Users with write access may modify permissions.",
            "type": "string"
          },
          "samba_fake_oplocks": {
            "description": "Fake oplocks.",
            "type": "string"
          },
          "samba_force_create_mode": {
            "description": "Force file mode.",
            "type": "string"
          },
          "samba_force_directory_mode": {
            "description": "Force directory mode.",
            "type": "string"
          },
          "samba_force_directory_security_mode": {
            "description": "Force directory security mode.",
            "type": "string"
          },
          "samba_force_group": {
            "description": "Force group.",
            "type": "string"
          },
          "samba_force_security_mode": {
            "description": "Force security mode.",
            "type": "string"
          },
          "samba_force_user": {
            "description": "Force user.",
            "type": "string"
          },
          "samba_hide_files": {
            "description": "Hide files.",
            "type": "string"
          },
          "samba_hide_unreadable": {
            "description": "Hide unreadable files/directories.",
            "type": "string"
          },
          "samba_hosts_allow": {
            "description": "Allowed host/network.",
            "type": "string"
          },
          "samba_hosts_deny": {
            "description": "Denied host/network.",
            "type": "string"
          },
          "samba_inherit_acls": {
            "description": "Inherit ACLs.",
            "type": "string"
          },
          "samba_inherit_owner": {
            "description": "Create files/directories with the owner of the parent directory.",
            "type": "string"
          },
          "samba_inherit_permissions": {
            "description": "Create files/directories with permissions of the parent directory.",
            "type": "string"
          },
          "samba_invalid_users": {
            "description": "Invalid users or groups.",
            "type": "string"
          },
          "samba_level_2_oplocks": {
            "description": "Level 2 oplocks.",
            "type": "string"
          },
          "samba_locking": {
            "description": "Locking.",
            "type": "string"
          },
          "samba_msdfs_root": {
            "description": "MSDFS root.",
            "type": "string"
          },
          "samba_name": {
            "description": "Windows name. Required if `state=present'.",
            "type": "string"
          },
          "samba_nt_acl_support": {
            "description": "NT ACL support.",
            "type": "string"
          },
          "samba_oplocks": {
            "description": "Oplocks.",
            "type": "string"
          },
          "samba_postexec": {
            "description": "Postexec script.",
            "type": "string"
          },
          "samba_preexec": {
            "description": "Preexec script.",
            "type": "string"
          },
          "samba_public": {
            "description": "Allow anonymous read-only access with a guest user.",
            "type": "string"
          },
          "samba_security_mode": {
            "description": "Security mode.",
            "type": "string"
          },
          "samba_strict_locking": {
            "description": "Strict locking.",
            "type": "string"
          },
          "samba_valid_users": {
            "description": "Valid users or groups.",
            "type": "string"
          },
          "samba_vfs_objects": {
            "description": "VFS objects.",
            "type": "string"
          },
          "samba_write_list": {
            "description": "Restrict write access to these users/groups.",
            "type": "string"
          },
          "samba_writeable": {
            "description": "Samba write access.",
            "type": "string"
          },
          "state": {
            "description": "Whether the share is present or not.",
            "type": "string"
          },
          "subtree_checking": {
            "description": "Subtree checking.",
            "type": "string"
          },
          "sync": {
            "description": "NFS synchronisation.",
            "type": "string"
          },
          "writeable": {
            "description": "NFS write access.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "ou"
        ]
      }
    },
    {
      "udm_user": {
        "type": "object",
        "description": "Manage posix users on a univention corporate server",
        "properties": {
          "birthday": {
            "description": "Birthday",
            "type": "string"
          },
          "city": {
            "description": "City of users business address.",
            "type": "string"
          },
          "country": {
            "description": "Country of users business address.",
            "type": "string"
          },
          "department_number": {
            "description": "Department number of users business address.",
            "type": "string"
          },
          "description": {
            "description": "Description (not gecos)",
            "type": "string"
          },
          "display_name": {
            "description": "Display name (not gecos)",
            "type": "string"
          },
          "email": {
            "description": "A list of e-mail addresses.",
            "type": "string"
          },
          "employee_number": {
            "description": "Employee number",
            "type": "string"
          },
          "employee_type": {
            "description": "Employee type",
            "type": "string"
          },
          "firstname": {
            "description": "First name. Required if `state=present'.",
            "type": "string"
          },
          "gecos": {
            "description": "GECOS",
            "type": "string"
          },
          "groups": {
            "description": "POSIX groups, the LDAP DNs of the groups will be found with the LDAP filter for each group as $GROUP: `(&(objec tClass=posixGroup '(cn=$GROUP))).",
            "type": "string"
          },
          "home_share": {
            "description": "Home NFS share. Must be a LDAP DN, e.g. `cn=home,cn=share s,ou=school,dc=ex ample,dc=com'.",
            "type": "string"
          },
          "home_share_path": {
            "description": "Path to home NFS share, inside the homeShare.",
            "type": "string"
          },
          "home_telephone_number": {
            "description": "List of private telephone numbers.",
            "type": "string"
          },
          "homedrive": {
            "description": "Windows home drive, e.g. `\"H:\"'.",
            "type": "string"
          },
          "lastname": {
            "description": "Last name. Required if `state=present'.",
            "type": "string"
          },
          "mail_alternative_address": {
            "description": "List of alternative e-mail addresses.",
            "type": "string"
          },
          "mail_home_server": {
            "description": "FQDN of mail server",
            "type": "string"
          },
          "mail_primary_address": {
            "description": "Primary e-mail address",
            "type": "string"
          },
          "mobile_telephone_number": {
            "description": "Mobile phone number",
            "type": "string"
          },
          "organisation": {
            "description": "Organisation",
            "type": "string"
          },
          "ou": {
            "description": "Organizational Unit inside the LDAP Base DN, e.g. `school' for LDAP OU `ou=schoo l,dc=example,dc=c om'.",
            "type": "string"
          },
          "override_pw_history": {
            "description": "Override password history",
            "type": "string"
          },
          "override_pw_length": {
            "description": "Override password check",
            "type": "string"
          },
          "pager_telephonenumber": {
            "description": "List of pager telephone numbers.",
            "type": "string"
          },
          "password": {
            "description": "Password. Required if `state=present'.",
            "type": "string"
          },
          "phone": {
            "description": "List of telephone numbers.",
            "type": "string"
          },
          "position": {
            "description": "Define the whole position of users object inside the LDAP tree, e.g. `cn=employee ,cn=users,ou=scho ol,dc=example,dc= com'.",
            "type": "string"
          },
          "postcode": {
            "description": "Postal code of users business address.",
            "type": "string"
          },
          "primary_group": {
            "description": "Primary group. This must be the group LDAP DN.",
            "type": "string"
          },
          "profilepath": {
            "description": "Windows profile directory",
            "type": "string"
          },
          "pwd_change_next_login": {
            "description": "Change password on next login.",
            "type": "string"
          },
          "room_number": {
            "description": "Room number of users business address.",
            "type": "string"
          },
          "samba_privileges": {
            "description": "Samba privilege, like allow printer administration, do domain join.",
            "type": "string"
          },
          "samba_user_workstations": {
            "description": "Allow the authentication only on this Microsoft Windows host.",
            "type": "string"
          },
          "sambahome": {
            "description": "Windows home path, e.g. `'\\\\$FQDN\\$USERNAME''.",
            "type": "string"
          },
          "scriptpath": {
            "description": "Windows logon script.",
            "type": "string"
          },
          "secretary": {
            "description": "A list of superiors as LDAP DNs.",
            "type": "string"
          },
          "serviceprovider": {
            "description": "Enable user for the following service providers.",
            "type": "string"
          },
          "shell": {
            "description": "Login shell",
            "type": "string"
          },
          "state": {
            "description": "Whether the user is present or not.",
            "type": "string"
          },
          "street": {
            "description": "Street of users business address.",
            "type": "string"
          },
          "subpath": {
            "description": "LDAP subpath inside the organizational unit, e.g. `cn=teachers ,cn=users' for LDAP container `c n=teachers,cn=use rs,dc=example,dc= com'.",
            "type": "string"
          },
          "title": {
            "description": "Title, e.g. `Prof.'.",
            "type": "string"
          },
          "unixhome": {
            "description": "Unix home directory",
            "type": "string"
          },
          "userexpiry": {
            "description": "Account expiry date, e.g. `1999-12-31'.",
            "type": "string"
          },
          "username": {
            "description": "User name",
            "type": "string"
          }
        },
        "required": "username"
      }
    },
    {
      "ufw": {
        "type": "object",
        "description": "Manage firewall with UFW",
        "properties": {
          "delete": {
            "description": "Delete rule.",
            "type": "string"
          },
          "direction": {
            "description": "Select direction for a rule or default policy command.",
            "type": "string"
          },
          "from_ip": {
            "description": "Source IP address.",
            "type": "string"
          },
          "from_port": {
            "description": "Source port.",
            "type": "string"
          },
          "insert": {
            "description": "Insert the corresponding rule as rule number NUM",
            "type": "string"
          },
          "interface": {
            "description": "Specify interface for rule.",
            "type": "string"
          },
          "log": {
            "description": "Log new connections matched to this rule",
            "type": "string"
          },
          "logging": {
            "description": "Toggles logging. Logged packets use the LOG_KERN syslog facility.",
            "type": "string"
          },
          "name": {
            "description": "Use profile located in `/etc/ufw/applications.d'",
            "type": "string"
          },
          "policy": {
            "description": "Change the default policy for incoming or outgoing traffic.",
            "type": "string"
          },
          "proto": {
            "description": "TCP/IP protocol.",
            "type": "string"
          },
          "route": {
            "description": "Apply the rule to routed/forwarded packets.",
            "type": "string"
          },
          "rule": {
            "description": "Add firewall rule",
            "type": "string"
          },
          "state": {
            "description": "`enabled' reloads firewall and enables firewall on boot. `disabled' unloads firewall and disables firewall on boot. `reloaded' reloads firewall. `reset' disables and resets firewall to installation defaults.",
            "type": "string"
          },
          "to_ip": {
            "description": "Destination IP address.",
            "type": "string"
          },
          "to_port": {
            "description": "Destination port.",
            "type": "string"
          }
        }
      }
    },
    {
      "unarchive": {
        "type": "object",
        "description": "Unpacks an archive after (optionally) copying it from the local machine.",
        "properties": {
          "copy": {
            "description": "If true, the file is copied from local 'master' to the target machine, otherwise, the plugin will look for src archive at the target machine. This option has been deprecated in favor of `remote_src' This option is mutually exclusive with `remote_src'.",
            "type": "string"
          },
          "creates": {
            "description": "a filename, when it already exists, this step will *not* be run.",
            "type": "string"
          },
          "dest": {
            "description": "Remote absolute path where the archive should be unpacked",
            "type": "string"
          },
          "exclude": {
            "description": "List the directory and file entries that you would like to exclude from the unarchive action.",
            "type": "string"
          },
          "extra_opts": {
            "description": "Specify additional options by passing in an array.",
            "type": "string"
          },
          "group": {
            "description": "name of the group that should own the file/directory, as would be fed to `chown'",
            "type": "string"
          },
          "keep_newer": {
            "description": "Do not replace existing files that are newer than files from the archive.",
            "type": "string"
          },
          "list_files": {
            "description": "If set to True, return the list of files that are contained in the tarball.",
            "type": "string"
          },
          "mode": {
            "description": "mode the file or directory should be. For those used to `/usr/bin/chmod' remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, `u+rwx' or `u=rw,g=r,o=r').",
            "type": "string"
          },
          "owner": {
            "description": "name of the user that should own the file/directory, as would be fed to `chown'",
            "type": "string"
          },
          "remote_src": {
            "description": "Set to `yes' to indicate the archived file is already on the remote system and not local to the Ansible controller. This option is mutually exclusive with `copy'.",
            "type": "string"
          },
          "selevel": {
            "description": "level part of the SELinux file context. This is the MLS/MCS attribute, sometimes known as the `range'. `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "serole": {
            "description": "role part of SELinux file context, `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "setype": {
            "description": "type part of SELinux file context, `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "seuser": {
            "description": "user part of SELinux file context. Will default to system policy, if applicable. If set to `_default', it will use the `user' portion of the policy if available",
            "type": "string"
          },
          "src": {
            "description": "If remote_src=no (default), local path to archive file to copy to the target server; can be absolute or relative. If remote_src=yes, path on the target server to existing archive file to unpack. If remote_src=yes and src contains ://, the remote machine will download the file from the url first. (version_added 2.0)",
            "type": "string"
          },
          "unsafe_writes": {
            "description": "Normally this module uses atomic operations to prevent data corruption or inconsistent reads from the target files, sometimes systems are configured or just broken in ways that prevent this. One example are docker mounted files, they cannot be updated atomically and can only be done in an unsafe manner. This boolean option allows ansible to fall back to unsafe methods of updating files for those cases in which you do not have any other choice. Be aware that this is subject to race conditions and can lead to data corruption.",
            "type": "string"
          },
          "validate_certs": {
            "description": "This only applies if using a https url as the source of the file. This should only set to `no' used on personally controlled sites using self-signed cer Prior to 2.2 the code worked as if this was set to `yes'.",
            "type": "string"
          }
        },
        "required": [
          "dest",
          "src"
        ]
      }
    },
    {
      "uptimerobot": {
        "type": "object",
        "description": "Pause and start Uptime Robot monitoring",
        "properties": {
          "apikey": {
            "description": "Uptime Robot API key.",
            "type": "string"
          },
          "monitorid": {
            "description": "ID of the monitor to check.",
            "type": "string"
          },
          "state": {
            "description": "Define whether or not the monitor should be running or paused.",
            "type": "string"
          }
        },
        "required": [
          "apikey",
          "monitorid",
          "state"
        ]
      }
    },
    {
      "uri": {
        "type": "object",
        "description": "Interacts with webservices",
        "properties": {
          "HEADER_": {
            "description": "Any parameter starting with \"HEADER_\" is a sent with your request as a header. For example, HEADER_Content-Ty pe=\"application/j son\" would send the header \"Content-Type\" along with your request with a value of \"applica tion/json\". This option is deprecated as of `2.1' and may be removed in a future release. Use `headers' instead.",
            "type": "string"
          },
          "body": {
            "description": "The body of the http request/response to the web service. If `body_format' is set to 'json' it will take an already formatted JSON string or convert a data structure into JSON.",
            "type": "string"
          },
          "body_format": {
            "description": "The serialization format of the body. When set to json, encodes the body argument, if needed, and automatically sets the Content- Type header accordingly.",
            "type": "string"
          },
          "creates": {
            "description": "a filename, when it already exists, this step will not be run.",
            "type": "string"
          },
          "dest": {
            "description": "path of where to download the file to (if desired). If `dest' is a directory, the basename of the file on the remote server will be used.",
            "type": "string"
          },
          "follow_redirects": {
            "description": "Whether or not the URI module should follow redirects. `all' will follow all redirects. `safe' will follow only \"safe\" redirects, where \"safe\" means that the client is only doing a GET or HEAD on the URI to which it is being redirected. `none' will not follow any redirects. Note that `yes' and `no' choices are accepted for backwards compatibility, where `yes' is the equivalent of `all' and `no' is the equivalent of `safe'. `yes' and `no' are deprecated and will be removed in some future version of Ansible.",
            "type": "string"
          },
          "force_basic_auth": {
            "description": "The library used by the uri module only sends authentication information when a webservice responds to an initial request with a 401 status. Since some basic auth services do not properly send a 401, logins will fail. This option forces the sending of the Basic authentication header upon initial request.",
            "type": "string"
          },
          "headers": {
            "description": "Add custom HTTP headers to a request in the format of a YAML hash",
            "type": "string"
          },
          "method": {
            "description": "The HTTP method of the request or response. It MUST be uppercase.",
            "type": "string"
          },
          "others": {
            "description": "all arguments accepted by the [file] module also work here",
            "type": "string"
          },
          "password": {
            "description": "password for the module to use for Digest, Basic or WSSE authentication.",
            "type": "string"
          },
          "removes": {
            "description": "a filename, when it does not exist, this step will not be run.",
            "type": "string"
          },
          "return_content": {
            "description": "Whether or not to return the body of the request as a \"content\" key in the dictionary result. If the reported Content- type is \"applicat ion/json\", then the JSON is additionally loaded into a key called `json' in the dictionary results.",
            "type": "string"
          },
          "status_code": {
            "description": "A valid, numeric, HTTP status code that signifies success of the request. Can also be comma separated list of status codes.",
            "type": "string"
          },
          "timeout": {
            "description": "The socket level timeout in seconds",
            "type": "string"
          },
          "url": {
            "description": "HTTP or HTTPS URL in the form (http|https)://ho st.domain[:port]/ path",
            "type": "string"
          },
          "user": {
            "description": "username for the module to use for Digest, Basic or WSSE authentication.",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only set to `no' used on personally controlled sites using self-signed certificates. Prior to 1.9.2 the code defaulted to `no'.",
            "type": "string"
          }
        },
        "required": "url"
      }
    },
    {
      "urpmi": {
        "type": "object",
        "description": "Urpmi manager",
        "properties": {
          "force": {
            "description": "Assume \"yes\" is the answer to any question urpmi has to ask. Corresponds to the `--force' option for `urpmi'.",
            "type": "string"
          },
          "no-recommends": {
            "description": "Corresponds to the `--no-recommends' option for `urpmi'.",
            "type": "string"
          },
          "pkg": {
            "description": "name of package to install, upgrade or remove.",
            "type": "string"
          },
          "state": {
            "description": "Indicates the desired package state",
            "type": "string"
          },
          "update_cache": {
            "description": "update the package database first `urpmi.update -a'.",
            "type": "string"
          }
        },
        "required": "pkg"
      }
    },
    {
      "user": {
        "type": "object",
        "description": "Manage user accounts",
        "properties": {
          "append": {
            "description": "If `yes', will only add groups, not set them to just the list in `groups'.",
            "type": "string"
          },
          "comment": {
            "description": "Optionally sets the description (aka `GECOS') of user account.",
            "type": "string"
          },
          "createhome": {
            "description": "Unless set to `no', a home directory will be made for the user when the account is created or if the home directory does not exist.",
            "type": "string"
          },
          "expires": {
            "description": "An expiry time for the user in epoch, it will be ignored on platforms that do not support this. Currently supported on Linux and FreeBSD.",
            "type": "string"
          },
          "force": {
            "description": "When used with `state=absent', behavior is as with `userdel --force'.",
            "type": "string"
          },
          "generate_ssh_key": {
            "description": "Whether to generate a SSH key for the user in question. This will *not* overwrite an existing SSH key.",
            "type": "string"
          },
          "group": {
            "description": "Optionally sets the user's primary group (takes a group name).",
            "type": "string"
          },
          "groups": {
            "description": "Puts the user in this comma-delimited list of groups. When set to the empty string ('groups='), the user is removed from all groups except the primary group.",
            "type": "string"
          },
          "home": {
            "description": "Optionally set the user's home directory.",
            "type": "string"
          },
          "login_class": {
            "description": "Optionally sets the user's login class for FreeBSD, OpenBSD and NetBSD systems.",
            "type": "string"
          },
          "move_home": {
            "description": "If set to `yes' when used with `home=', attempt to move the user's home directory to the specified directory if it isn't there already.",
            "type": "string"
          },
          "name": {
            "description": "Name of the user to create, remove or modify.",
            "type": "string"
          },
          "non_unique": {
            "description": "Optionally when used with the -u option, this option allows to change the user ID to a non- unique value.",
            "type": "string"
          },
          "password": {
            "description": "Optionally set the user's password to this crypted value. See the user example in the github examples directory for what this looks like in a playbook. See htt p://docs.ansible. com/ansible/faq.h tml#how-do-i -generate- crypted- passwords-for- the-user-module for details on various ways to generate these password values. Note on Darwin system, this value has to be cleartext. Beware of security issues.",
            "type": "string"
          },
          "remove": {
            "description": "When used with `state=absent', behavior is as with `userdel --remove'.",
            "type": "string"
          },
          "seuser": {
            "description": "Optionally sets the seuser type (user_u) on selinux enabled systems.",
            "type": "string"
          },
          "shell": {
            "description": "Optionally set the user's shell.",
            "type": "string"
          },
          "skeleton": {
            "description": "Optionally set a home skeleton directory. Requires createhome option!",
            "type": "string"
          },
          "ssh_key_bits": {
            "description": "Optionally specify number of bits in SSH key to create.",
            "type": "string"
          },
          "ssh_key_comment": {
            "description": "Optionally define the comment for the SSH key.",
            "type": "string"
          },
          "ssh_key_file": {
            "description": "Optionally specify the SSH key filename. If this is a relative filename then it will be relative to the user's home directory.",
            "type": "string"
          },
          "ssh_key_passphrase": {
            "description": "Set a passphrase for the SSH key.  If no passphrase is provided, the SSH key will default to having no passphrase.",
            "type": "string"
          },
          "ssh_key_type": {
            "description": "Optionally specify the type of SSH key to generate. Available SSH key types will depend on implementation present on target host.",
            "type": "string"
          },
          "state": {
            "description": "Whether the account should exist or not, taking action if the state is different from what is stated.",
            "type": "string"
          },
          "system": {
            "description": "When creating an account, setting this to `yes' makes the user a system account. This setting cannot be changed on existing users.",
            "type": "string"
          },
          "uid": {
            "description": "Optionally sets the `UID' of the user.",
            "type": "string"
          },
          "update_password": {
            "description": "`always' will update passwords if they differ. `on_create' will only set the password for newly created users.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "vca_fw": {
        "type": "object",
        "description": "add remove firewall rules in a gateway  in a vca",
        "properties": {
          "api_version": {
            "description": "The api version to be used with the vca",
            "type": "string"
          },
          "fw_rules": {
            "description": "A list of firewall rules to be added to the gateway, Please see examples on valid entries",
            "type": "string"
          },
          "gateway_name": {
            "description": "The name of the gateway of the vdc where the rule should be added",
            "type": "string"
          },
          "host": {
            "description": "The authentication host to be used when service type  is vcd.",
            "type": "string"
          },
          "instance_id": {
            "description": "The instance id in a vchs environment to be used for creating the vapp",
            "type": "string"
          },
          "org": {
            "description": "The org to login to for creating vapp. This option is required when the `service_type' is `vdc'.",
            "type": "string"
          },
          "password": {
            "description": "The vca password, if not set the environment variable VCA_PASS is checked for the password",
            "type": "string"
          },
          "service_type": {
            "description": "The type of service we are authenticating against",
            "type": "string"
          },
          "state": {
            "description": "if the object should be added or removed",
            "type": "string"
          },
          "username": {
            "description": "The vca username or email address, if not set the environment variable VCA_USER is checked for the username.",
            "type": "string"
          },
          "vdc_name": {
            "description": "The name of the vdc where the gateway is located.",
            "type": "string"
          },
          "verify_certs": {
            "description": "If the certificates of the authentication is to be verified",
            "type": "string"
          }
        },
        "required": "fw_rules"
      }
    },
    {
      "vca_nat": {
        "type": "object",
        "description": "add remove nat rules in a gateway  in a vca",
        "properties": {
          "api_version": {
            "description": "The api version to be used with the vca",
            "type": "string"
          },
          "gateway_name": {
            "description": "The name of the gateway of the vdc where the rule should be added",
            "type": "string"
          },
          "host": {
            "description": "The authentication host to be used when service type  is vcd.",
            "type": "string"
          },
          "instance_id": {
            "description": "The instance id in a vchs environment to be used for creating the vapp",
            "type": "string"
          },
          "nat_rules": {
            "description": "A list of rules to be added to the gateway, Please see examples on valid entries",
            "type": "string"
          },
          "org": {
            "description": "The org to login to for creating vapp. This option is required when the `service_type' is `vdc'.",
            "type": "string"
          },
          "password": {
            "description": "The vca password, if not set the environment variable VCA_PASS is checked for the password",
            "type": "string"
          },
          "purge_rules": {
            "description": "If set to true, it will delete all rules in the gateway that are not given as paramter to this module.",
            "type": "string"
          },
          "service_type": {
            "description": "The type of service we are authenticating against",
            "type": "string"
          },
          "state": {
            "description": "if the object should be added or removed",
            "type": "string"
          },
          "username": {
            "description": "The vca username or email address, if not set the environment variable VCA_USER is checked for the username.",
            "type": "string"
          },
          "vdc_name": {
            "description": "The name of the vdc where the gateway is located.",
            "type": "string"
          },
          "verify_certs": {
            "description": "If the certificates of the authentication is to be verified",
            "type": "string"
          }
        },
        "required": "nat_rules"
      }
    },
    {
      "vca_vapp": {
        "type": "object",
        "description": "Manages vCloud Air vApp instances.",
        "properties": {
          "api_version": {
            "description": "The api version to be used with the vca",
            "type": "string"
          },
          "host": {
            "description": "The authentication host to be used when service type  is vcd.",
            "type": "string"
          },
          "instance_id": {
            "description": "The instance id in a vchs environment to be used for creating the vapp",
            "type": "string"
          },
          "network_mode": {
            "description": "Configures the mode of the network connection.",
            "type": "string"
          },
          "network_name": {
            "description": "The name of the network that should be attached to the virtual machine in the vApp.  The virtual network specified must already be created in the vCloud Air VDC. If the `state' is not 'absent' then the `network_name' argument must be provided.",
            "type": "string"
          },
          "operation": {
            "description": "Specifies an operation to be performed on the vApp.",
            "type": "string"
          },
          "org": {
            "description": "The org to login to for creating vapp, mostly set when the service_type is vdc.",
            "type": "string"
          },
          "password": {
            "description": "The vCloud Air password to use during authentication",
            "type": "string"
          },
          "service_type": {
            "description": "The type of service we are authenticating against",
            "type": "string"
          },
          "state": {
            "description": "Configures the state of the vApp.",
            "type": "string"
          },
          "template_name": {
            "description": "The name of the vApp template to use to create the vApp instance.  If the `state' is not `absent` then the `template_name' value must be provided.  The `template_name' must be previously uploaded to the catalog specified by `catalog_name'",
            "type": "string"
          },
          "username": {
            "description": "The vCloud Air username to use during authentication",
            "type": "string"
          },
          "vapp_name": {
            "description": "The name of the vCloud Air vApp instance",
            "type": "string"
          },
          "vdc_name": {
            "description": "The name of the virtual data center (VDC) where the vm should be created or contains the vAPP.",
            "type": "string"
          },
          "vm_cpus": {
            "description": "The number of vCPUs to configure for the VM in the vApp.   If the `vm_name' argument is provided, then this becomes a per VM setting otherwise it is applied to all VMs in the vApp.",
            "type": "string"
          },
          "vm_memory": {
            "description": "The amount of memory in MB to allocate to VMs in the vApp.  If the `vm_name' argument is provided, then this becomes a per VM setting otherise it is applied to all VMs in the vApp.",
            "type": "string"
          },
          "vm_name": {
            "description": "The name of the virtual machine instance in the vApp to manage.",
            "type": "string"
          }
        },
        "required": "vapp_name"
      }
    },
    {
      "vertica_configuration": {
        "type": "object",
        "description": "Updates Vertica configuration parameters.",
        "properties": {
          "cluster": {
            "description": "Name of the Vertica cluster.",
            "type": "string"
          },
          "db": {
            "description": "Name of the Vertica database.",
            "type": "string"
          },
          "login_password": {
            "description": "The password used to authenticate with.",
            "type": "string"
          },
          "login_user": {
            "description": "The username used to authenticate with.",
            "type": "string"
          },
          "name": {
            "description": "Name of the parameter to update.",
            "type": "string"
          },
          "port": {
            "description": "Vertica cluster port to connect to.",
            "type": "string"
          },
          "value": {
            "description": "Value of the parameter to be set.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "value"
        ]
      }
    },
    {
      "vertica_facts": {
        "type": "object",
        "description": "Gathers Vertica database facts.",
        "properties": {
          "cluster": {
            "description": "Name of the cluster running the schema.",
            "type": "string"
          },
          "db": {
            "description": "Name of the database running the schema.",
            "type": "string"
          },
          "login_password": {
            "description": "The password used to authenticate with.",
            "type": "string"
          },
          "login_user": {
            "description": "The username used to authenticate with.",
            "type": "string"
          },
          "port": {
            "description": "D a t a b a s e   p o r t   t o   c o n n e c t t o .",
            "type": "string"
          }
        }
      }
    },
    {
      "vertica_role": {
        "type": "object",
        "description": "Adds or removes Vertica database roles and assigns roles to them.",
        "properties": {
          "assigned_roles": {
            "description": "Comma separated list of roles to assign to the role.",
            "type": "string"
          },
          "cluster": {
            "description": "Name of the Vertica cluster.",
            "type": "string"
          },
          "db": {
            "description": "Name of the Vertica database.",
            "type": "string"
          },
          "login_password": {
            "description": "The password used to authenticate with.",
            "type": "string"
          },
          "login_user": {
            "description": "The username used to authenticate with.",
            "type": "string"
          },
          "name": {
            "description": "Name of the role to add or remove.",
            "type": "string"
          },
          "port": {
            "description": "Vertica cluster port to connect to.",
            "type": "string"
          },
          "state": {
            "description": "Whether to create `present', drop `absent' or lock `locked' a role.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "vertica_schema": {
        "type": "object",
        "description": "Adds or removes Vertica database schema and roles.",
        "properties": {
          "cluster": {
            "description": "Name of the Vertica cluster.",
            "type": "string"
          },
          "create_roles": {
            "description": "Comma separated list of roles to create and grant usage and create access to the schema.",
            "type": "string"
          },
          "db": {
            "description": "Name of the Vertica database.",
            "type": "string"
          },
          "login_password": {
            "description": "The password used to authenticate with.",
            "type": "string"
          },
          "login_user": {
            "description": "The username used to authenticate with.",
            "type": "string"
          },
          "name": {
            "description": "Name of the schema to add or remove.",
            "type": "string"
          },
          "owner": {
            "description": "Name of the user to set as owner of the schema.",
            "type": "string"
          },
          "port": {
            "description": "Vertica cluster port to connect to.",
            "type": "string"
          },
          "state": {
            "description": "Whether to create `present', or drop `absent' a schema.",
            "type": "string"
          },
          "usage_roles": {
            "description": "Comma separated list of roles to create and grant usage access to the schema.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "vertica_user": {
        "type": "object",
        "description": "Adds or removes Vertica database users and assigns roles.",
        "properties": {
          "cluster": {
            "description": "Name of the Vertica cluster.",
            "type": "string"
          },
          "db": {
            "description": "Name of the Vertica database.",
            "type": "string"
          },
          "expired": {
            "description": "Sets the user's password expiration.",
            "type": "string"
          },
          "ldap": {
            "description": "Set to true if users are authenticated via LDAP. The user will be created with password expired and set to `$ldap$'.",
            "type": "string"
          },
          "login_password": {
            "description": "The password used to authenticate with.",
            "type": "string"
          },
          "login_user": {
            "description": "The username used to authenticate with.",
            "type": "string"
          },
          "name": {
            "description": "Name of the user to add or remove.",
            "type": "string"
          },
          "password": {
            "description": "The user's password encrypted by the MD5 algorithm. The password must be generated with the format `\"md5\" + md5[password + username]', resulting in a total of 35 characters. An easy way to do this is by querying the Vertica database with select 'md5' ||md5('<user_pass word><user_name>' ).",
            "type": "string"
          },
          "port": {
            "description": "Vertica cluster port to connect to.",
            "type": "string"
          },
          "profile": {
            "description": "Sets the user's profile.",
            "type": "string"
          },
          "resource_pool": {
            "description": "Sets the user's resource pool.",
            "type": "string"
          },
          "roles": {
            "description": "Comma separated list of roles to assign to the user.",
            "type": "string"
          },
          "state": {
            "description": "Whether to create `present', drop `absent' or lock `locked' a user.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "virt": {
        "type": "object",
        "description": "Manages virtual machines supported by libvirt",
        "properties": {
          "command": {
            "description": "in addition to state management, various non- idempotent commands are available. See examples",
            "type": "string"
          },
          "name": {
            "description": "name of the guest VM being managed. Note that VM must be previously defined with xml.",
            "type": "string"
          },
          "state": {
            "description": "Note that there may be some lag for state requests like `shutdown' since these refer only to VM states. After starting a guest, it may not be immediately accessible.",
            "type": "string"
          },
          "uri": {
            "description": "libvirt connection uri",
            "type": "string"
          },
          "xml": {
            "description": "XML document used with the define command",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "virt_net": {
        "type": "object",
        "description": "Manage libvirt network configuration",
        "properties": {
          "autostart": {
            "description": "Specify if a given storage pool should be started automatically on system boot.",
            "type": "string"
          },
          "command": {
            "description": "in addition to state management, various non- idempotent commands are available. See examples. Modify was added in version 2.1",
            "type": "string"
          },
          "name": {
            "description": "name of the network being managed. Note that network must be previously defined with xml.",
            "type": "string"
          },
          "state": {
            "description": "specify which state you want a network to be in. If 'active', network will be started. If 'present', ensure that network is present but do not change its state; if it's missing, you need to specify xml argument. If 'inactive', network will be stopped. If 'undefined' or 'absent', network will be removed from `libvirt' configuration.",
            "type": "string"
          },
          "uri": {
            "description": "libvirt connection uri.",
            "type": "string"
          },
          "xml": {
            "description": "XML document used with the define command.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "virt_pool": {
        "type": "object",
        "description": "Manage libvirt storage pools",
        "properties": {
          "autostart": {
            "description": "Specify if a given storage pool should be started automatically on system boot.",
            "type": "string"
          },
          "command": {
            "description": "in addition to state management, various non- idempotent commands are available. See examples.",
            "type": "string"
          },
          "mode": {
            "description": "Pass additional parameters to 'build' or 'delete' commands.",
            "type": "string"
          },
          "name": {
            "description": "name of the storage pool being managed. Note that pool must be previously defined with xml.",
            "type": "string"
          },
          "state": {
            "description": "specify which state you want a storage pool to be in. If 'active', pool will be started. If 'present', ensure that pool is present but do not change its state; if it's missing, you need to specify xml argument. If 'inactive', pool will be stopped. If 'undefined' or 'absent', pool will be removed from `libvirt' configuration. If 'deleted', pool contents will be deleted and then pool undefined.",
            "type": "string"
          },
          "uri": {
            "description": "`libvirt' connection uri.",
            "type": "string"
          },
          "xml": {
            "description": "XML document used with the define command.",
            "type": "string"
          }
        }
      }
    },
    {
      "vmware_cluster": {
        "type": "object",
        "description": "Create VMware vSphere Cluster",
        "properties": {
          "cluster_name": {
            "description": "The name of the cluster that will be created",
            "type": "string"
          },
          "datacenter_name": {
            "description": "The name of the datacenter the cluster will be created in.",
            "type": "string"
          },
          "enable_drs": {
            "description": "If set to True will enable DRS when the cluster is created.",
            "type": "string"
          },
          "enable_ha": {
            "description": "If set to True will enable HA when the cluster is created.",
            "type": "string"
          },
          "enable_vsan": {
            "description": "If set to True will enable vSAN when the cluster is created.",
            "type": "string"
          },
          "hostname": {
            "description": "The hostname or IP address of the vSphere vCenter",
            "type": "string"
          },
          "password": {
            "description": "The password of the vSphere vCenter",
            "type": "string"
          },
          "username": {
            "description": "The username of the vSphere vCenter",
            "type": "string"
          },
          "validate_certs": {
            "description": "Allows connection when SSL certificates are not valid. Set to false when certificates are not trusted",
            "type": "string"
          }
        },
        "required": [
          "cluster_name",
          "datacenter_name",
          "hostname",
          "password",
          "username"
        ]
      }
    },
    {
      "vmware_datacenter": {
        "type": "object",
        "description": "Manage VMware vSphere Datacenters",
        "properties": {
          "datacenter_name": {
            "description": "The name of the datacenter the cluster will be created in.",
            "type": "string"
          },
          "hostname": {
            "description": "The hostname or IP address of the vSphere vCenter",
            "type": "string"
          },
          "password": {
            "description": "The password of the vSphere vCenter",
            "type": "string"
          },
          "state": {
            "description": "If the datacenter should be present or absent",
            "type": "string"
          },
          "username": {
            "description": "The username of the vSphere vCenter",
            "type": "string"
          },
          "validate_certs": {
            "description": "Allows connection when SSL certificates are not valid. Set to false when certificates are not trusted",
            "type": "string"
          }
        },
        "required": [
          "datacenter_name",
          "hostname",
          "password",
          "username"
        ]
      }
    },
    {
      "vmware_dns_config": {
        "type": "object",
        "description": "Manage VMware ESXi DNS Configuration",
        "properties": {
          "change_hostname_to": {
            "description": "The hostname that an ESXi host should be changed to.",
            "type": "string"
          },
          "dns_servers": {
            "description": "The DNS servers that the host should be configured to use.",
            "type": "string"
          },
          "domainname": {
            "description": "The domain the ESXi host should be apart of.",
            "type": "string"
          },
          "hostname": {
            "description": "The hostname or IP address of the vSphere vCenter",
            "type": "string"
          },
          "password": {
            "description": "The password of the vSphere vCenter",
            "type": "string"
          },
          "username": {
            "description": "The username of the vSphere vCenter",
            "type": "string"
          },
          "validate_certs": {
            "description": "Allows connection when SSL certificates are not valid. Set to false when certificates are not trusted",
            "type": "string"
          }
        },
        "required": [
          "change_hostname_to",
          "dns_servers",
          "domainname",
          "hostname",
          "password",
          "username"
        ]
      }
    },
    {
      "vmware_dvs_host": {
        "type": "object",
        "description": "Add or remove a host from distributed virtual switch",
        "properties": {
          "esxi_hostname": {
            "description": "The ESXi hostname",
            "type": "string"
          },
          "hostname": {
            "description": "The hostname or IP address of the vSphere vCenter",
            "type": "string"
          },
          "password": {
            "description": "The password of the vSphere vCenter",
            "type": "string"
          },
          "state": {
            "description": "If the host should be present or absent attached to the vSwitch",
            "type": "string"
          },
          "switch_name": {
            "description": "The name of the Distributed vSwitch",
            "type": "string"
          },
          "username": {
            "description": "The username of the vSphere vCenter",
            "type": "string"
          },
          "validate_certs": {
            "description": "Allows connection when SSL certificates are not valid. Set to false when certificates are not trusted",
            "type": "string"
          },
          "vmnics": {
            "description": "The ESXi hosts vmnics to use with the Distributed vSwitch",
            "type": "string"
          }
        },
        "required": [
          "esxi_hostname",
          "hostname",
          "password",
          "state",
          "switch_name",
          "username",
          "vmnics"
        ]
      }
    },
    {
      "vmware_dvs_portgroup": {
        "type": "object",
        "description": "Create or remove a Distributed vSwitch portgroup",
        "properties": {
          "hostname": {
            "description": "The hostname or IP address of the vSphere vCenter",
            "type": "string"
          },
          "num_ports": {
            "description": "The number of ports the portgroup should contain",
            "type": "string"
          },
          "password": {
            "description": "The password of the vSphere vCenter",
            "type": "string"
          },
          "portgroup_name": {
            "description": "The name of the portgroup that is to be created or deleted",
            "type": "string"
          },
          "portgroup_type": {
            "description": "See VMware KB 1022312 regarding portgroup types",
            "type": "string"
          },
          "switch_name": {
            "description": "The name of the distributed vSwitch the port group should be created on.",
            "type": "string"
          },
          "username": {
            "description": "The username of the vSphere vCenter",
            "type": "string"
          },
          "validate_certs": {
            "description": "Allows connection when SSL certificates are not valid. Set to false when certificates are not trusted",
            "type": "string"
          },
          "vlan_id": {
            "description": "The VLAN ID that should be configured with the portgroup",
            "type": "string"
          }
        },
        "required": [
          "hostname",
          "num_ports",
          "password",
          "portgroup_name",
          "portgroup_type",
          "switch_name",
          "username",
          "vlan_id"
        ]
      }
    },
    {
      "vmware_dvswitch": {
        "type": "object",
        "description": "Create or remove a distributed vSwitch",
        "properties": {
          "datacenter_name": {
            "description": "The name of the datacenter that will contain the dvSwitch",
            "type": "string"
          },
          "discovery_operation": {
            "description": "Select the discovery operation",
            "type": "string"
          },
          "discovery_proto": {
            "description": "Link discovery protocol between Cisco and Link Layer discovery",
            "type": "string"
          },
          "hostname": {
            "description": "The hostname or IP address of the vSphere vCenter",
            "type": "string"
          },
          "mtu": {
            "description": "The switch maximum transmission unit",
            "type": "string"
          },
          "password": {
            "description": "The password of the vSphere vCenter",
            "type": "string"
          },
          "state": {
            "description": "Create or remove dvSwitch",
            "type": "string"
          },
          "switch_name": {
            "description": "The name of the switch to create or remove",
            "type": "string"
          },
          "uplink_quantity": {
            "description": "Quantity of uplink per ESXi host added to the switch",
            "type": "string"
          },
          "username": {
            "description": "The username of the vSphere vCenter",
            "type": "string"
          },
          "validate_certs": {
            "description": "Allows connection when SSL certificates are not valid. Set to false when certificates are not trusted",
            "type": "string"
          }
        },
        "required": [
          "datacenter_name",
          "discovery_proto",
          "hostname",
          "mtu",
          "password",
          "switch_name",
          "uplink_quantity",
          "username"
        ]
      }
    },
    {
      "vmware_guest": {
        "type": "object",
        "description": "Manages virtualmachines in vcenter",
        "properties": {
          "datacenter": {
            "description": "Destination datacenter for the deploy operation",
            "type": "string"
          },
          "disk": {
            "description": "A list of disks to add",
            "type": "string"
          },
          "esxi_hostname": {
            "description": "The esxi hostname where the VM will run.",
            "type": "string"
          },
          "folder": {
            "description": "Destination folder path for the new guest",
            "type": "string"
          },
          "force": {
            "description": "Ignore warnings and complete the actions",
            "type": "string"
          },
          "hardware": {
            "description": "Attributes such as cpus, memory, osid, and disk controller",
            "type": "string"
          },
          "hostname": {
            "description": "The hostname or IP address of the vSphere vCenter",
            "type": "string"
          },
          "name": {
            "description": "Name of the newly deployed guest",
            "type": "string"
          },
          "name_match": {
            "description": "If multiple vms matching the name, use the first or last found",
            "type": "string"
          },
          "nic": {
            "description": "A list of nics to add",
            "type": "string"
          },
          "password": {
            "description": "The password of the vSphere vCenter",
            "type": "string"
          },
          "state": {
            "description": "What state should the virtualmachine be in?",
            "type": "string"
          },
          "template": {
            "description": "Name of the template to deploy, if needed to create the guest (state=present). If the guest exists already this setting will be ignored.",
            "type": "string"
          },
          "username": {
            "description": "The username of the vSphere vCenter",
            "type": "string"
          },
          "uuid": {
            "description": "UUID of the instance to manage if known, this is vmware's unique identifier. This is required if name is not supplied.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Allows connection when SSL certificates are not valid. Set to false when certificates are not trusted",
            "type": "string"
          },
          "wait_for_ip_address": {
            "description": "Wait until vcenter detects an IP address for the guest",
            "type": "string"
          }
        },
        "required": [
          "datacenter",
          "esxi_hostname",
          "hostname",
          "name",
          "password",
          "state",
          "username"
        ]
      }
    },
    {
      "vmware_host": {
        "type": "object",
        "description": "Add/remove ESXi host to/from vCenter",
        "properties": {
          "cluster_name": {
            "description": "Name of the cluster to add the host",
            "type": "string"
          },
          "datacenter_name": {
            "description": "Name of the datacenter to add the host",
            "type": "string"
          },
          "esxi_hostname": {
            "description": "ESXi hostname to manage",
            "type": "string"
          },
          "esxi_password": {
            "description": "ESXi password",
            "type": "string"
          },
          "esxi_username": {
            "description": "ESXi username",
            "type": "string"
          },
          "hostname": {
            "description": "The hostname or IP address of the vSphere vCenter",
            "type": "string"
          },
          "password": {
            "description": "The password of the vSphere vCenter",
            "type": "string"
          },
          "state": {
            "description": "Add or remove the host",
            "type": "string"
          },
          "username": {
            "description": "The username of the vSphere vCenter",
            "type": "string"
          },
          "validate_certs": {
            "description": "Allows connection when SSL certificates are not valid. Set to false when certificates are not trusted",
            "type": "string"
          }
        },
        "required": [
          "cluster_name",
          "datacenter_name",
          "esxi_hostname",
          "esxi_password",
          "esxi_username",
          "hostname",
          "password",
          "username"
        ]
      }
    },
    {
      "vmware_local_user_manager": {
        "type": "object",
        "description": "Manage local users on an ESXi host",
        "properties": {
          "hostname": {
            "description": "The hostname or IP address of the vSphere vCenter",
            "type": "string"
          },
          "local_user_description": {
            "description": "Description for the user",
            "type": "string"
          },
          "local_user_name": {
            "description": "The local user name to be changed",
            "type": "string"
          },
          "local_user_password": {
            "description": "The password to be set",
            "type": "string"
          },
          "password": {
            "description": "The password of the vSphere vCenter",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the user. If the user already exists when `state=present', the user info is updated",
            "type": "string"
          },
          "username": {
            "description": "The username of the vSphere vCenter",
            "type": "string"
          },
          "validate_certs": {
            "description": "Allows connection when SSL certificates are not valid. Set to false when certificates are not trusted",
            "type": "string"
          }
        },
        "required": [
          "hostname",
          "local_user_name",
          "password",
          "username"
        ]
      }
    },
    {
      "vmware_maintenancemode": {
        "type": "object",
        "description": "Place a host into maintenance mode",
        "properties": {
          "esxi_hostname": {
            "description": "Name of the host as defined in vCenter",
            "type": "string"
          },
          "evacuate": {
            "description": "If True, evacuate all powered off VMs",
            "type": "string"
          },
          "hostname": {
            "description": "The hostname or IP address of the vSphere vCenter",
            "type": "string"
          },
          "password": {
            "description": "The password of the vSphere vCenter",
            "type": "string"
          },
          "state": {
            "description": "Enter or exit maintenance mode",
            "type": "string"
          },
          "timeout": {
            "description": "Specify a timeout for the operation",
            "type": "string"
          },
          "username": {
            "description": "The username of the vSphere vCenter",
            "type": "string"
          },
          "validate_certs": {
            "description": "Allows connection when SSL certificates are not valid. Set to false when certificates are not trusted",
            "type": "string"
          },
          "vsan_mode": {
            "description": "Specify which VSAN compliant mode to enter",
            "type": "string"
          }
        },
        "required": [
          "esxi_hostname",
          "hostname",
          "password",
          "username"
        ]
      }
    },
    {
      "vmware_migrate_vmk": {
        "type": "object",
        "description": "Migrate a VMK interface from VSS to VDS",
        "properties": {
          "current_portgroup_name": {
            "description": "Portgroup name VMK interface is currently on",
            "type": "string"
          },
          "current_switch_name": {
            "description": "Switch VMK interface is currently on",
            "type": "string"
          },
          "device": {
            "description": "VMK interface name",
            "type": "string"
          },
          "esxi_hostname": {
            "description": "ESXi hostname to be managed",
            "type": "string"
          },
          "hostname": {
            "description": "The hostname or IP address of the vSphere vCenter",
            "type": "string"
          },
          "migrate_portgroup_name": {
            "description": "Portgroup name to migrate VMK interface to",
            "type": "string"
          },
          "migrate_switch_name": {
            "description": "Switch name to migrate VMK interface to",
            "type": "string"
          },
          "password": {
            "description": "The password of the vSphere vCenter",
            "type": "string"
          },
          "username": {
            "description": "The username of the vSphere vCenter",
            "type": "string"
          },
          "validate_certs": {
            "description": "Allows connection when SSL certificates are not valid. Set to false when certificates are not trusted",
            "type": "string"
          }
        },
        "required": [
          "current_portgroup_name",
          "current_switch_name",
          "device",
          "esxi_hostname",
          "hostname",
          "migrate_portgroup_name",
          "migrate_switch_name",
          "password",
          "username"
        ]
      }
    },
    {
      "vmware_portgroup": {
        "type": "object",
        "description": "Create a VMware portgroup",
        "properties": {
          "hostname": {
            "description": "The hostname or IP address of the vSphere vCenter",
            "type": "string"
          },
          "network_policy": {
            "description": "Network policy specifies layer 2 security settings for a portgroup such as promiscuous mode, where guest adapter listens to all the packets, MAC address changes and forged transmits. Settings are promiscuous_mode, forged_transmits, mac_changes",
            "type": "string"
          },
          "password": {
            "description": "The password of the vSphere vCenter",
            "type": "string"
          },
          "portgroup_name": {
            "description": "Portgroup name to add",
            "type": "string"
          },
          "switch_name": {
            "description": "vSwitch to modify",
            "type": "string"
          },
          "username": {
            "description": "The username of the vSphere vCenter",
            "type": "string"
          },
          "validate_certs": {
            "description": "Allows connection when SSL certificates are not valid. Set to false when certificates are not trusted",
            "type": "string"
          },
          "vlan_id": {
            "description": "VLAN ID to assign to portgroup",
            "type": "string"
          }
        },
        "required": [
          "hostname",
          "password",
          "portgroup_name",
          "switch_name",
          "username",
          "vlan_id"
        ]
      }
    },
    {
      "vmware_target_canonical_facts": {
        "type": "object",
        "description": "Return canonical (NAA) from an ESXi host",
        "properties": {
          "hostname": {
            "description": "The hostname or IP address of the vSphere vCenter",
            "type": "string"
          },
          "password": {
            "description": "The password of the vSphere vCenter",
            "type": "string"
          },
          "target_id": {
            "description": "The target id based on order of scsi device",
            "type": "string"
          },
          "username": {
            "description": "The username of the vSphere vCenter",
            "type": "string"
          },
          "validate_certs": {
            "description": "Allows connection when SSL certificates are not valid. Set to false when certificates are not trusted",
            "type": "string"
          }
        },
        "required": [
          "hostname",
          "password",
          "target_id",
          "username"
        ]
      }
    },
    {
      "vmware_vm_facts": {
        "type": "object",
        "description": "Return basic facts pertaining to a vSphere virtual machine guest",
        "properties": {
          "hostname": {
            "description": "The hostname or IP address of the vSphere vCenter",
            "type": "string"
          },
          "password": {
            "description": "The password of the vSphere vCenter",
            "type": "string"
          },
          "username": {
            "description": "The username of the vSphere vCenter",
            "type": "string"
          },
          "validate_certs": {
            "description": "Allows connection when SSL certificates are not valid. Set to false when certificates are not trusted",
            "type": "string"
          }
        },
        "required": [
          "hostname",
          "password",
          "username"
        ]
      }
    },
    {
      "vmware_vm_shell": {
        "type": "object",
        "description": "Execute a process in VM",
        "properties": {
          "cluster": {
            "description": "The cluster hosting the VM Will help speed up search",
            "type": "string"
          },
          "datacenter": {
            "description": "The datacenter hosting the VM Will help speed up search",
            "type": "string"
          },
          "hostname": {
            "description": "The hostname or IP address of the vSphere vCenter",
            "type": "string"
          },
          "password": {
            "description": "The password of the vSphere vCenter",
            "type": "string"
          },
          "username": {
            "description": "The username of the vSphere vCenter",
            "type": "string"
          },
          "validate_certs": {
            "description": "Allows connection when SSL certificates are not valid. Set to false when certificates are not trusted",
            "type": "string"
          },
          "vm_id": {
            "description": "The identification for the VM",
            "type": "string"
          },
          "vm_id_type": {
            "description": "The identification tag for the VM",
            "type": "string"
          },
          "vm_password": {
            "description": "The password used to login to the VM.",
            "type": "string"
          },
          "vm_shell": {
            "description": "The absolute path to the program to start. On Linux this is executed via bash.",
            "type": "string"
          },
          "vm_shell_args": {
            "description": "The argument to the program.",
            "type": "string"
          },
          "vm_shell_cwd": {
            "description": "The current working directory of the application from which it will be run",
            "type": "string"
          },
          "vm_shell_env": {
            "description": "Comma seperated list of envirnoment variable, specified in the guest OS notation",
            "type": "string"
          },
          "vm_username": {
            "description": "The user to connect to the VM.",
            "type": "string"
          }
        },
        "required": [
          "hostname",
          "password",
          "username",
          "vm_id",
          "vm_shell"
        ]
      }
    },
    {
      "vmware_vm_vss_dvs_migrate": {
        "type": "object",
        "description": "Migrates a virtual machine from a standard vswitch to distributed",
        "properties": {
          "dvportgroup_name": {
            "description": "Name of the portgroup to migrate to the virtual machine to",
            "type": "string"
          },
          "hostname": {
            "description": "The hostname or IP address of the vSphere vCenter",
            "type": "string"
          },
          "password": {
            "description": "The password of the vSphere vCenter",
            "type": "string"
          },
          "username": {
            "description": "The username of the vSphere vCenter",
            "type": "string"
          },
          "validate_certs": {
            "description": "Allows connection when SSL certificates are not valid. Set to false when certificates are not trusted",
            "type": "string"
          },
          "vm_name": {
            "description": "Name of the virtual machine to migrate to a dvSwitch",
            "type": "string"
          }
        },
        "required": [
          "dvportgroup_name",
          "hostname",
          "password",
          "username",
          "vm_name"
        ]
      }
    },
    {
      "vmware_vmkernel": {
        "type": "object",
        "description": "Create a VMware VMkernel Interface",
        "properties": {
          "enable_ft": {
            "description": "Enable the VMK interface for Fault Tolerance traffic",
            "type": "string"
          },
          "enable_mgmt": {
            "description": "Enable the VMK interface for Management traffic",
            "type": "string"
          },
          "enable_vmotion": {
            "description": "Enable the VMK interface for vMotion traffic",
            "type": "string"
          },
          "enable_vsan": {
            "description": "Enable the VMK interface for VSAN traffic",
            "type": "string"
          },
          "hostname": {
            "description": "The hostname or IP address of the vSphere vCenter",
            "type": "string"
          },
          "ip_address": {
            "description": "The IP Address for the VMK interface",
            "type": "string"
          },
          "mtu": {
            "description": "The MTU for the VMK interface",
            "type": "string"
          },
          "password": {
            "description": "The password of the vSphere vCenter",
            "type": "string"
          },
          "portgroup_name": {
            "description": "The name of the portgroup for the VMK interface",
            "type": "string"
          },
          "subnet_mask": {
            "description": "The Subnet Mask for the VMK interface",
            "type": "string"
          },
          "username": {
            "description": "The username of the vSphere vCenter",
            "type": "string"
          },
          "validate_certs": {
            "description": "Allows connection when SSL certificates are not valid. Set to false when certificates are not trusted",
            "type": "string"
          },
          "vland_id": {
            "description": "The VLAN ID for the VMK interface",
            "type": "string"
          },
          "vswitch_name": {
            "description": "The name of the vswitch where to add the VMK interface",
            "type": "string"
          }
        },
        "required": [
          "hostname",
          "ip_address",
          "password",
          "portgroup_name",
          "subnet_mask",
          "username",
          "vland_id",
          "vswitch_name"
        ]
      }
    },
    {
      "vmware_vmkernel_ip_config": {
        "type": "object",
        "description": "Configure the VMkernel IP Address",
        "properties": {
          "hostname": {
            "description": "The hostname or IP address of the vSphere vCenter",
            "type": "string"
          },
          "ip_address": {
            "description": "IP address to assign to VMkernel interface",
            "type": "string"
          },
          "password": {
            "description": "The password of the vSphere vCenter",
            "type": "string"
          },
          "subnet_mask": {
            "description": "Subnet Mask to assign to VMkernel interface",
            "type": "string"
          },
          "username": {
            "description": "The username of the vSphere vCenter",
            "type": "string"
          },
          "validate_certs": {
            "description": "Allows connection when SSL certificates are not valid. Set to false when certificates are not trusted",
            "type": "string"
          },
          "vmk_name": {
            "description": "VMkernel interface name",
            "type": "string"
          }
        },
        "required": [
          "hostname",
          "ip_address",
          "password",
          "subnet_mask",
          "username",
          "vmk_name"
        ]
      }
    },
    {
      "vmware_vmotion": {
        "type": "object",
        "description": "Move a virtual machine using vMotion",
        "properties": {
          "destination_host": {
            "description": "Name of the end host the VM should be running on",
            "type": "string"
          },
          "hostname": {
            "description": "The hostname or IP address of the vSphere vCenter",
            "type": "string"
          },
          "password": {
            "description": "The password of the vSphere vCenter",
            "type": "string"
          },
          "username": {
            "description": "The username of the vSphere vCenter",
            "type": "string"
          },
          "validate_certs": {
            "description": "Allows connection when SSL certificates are not valid. Set to false when certificates are not trusted",
            "type": "string"
          },
          "vm_name": {
            "description": "Name of the VM to perform a vMotion on",
            "type": "string"
          }
        },
        "required": [
          "destination_host",
          "hostname",
          "password",
          "username",
          "vm_name"
        ]
      }
    },
    {
      "vmware_vsan_cluster": {
        "type": "object",
        "description": "Configure VSAN clustering on an ESXi host",
        "properties": {
          "cluster_uuid": {
            "description": "Desired cluster UUID",
            "type": "string"
          },
          "hostname": {
            "description": "The hostname or IP address of the vSphere vCenter",
            "type": "string"
          },
          "password": {
            "description": "The password of the vSphere vCenter",
            "type": "string"
          },
          "username": {
            "description": "The username of the vSphere vCenter",
            "type": "string"
          },
          "validate_certs": {
            "description": "Allows connection when SSL certificates are not valid. Set to false when certificates are not trusted",
            "type": "string"
          }
        },
        "required": [
          "hostname",
          "password",
          "username"
        ]
      }
    },
    {
      "vmware_vswitch": {
        "type": "object",
        "description": "Add a VMware Standard Switch to an ESXi host",
        "properties": {
          "hostname": {
            "description": "The hostname or IP address of the vSphere vCenter",
            "type": "string"
          },
          "mtu": {
            "description": "MTU to configure on vswitch",
            "type": "string"
          },
          "nic_name": {
            "description": "vmnic name to attach to vswitch",
            "type": "string"
          },
          "number_of_ports": {
            "description": "Number of port to configure on vswitch",
            "type": "string"
          },
          "password": {
            "description": "The password of the vSphere vCenter",
            "type": "string"
          },
          "state": {
            "description": "Add or remove the switch",
            "type": "string"
          },
          "switch_name": {
            "description": "vSwitch name to add",
            "type": "string"
          },
          "username": {
            "description": "The username of the vSphere vCenter",
            "type": "string"
          },
          "validate_certs": {
            "description": "Allows connection when SSL certificates are not valid. Set to false when certificates are not trusted",
            "type": "string"
          }
        },
        "required": [
          "hostname",
          "nic_name",
          "password",
          "switch_name",
          "username"
        ]
      }
    },
    {
      "vsphere_copy": {
        "type": "object",
        "description": "Copy a file to a vCenter datastore",
        "properties": {
          "datacenter": {
            "description": "The datacenter on the vCenter server that holds the datastore.",
            "type": "string"
          },
          "datastore": {
            "description": "The datastore on the vCenter server to push files to.",
            "type": "string"
          },
          "host": {
            "description": "The vCenter server on which the datastore is available.",
            "type": "string"
          },
          "login": {
            "description": "The login name to authenticate on the vCenter server.",
            "type": "string"
          },
          "password": {
            "description": "The password to authenticate on the vCenter server.",
            "type": "string"
          },
          "path": {
            "description": "The file to push to the datastore on the vCenter server.",
            "type": "string"
          },
          "src": {
            "description": "The file to push to vCenter",
            "type": "string"
          },
          "validate_certs": {
            "description": "If `no', SSL certificates will not be validated. This should only be set to `no' when no other option exists.",
            "type": "string"
          }
        },
        "required": [
          "datacenter",
          "datastore",
          "host",
          "login",
          "password",
          "path",
          "src"
        ]
      }
    },
    {
      "vsphere_guest": {
        "type": "object",
        "description": "Create/delete/manage a guest VM through VMware vSphere.",
        "properties": {
          "cluster": {
            "description": "The name of the cluster to create the VM in. By default this is derived from the host you tell the module to build the guest on.",
            "type": "string"
          },
          "esxi": {
            "description": "Dictionary which includes datacenter and hostname on which the VM should be created. For standalone ESXi hosts, ha- datacenter should be used as the datacenter name",
            "type": "string"
          },
          "force": {
            "description": "Boolean. Allows you to run commands which may alter the running state of a guest. Also used to reconfigure and destroy.",
            "type": "string"
          },
          "from_template": {
            "description": "Specifies if the VM should be deployed from a template (mutually exclusive with 'state' parameter). No guest customization changes to hardware such as CPU, RAM, NICs or Disks can be applied when launching from template.",
            "type": "string"
          },
          "guest": {
            "description": "The virtual server name you wish to manage.",
            "type": "string"
          },
          "password": {
            "description": "Password of the user to connect to vcenter as.",
            "type": "string"
          },
          "power_on_after_clone": {
            "description": "Specifies if the VM should be powered on after the clone.",
            "type": "string"
          },
          "resource_pool": {
            "description": "The name of the resource_pool to create the VM in.",
            "type": "string"
          },
          "snapshot_to_clone": {
            "description": "A string that when specified, will create a linked clone copy of the VM. Snapshot must already be taken in vCenter.",
            "type": "string"
          },
          "state": {
            "description": "Indicate desired state of the vm. 'reconfigured' only applies changes to 'vm_cdrom', 'memory_mb', and 'num_cpus' in vm_hardware parameter. The 'memory_mb' and 'num_cpus' changes are applied to powered-on vms when hot-plugging is enabled for the guest.",
            "type": "string"
          },
          "template_src": {
            "description": "Name of the source template to deploy from",
            "type": "string"
          },
          "username": {
            "description": "Username to connect to vcenter as.",
            "type": "string"
          },
          "validate_certs": {
            "description": "Validate SSL certs.  Note, if running on python without SSLContext support (typically, python < 2.7.9) you will have to set this to `no' as pysphere does not support validating certificates on older python. Prior to 2.1, this module would always validate on python >= 2.7.9 and never validate on python <= 2.7.8.",
            "type": "string"
          },
          "vcenter_hostname": {
            "description": "The hostname of the vcenter server the module will connect to, to create the guest.",
            "type": "string"
          },
          "vm_disk": {
            "description": "A key, value list of disks and their sizes and which datastore to keep it in.",
            "type": "string"
          },
          "vm_extra_config": {
            "description": "A key, value pair of any extra values you want set or changed in the vmx file of the VM. Useful to set advanced options on the VM.",
            "type": "string"
          },
          "vm_hardware": {
            "description": "A key, value list of VM config settings. Must include ['memory_mb', 'num_cpus', 'osid', 'scsi'].",
            "type": "string"
          },
          "vm_hw_version": {
            "description": "Desired hardware version identifier (for example, \"vmx-08\" for vms that needs to be managed with vSphere Client). Note that changing hardware version of existing vm is not supported.",
            "type": "string"
          },
          "vm_nic": {
            "description": "A key, value list of nics, their types and what network to put them on.",
            "type": "string"
          },
          "vmware_guest_facts": {
            "description": "Gather facts from vCenter on a particular VM",
            "type": "string"
          }
        },
        "required": [
          "guest",
          "password",
          "username",
          "vcenter_hostname"
        ]
      }
    },
    {
      "vyos_command": {
        "type": "object",
        "description": "Run one or more commands on VyOS devices",
        "properties": {
          "commands": {
            "description": "The ordered set of commands to execute on the remote device running VyOS. The output from the command execution is returned to the playbook.  If the `wait_for' argument is provided, the module is not returned until the condition is satisfied or the number of retries has been exceeded.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "interval": {
            "description": "Configures the interval in seconds to wait between `retries' of the command. If the command does not pass the specified conditional, the interval indicates how to long to wait before trying the command again.",
            "type": "string"
          },
          "match": {
            "description": "The `match' argument is used in conjunction with the `wait_for' argument to specify the match policy.  Valid values are `all' or `any'.  If the value is set to `all' then all conditionals in the wait_for must be satisfied.  If the value is set to `any' then only one of the values must be satisfied.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.   The value of `password' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device.",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `vyos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "retries": {
            "description": "Specifies the number of retries a command should be tried before it is considered failed.  The command is run on the target device every retry and evaluated against the `wait_for' conditionals.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. The value of `ssh_keyfile' is the path to the key used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "timeout": {
            "description": "Specifies idle timeout for the connection. Useful if the console freezes before continuing. For example when saving configurations.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          },
          "wait_for": {
            "description": "Specifies what to evaluate from the output of the command and what conditionals to apply.  This argument will cause the task to wait for a particular conditional to be true before moving forward. If the conditional is not true by the configured `retries', the task fails.  See examples.",
            "type": "string"
          }
        },
        "required": [
          "commands",
          "host"
        ]
      }
    },
    {
      "vyos_config": {
        "type": "object",
        "description": "Manage VyOS configuration on remote device",
        "properties": {
          "backup": {
            "description": "The `backup' argument will backup the current devices active configuration to the Ansible control host prior to making any changes.  The backup file will be located in the backup folder in the root of the playbook",
            "type": "string"
          },
          "comment": {
            "description": "Allows a commit description to be specified to be included when the configuration is committed.  If the configuration is not changed or committed, this argument is ignored.",
            "type": "string"
          },
          "config": {
            "description": "The `config' argument specifies the base configuration to use to compare against the desired configuration. If this value is not specified, the module will automatically retrieve the current active configuration from the remote device.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "lines": {
            "description": "The ordered set of configuration lines to be managed and compared with the existing configuration on the remote device.",
            "type": "string"
          },
          "match": {
            "description": "The `match' argument controls the method used to match against the current active configuration. By default, the desired config is matched against the active config and the deltas are loaded.  If the `match' argument is set to `none' the active configuration is ignored and the configuration is always loaded.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.   The value of `password' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device.",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `vyos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "save": {
            "description": "The `save' argument controls whether or not changes made to the active configuration are saved to disk. This is independent of committing the config.  When set to True, the active configuration is saved.",
            "type": "string"
          },
          "src": {
            "description": "The `src' argument specifies the path to the source config file to load. The source config file can either be in bracket format or set format.  The source file can include Jinja2 template variables.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. The value of `ssh_keyfile' is the path to the key used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "timeout": {
            "description": "Specifies idle timeout for the connection. Useful if the console freezes before continuing. For example when saving configurations.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": "host"
      }
    },
    {
      "vyos_facts": {
        "type": "object",
        "description": "Collect facts from remote devices running OS",
        "properties": {
          "gather_subset": {
            "description": "When supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include all, hardware, config, and interfaces.  Can specify a list of values to include a larger subset. Values can also be used with an initial `[!]' to specify that a specific subset should not be collected.",
            "type": "string"
          },
          "host": {
            "description": "Specifies the DNS host name or address for connecting to the remote device over the specified transport.  The value of host is used as the destination address for the transport.",
            "type": "string"
          },
          "password": {
            "description": "Specifies the password to use to authenticate the connection to the remote device.   The value of `password' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_PASSWORD' will be used instead.",
            "type": "string"
          },
          "port": {
            "description": "Specifies the port to use when building the connection to the remote device.",
            "type": "string"
          },
          "provider": {
            "description": "Convenience method that allows all `vyos' arguments to be passed as a dict object.  All constraints (required, choices, etc) must be met either by individual arguments or values in this dict.",
            "type": "string"
          },
          "ssh_keyfile": {
            "description": "Specifies the SSH key to use to authenticate the connection to the remote device. The value of `ssh_keyfile' is the path to the key used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_SSH_KEYFILE' will be used instead.",
            "type": "string"
          },
          "timeout": {
            "description": "Specifies idle timeout for the connection. Useful if the console freezes before continuing. For example when saving configurations.",
            "type": "string"
          },
          "username": {
            "description": "Configures the username to use to authenticate the connection to the remote device.  The value of `username' is used to authenticate the SSH session. If the value is not specified in the task, the value of environment variable `ANSIBLE _NET_USERNAME' will be used instead.",
            "type": "string"
          }
        },
        "required": "host"
      }
    },
    {
      "wait_for": {
        "type": "object",
        "description": "Waits for a condition before continuing.",
        "properties": {
          "connect_timeout": {
            "description": "maximum number of seconds to wait for a connection to happen before closing and retrying",
            "type": "string"
          },
          "delay": {
            "description": "number of seconds to wait before starting to poll",
            "type": "string"
          },
          "exclude_hosts": {
            "description": "list of hosts or IPs to ignore when looking for active TCP connections for `drained' state",
            "type": "string"
          },
          "host": {
            "description": "A resolvable hostname or IP address to wait for",
            "type": "string"
          },
          "path": {
            "description": "path to a file on the filesytem that must exist before continuing",
            "type": "string"
          },
          "port": {
            "description": "port number to poll",
            "type": "string"
          },
          "search_regex": {
            "description": "Can be used to match a string in either a file or a socket connection. Defaults to a multiline regex.",
            "type": "string"
          },
          "state": {
            "description": "either `present', `started', or `stopped', `absent', or `drained' When checking a port `started' will ensure the port is open, `stopped' will check that it is closed, `drained' will check for active connections When checking for a file or a search string `present' or `started' will ensure that the file or string is present before continuing, `absent' will check that file is absent or removed",
            "type": "string"
          },
          "timeout": {
            "description": "maximum number of seconds to wait for",
            "type": "string"
          }
        }
      }
    },
    {
      "wakeonlan": {
        "type": "object",
        "description": "Send a magic Wake-on-LAN (WoL) broadcast packet",
        "properties": {
          "broadcast": {
            "description": "Network broadcast address to use for broadcasting magic Wake-on-LAN packet",
            "type": "string"
          },
          "mac": {
            "description": "MAC address to send Wake-on-LAN broadcast packet for",
            "type": "string"
          },
          "port": {
            "description": "UDP port to use for magic Wake-on-LAN packet",
            "type": "string"
          }
        },
        "required": "mac"
      }
    },
    {
      "webfaction_app": {
        "type": "object",
        "description": "Add or remove applications on a Webfaction host",
        "properties": {
          "autostart": {
            "description": "Whether the app should restart with an autostart.cgi script",
            "type": "string"
          },
          "extra_info": {
            "description": "Any extra parameters required by the app",
            "type": "string"
          },
          "login_name": {
            "description": "The webfaction account to use",
            "type": "string"
          },
          "login_password": {
            "description": "The webfaction password to use",
            "type": "string"
          },
          "machine": {
            "description": "The machine name to use (optional for accounts with only one machine)",
            "type": "string"
          },
          "name": {
            "description": "The name of the application",
            "type": "string"
          },
          "port_open": {
            "description": "IF the port should be opened",
            "type": "string"
          },
          "state": {
            "description": "Whether the application should exist",
            "type": "string"
          },
          "type": {
            "description": "The type of application to create. See the Webfaction docs at http://docs.we bfaction.com /xmlrpc- api/apps.html for a list.",
            "type": "string"
          }
        },
        "required": [
          "login_name",
          "login_password",
          "name",
          "type"
        ]
      }
    },
    {
      "webfaction_db": {
        "type": "object",
        "description": "Add or remove a database on Webfaction",
        "properties": {
          "login_name": {
            "description": "The webfaction account to use",
            "type": "string"
          },
          "login_password": {
            "description": "The webfaction password to use",
            "type": "string"
          },
          "machine": {
            "description": "The machine name to use (optional for accounts with only one machine)",
            "type": "string"
          },
          "name": {
            "description": "The name of the database",
            "type": "string"
          },
          "password": {
            "description": "The password for the new database user.",
            "type": "string"
          },
          "state": {
            "description": "Whether the database should exist",
            "type": "string"
          },
          "type": {
            "description": "The type of database to create.",
            "type": "string"
          }
        },
        "required": [
          "login_name",
          "login_password",
          "name",
          "type"
        ]
      }
    },
    {
      "webfaction_domain": {
        "type": "object",
        "description": "Add or remove domains and subdomains on Webfaction",
        "properties": {
          "login_name": {
            "description": "The webfaction account to use",
            "type": "string"
          },
          "login_password": {
            "description": "The webfaction password to use",
            "type": "string"
          },
          "name": {
            "description": "The name of the domain",
            "type": "string"
          },
          "state": {
            "description": "Whether the domain should exist",
            "type": "string"
          },
          "subdomains": {
            "description": "Any subdomains to create.",
            "type": "string"
          }
        },
        "required": [
          "login_name",
          "login_password",
          "name"
        ]
      }
    },
    {
      "webfaction_mailbox": {
        "type": "object",
        "description": "Add or remove mailboxes on Webfaction",
        "properties": {
          "login_name": {
            "description": "The webfaction account to use",
            "type": "string"
          },
          "login_password": {
            "description": "The webfaction password to use",
            "type": "string"
          },
          "mailbox_name": {
            "description": "The name of the mailbox",
            "type": "string"
          },
          "mailbox_password": {
            "description": "The password for the mailbox",
            "type": "string"
          },
          "state": {
            "description": "Whether the mailbox should exist",
            "type": "string"
          }
        },
        "required": [
          "login_name",
          "login_password",
          "mailbox_name",
          "mailbox_password"
        ]
      }
    },
    {
      "webfaction_site": {
        "type": "object",
        "description": "Add or remove a website on a Webfaction host",
        "properties": {
          "host": {
            "description": "The webfaction host on which the site should be created.",
            "type": "string"
          },
          "https": {
            "description": "Whether or not to use HTTPS",
            "type": "string"
          },
          "login_name": {
            "description": "The webfaction account to use",
            "type": "string"
          },
          "login_password": {
            "description": "The webfaction password to use",
            "type": "string"
          },
          "name": {
            "description": "The name of the website",
            "type": "string"
          },
          "site_apps": {
            "description": "A mapping of URLs to apps",
            "type": "string"
          },
          "state": {
            "description": "Whether the website should exist",
            "type": "string"
          },
          "subdomains": {
            "description": "A list of subdomains associated with this site.",
            "type": "string"
          }
        },
        "required": [
          "host",
          "login_name",
          "login_password",
          "name"
        ]
      }
    },
    {
      "win_acl": {
        "type": "object",
        "description": "Set file/directory permissions for a system user or group.",
        "properties": {
          "inherit": {
            "description": "Inherit flags on the ACL rules.  Can be specified as a comma separated list (Ex. \"Contai nerInherit, ObjectInherit\"). For more information on the choices see MSDN InheritanceFlags Enumeration.",
            "type": "string"
          },
          "path": {
            "description": "File or Directory",
            "type": "string"
          },
          "propagation": {
            "description": "Propagation flag on the ACL rules.  For more information on the choices see MSDN PropagationFlags Enumeration.",
            "type": "string"
          },
          "rights": {
            "description": "The rights/permissions that are to be allowed/denyed for the specified user or group for the given src file or directory.  Can be entered as a comma separated list (Ex. \"Modify, Delete, ExecuteFile\"). For more information on the choices see MSDN FileSystemRights Enumeration.",
            "type": "string"
          },
          "state": {
            "description": "Specify whether to add `present' or remove `absent' the specified access rule",
            "type": "string"
          },
          "type": {
            "description": "Specify whether to allow or deny the rights specified",
            "type": "string"
          },
          "user": {
            "description": "User or Group to add specified rights to act on src file/folder",
            "type": "string"
          }
        },
        "required": [
          "path",
          "rights",
          "type",
          "user"
        ]
      }
    },
    {
      "win_acl_inheritance": {
        "type": "object",
        "description": "Change ACL inheritance",
        "properties": {
          "path": {
            "description": "Path to be used for changing inheritance",
            "type": "string"
          },
          "reorganize": {
            "description": "For P(state) = `absent', indicates if the inherited ACE's should be copied from the parent directory. This is necessary (in combination with removal) for a simple ACL instead of using multiple ACE deny entries. For P(state) = `present', indicates if the inherited ACE's should be deduplicated compared to the parent directory. This removes complexity of the ACL structure.",
            "type": "string"
          },
          "state": {
            "description": "Specify whether to enable `present' or disable `absent' ACL inheritance",
            "type": "string"
          }
        },
        "required": "path"
      }
    },
    {
      "win_chocolatey": {
        "type": "object",
        "description": "Installs packages using chocolatey",
        "properties": {
          "allow_empty_checksums": {
            "description": "Allow empty Checksums to be used",
            "type": "string"
          },
          "force": {
            "description": "Forces install of the package (even if it already exists). Using Force will cause ansible to always report that a change was made",
            "type": "string"
          },
          "ignore_checksums": {
            "description": "Ignore Checksums",
            "type": "string"
          },
          "ignore_dependencies": {
            "description": "Ignore dependencies, only install/upgrade the package itself",
            "type": "string"
          },
          "install_args": {
            "description": "Arguments to pass to the native installer",
            "type": "string"
          },
          "name": {
            "description": "Name of the package to be installed",
            "type": "string"
          },
          "params": {
            "description": "Parameters to pass to the package",
            "type": "string"
          },
          "source": {
            "description": "Specify source rather than using default chocolatey repository",
            "type": "string"
          },
          "state": {
            "description": "State of the package on the system",
            "type": "string"
          },
          "upgrade": {
            "description": "If package is already installed it, try to upgrade to the latest version or to the specified version",
            "type": "string"
          },
          "version": {
            "description": "Specific version of the package to be installed Ignored when state == 'absent'",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "win_command": {
        "type": "object",
        "description": "Executes a command on a remote Windows node",
        "properties": {
          "chdir": {
            "description": "set the specified path as the current working directory before executing a command",
            "type": "string"
          },
          "creates": {
            "description": "a path or path filter pattern; when the referenced path exists on the target host, the task will be skipped.",
            "type": "string"
          },
          "free_form": {
            "description": "the win_command module takes a free form command to run.  There is no parameter actually named 'free form'. See the examples!",
            "type": "string"
          },
          "removes": {
            "description": "a path or path filter pattern; when the referenced path *does not* exist on the target host, the task will be skipped.",
            "type": "string"
          }
        },
        "required": "free_form"
      }
    },
    {
      "win_copy": {
        "type": "object",
        "description": "Copies files to remote locations on windows hosts.",
        "properties": {
          "dest": {
            "description": "Remote absolute path where the file should be copied to. If src is a directory, this must be a directory too. Use \\ for path separators.",
            "type": "string"
          },
          "src": {
            "description": "Local path to a file to copy to the remote server; can be absolute or relative. If path is a directory, it is copied recursively. In this case, if path ends with \"/\", only inside contents of that directory are copied to destination. Otherwise, if it does not end with \"/\", the directory itself with all contents is copied. This behavior is similar to Rsync.",
            "type": "string"
          }
        },
        "required": "dest"
      }
    },
    {
      "win_environment": {
        "type": "object",
        "description": "Modifies environment variables on windows hosts.",
        "properties": {
          "level": {
            "description": "The level at which to set the environment variable. Use 'machine' to set for all users. Use 'user' to set for the current user that ansible is connected as. Use 'process' to set for the current process. Probably not that useful.",
            "type": "string"
          },
          "name": {
            "description": "The name of the environment variable",
            "type": "string"
          },
          "state": {
            "description": "present to ensure environment variable is set, or absent to ensure it is removed",
            "type": "string"
          },
          "value": {
            "description": "The value to store in the environment variable. Can be omitted for state=absent",
            "type": "string"
          }
        },
        "required": [
          "level",
          "name"
        ]
      }
    },
    {
      "win_feature": {
        "type": "object",
        "description": "Installs and uninstalls Windows Features on Windows Server",
        "properties": {
          "include_management_tools": {
            "description": "Adds the corresponding management tools to the specified feature",
            "type": "string"
          },
          "include_sub_features": {
            "description": "Adds all subfeatures of the specified feature",
            "type": "string"
          },
          "name": {
            "description": "Names of roles or features to install as a single feature or a comma-separated list of features",
            "type": "string"
          },
          "restart": {
            "description": "Restarts the computer automatically when installation is complete, if restarting is required by the roles or features installed.",
            "type": "string"
          },
          "source": {
            "description": "Specify a source to install the feature from",
            "type": "string"
          },
          "state": {
            "description": "State of the features or roles on the system",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "win_file": {
        "type": "object",
        "description": "Creates, touches or removes files or directories.",
        "properties": {
          "path": {
            "description": "path to the file being managed.  Aliases: `dest', `name'",
            "type": "string"
          },
          "state": {
            "description": "If `directory', all immediate subdirectories will be created if they do not exist. If `file', the file will NOT be created if it does not exist, see the [copy] or [template] module if you want that behavior.  If `absent', directories will be recursively deleted, and files will be removed. If `touch', an empty file will be created if the c(path) does not exist, while an existing file or directory will receive updated file access and modification times (similar to the way `touch` works from the command line).",
            "type": "string"
          }
        },
        "required": "path"
      }
    },
    {
      "win_file_version": {
        "type": "object",
        "description": "Get DLL or EXE file build version",
        "properties": {
          "path": {
            "description": "File to get version(provide absolute path)",
            "type": "string"
          }
        },
        "required": "path"
      }
    },
    {
      "win_firewall_rule": {
        "type": "object",
        "description": "Windows firewall automation",
        "properties": {
          "action": {
            "description": "what to do with the items this rule is for",
            "type": "string"
          },
          "description": {
            "description": "description for the firewall rule",
            "type": "string"
          },
          "direction": {
            "description": "is this rule for inbound or outbound trafic",
            "type": "string"
          },
          "enable": {
            "description": "is this firewall rule enabled or disabled",
            "type": "string"
          },
          "force": {
            "description": "Enforces the change if a rule with different values exists",
            "type": "string"
          },
          "localip": {
            "description": "the local ip address this rule applies to",
            "type": "string"
          },
          "localport": {
            "description": "the local port this rule applies to",
            "type": "string"
          },
          "name": {
            "description": "the rules name",
            "type": "string"
          },
          "profile": {
            "description": "the profile this rule applies to, e.g. Domain,Private,Pu blic",
            "type": "string"
          },
          "program": {
            "description": "the program this rule applies to",
            "type": "string"
          },
          "protocol": {
            "description": "the protocol this rule applies to",
            "type": "string"
          },
          "remoteip": {
            "description": "the remote ip address/range this rule applies to",
            "type": "string"
          },
          "remoteport": {
            "description": "the remote port this rule applies to",
            "type": "string"
          },
          "service": {
            "description": "the service this rule applies to",
            "type": "string"
          },
          "state": {
            "description": "should this rule be added or removed",
            "type": "string"
          }
        },
        "required": [
          "action",
          "direction",
          "name",
          "state"
        ]
      }
    },
    {
      "win_get_url": {
        "type": "object",
        "description": "Fetches a file from a given URL",
        "properties": {
          "dest": {
            "description": "The absolute path of the location to save the file at the URL. Be sure to include a filename and extension as appropriate.",
            "type": "string"
          },
          "force": {
            "description": "If `yes', will always download the file.  If `no', will only download the file if it does not exist or the remote file has been modified more recently than the local file.  This works by sending an http HEAD request to retrieve last modified time of the requested resource, so for this to work, the remote web server must support HEAD requests.",
            "type": "string"
          },
          "password": {
            "description": "Basic authentication password",
            "type": "string"
          },
          "proxy_password": {
            "description": "Proxy authentication password",
            "type": "string"
          },
          "proxy_url": {
            "description": "The full URL of the proxy server to download through.",
            "type": "string"
          },
          "proxy_username": {
            "description": "Proxy authentication username",
            "type": "string"
          },
          "skip_certificate_validation": {
            "description": "Skip SSL certificate validation if true",
            "type": "string"
          },
          "url": {
            "description": "The full URL of a file to download",
            "type": "string"
          },
          "username": {
            "description": "Basic authentication username",
            "type": "string"
          }
        },
        "required": [
          "dest",
          "url"
        ]
      }
    },
    {
      "win_group": {
        "type": "object",
        "description": "Add and remove local groups",
        "properties": {
          "description": {
            "description": "Description of the group",
            "type": "string"
          },
          "name": {
            "description": "Name of the group",
            "type": "string"
          },
          "state": {
            "description": "Create or remove the group",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "win_iis_virtualdirectory": {
        "type": "object",
        "description": "Configures a virtual directory in IIS.",
        "properties": {
          "application": {
            "description": "The application under which the virtual directory is created or exists.",
            "type": "string"
          },
          "name": {
            "description": "The name of the virtual directory to create or remove",
            "type": "string"
          },
          "physical_path": {
            "description": "The physical path to the folder in which the new virtual directory is created. The specified folder must already exist.",
            "type": "string"
          },
          "site": {
            "description": "The site name under which the virtual directory is created or exists.",
            "type": "string"
          },
          "state": {
            "description": "Whether to add or remove the specified virtual directory",
            "type": "string"
          }
        },
        "required": [
          "name",
          "site"
        ]
      }
    },
    {
      "win_iis_webapplication": {
        "type": "object",
        "description": "Configures a IIS Web application.",
        "properties": {
          "application_pool": {
            "description": "The application pool in which the new site executes.",
            "type": "string"
          },
          "name": {
            "description": "Name of the Web applicatio",
            "type": "string"
          },
          "physical_path": {
            "description": "The physical path on the remote host to use for the new applicatiojn. The specified folder must already exist.",
            "type": "string"
          },
          "site": {
            "description": "Name of the site on which the application is created.",
            "type": "string"
          },
          "state": {
            "description": "State of the web application",
            "type": "string"
          }
        },
        "required": [
          "name",
          "site"
        ]
      }
    },
    {
      "win_iis_webapppool": {
        "type": "object",
        "description": "Configures a IIS Web Application Pool.",
        "properties": {
          "attributes": {
            "description": "Application Pool attributes from string where attributes are seperated by a pipe and attribute name/values by colon Ex. \"foo:1|bar:2\"",
            "type": "string"
          },
          "name": {
            "description": "Names of application pool",
            "type": "string"
          },
          "state": {
            "description": "State of the binding",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "win_iis_webbinding": {
        "type": "object",
        "description": "Configures a IIS Web site.",
        "properties": {
          "certificate_hash": {
            "description": "Certificate hash for the SSL binding. The certificate hash is the unique identifier for the certificate.",
            "type": "string"
          },
          "certificate_store_name": {
            "description": "Name of the certificate store where the certificate for the binding is located.",
            "type": "string"
          },
          "host_header": {
            "description": "The host header to bind to / use for the new site.",
            "type": "string"
          },
          "ip": {
            "description": "The IP address to bind to / use for the new site.",
            "type": "string"
          },
          "name": {
            "description": "Names of web site",
            "type": "string"
          },
          "port": {
            "description": "The port to bind to / use for the new site.",
            "type": "string"
          },
          "protocol": {
            "description": "The protocol to be used for the Web binding (usually HTTP, HTTPS, or FTP).",
            "type": "string"
          },
          "state": {
            "description": "State of the binding",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "win_iis_website": {
        "type": "object",
        "description": "Configures a IIS Web site.",
        "properties": {
          "application_pool": {
            "description": "The application pool in which the new site executes.",
            "type": "string"
          },
          "hostname": {
            "description": "The host header to bind to / use for the new site.",
            "type": "string"
          },
          "ip": {
            "description": "The IP address to bind to / use for the new site.",
            "type": "string"
          },
          "name": {
            "description": "Names of web site",
            "type": "string"
          },
          "parameters": {
            "description": "Custom site Parameters from string where properties are seperated by a pipe and property name/values by colon Ex. \"foo:1|bar:2\"",
            "type": "string"
          },
          "physical_path": {
            "description": "The physical path on the remote host to use for the new site. The specified folder must already exist.",
            "type": "string"
          },
          "port": {
            "description": "The port to bind to / use for the new site.",
            "type": "string"
          },
          "site_id": {
            "description": "Explicitly set the IIS numeric ID for a site. Note that this value cannot be changed after the website has been created.",
            "type": "string"
          },
          "ssl": {
            "description": "Enables HTTPS binding on the site..",
            "type": "string"
          },
          "state": {
            "description": "State of the web site",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "win_lineinfile": {
        "type": "object",
        "description": "Ensure a particular line is in a file, or replace an existing line using a back-referenced regular expression.",
        "properties": {
          "backrefs": {
            "description": "Used with `state=present'. If set, line can contain backreferences (both positional and named) that will get populated if the `regexp' matches. This flag changes the operation of the module slightly; `insertbefore' and `insertafter' will be ignored, and if the `regexp' doesn't match anywhere in the file, the file will be left unchanged. If the `regexp' does match, the last matching line will be replaced by the expanded line parameter.",
            "type": "string"
          },
          "backup": {
            "description": "Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.",
            "type": "string"
          },
          "create": {
            "description": "Used with `state=present'. If specified, the file will be created if it does not already exist. By default it will fail if the file is missing.",
            "type": "string"
          },
          "dest": {
            "description": "The path of the file to modify. Note that the Windows path delimiter '' must be escaped as '\\' (see examples below)",
            "type": "string"
          },
          "encoding": {
            "description": "Specifies the encoding of the source text file to operate on (and thus what the output encoding will be). The default of `auto' will cause the module to auto-detect the encoding of the source file and ensure that the modified file is written with the same encoding. An explicit encoding can be passed as a string that is a valid value to pass to the .NET framework System. Text.Encoding.Get Encoding() method - see https://msd n.microsoft.com /en-us/library/sy stem.text.encodin g%28v=vs.110%29.a spx. This is mostly useful with `create=yes' if you want to create a new file with a specific encoding. If `create=yes' is specified without a specific encoding, the default encoding (UTF-8, no BOM) will be used.",
            "type": "string"
          },
          "insertafter": {
            "description": "Used with `state=present'. If specified, the line will be inserted after the last match of specified regular expression. A special value is available; `EOF' for inserting the line at the end of the file. If specified regular expression has no matches, EOF will be used instead. May not be used with `backrefs'.",
            "type": "string"
          },
          "insertbefore": {
            "description": "Used with `state=present'. If specified, the line will be inserted before the last match of specified regular expression. A value is available; `BOF' for inserting the line at the beginning of the file. If specified regular expression has no matches, the line will be inserted at the end of the file.  May not be used with `backrefs'.",
            "type": "string"
          },
          "line": {
            "description": "Required for `state=present'. The line to insert/replace into the file. If `backrefs' is set, may contain backreferences that will get expanded with the `regexp' capture groups if the regexp matches.",
            "type": "string"
          },
          "newline": {
            "description": "Specifies the line separator style to use for the modified file. This defaults to the windows line separator ( ). Note that the indicated line separator will be used for file output regardless of the original line separator that appears in the input file.",
            "type": "string"
          },
          "regexp": {
            "description": "The regular expression to look for in every line of the file. For `state=present', the pattern to replace if found; only the last line found will be replaced. For `state=absent', the pattern of the line to remove.  Uses .NET compatible regular expressions; see  https://msdn.micr osoft.com/en-us/l ibrary/hs600312%2 8v=vs.110%29.aspx .",
            "type": "string"
          },
          "state": {
            "description": "Whether the line should be there or not.",
            "type": "string"
          },
          "validate": {
            "description": "Validation to run before copying into place. Use %s in the command to indicate the current file to validate. The command is passed securely so shell features like expansion and pipes won't work.",
            "type": "string"
          }
        },
        "required": "dest"
      }
    },
    {
      "win_msi": {
        "type": "object",
        "description": "Installs and uninstalls Windows MSI files",
        "properties": {
          "creates": {
            "description": "Path to a file created by installing the MSI to prevent from attempting to reinstall the package on every run",
            "type": "string"
          },
          "extra_args": {
            "description": "Additional arguments to pass to the msiexec.exe command",
            "type": "string"
          },
          "path": {
            "description": "File system path to the MSI file to install",
            "type": "string"
          },
          "state": {
            "description": "Whether the MSI file should be installed or uninstalled",
            "type": "string"
          },
          "wait": {
            "description": "Specify whether to wait for install or uninstall to complete before continuing.",
            "type": "string"
          }
        },
        "required": "path"
      }
    },
    {
      "win_nssm": {
        "type": "object",
        "description": "NSSM - the Non-Sucking Service Manager",
        "properties": {
          "app_parameters": {
            "description": "Parameters to be passed to the application when it starts",
            "type": "string"
          },
          "application": {
            "description": "The application binary to run as a service Specify this whenever the service may need to be installed (state: present, started, stopped, restarted) Note that the application name must look like the following, if the directory includes spaces: nssm install service \"c:\\Program Files\\app.exe\\\" \"C:\\Path with spaces\\\" See commit 0b386fc198 4ab74ee59b7bed14b 7e8f57212c22b in the nssm.git project for more info (https://git .nssm.cc/?p=nssm. git;a=commit;h=0b 386fc1984ab74ee59 b7bed14b7e8f57212 c22b)",
            "type": "string"
          },
          "dependencies": {
            "description": "Service dependencies that has to be started to trigger startup, separated by comma.",
            "type": "string"
          },
          "name": {
            "description": "Name of the service to operate on",
            "type": "string"
          },
          "password": {
            "description": "Password to be used for service startup",
            "type": "string"
          },
          "start_mode": {
            "description": "If `auto' is selected, the service will start at bootup. `manual' means that the service will start only when another service needs it. `disabled' means that the service will stay off, regardless if it is needed or not.",
            "type": "string"
          },
          "state": {
            "description": "State of the service on the system Note that NSSM actions like \"pause\", \"continue\", \"rotate\" do not fit the declarative style of ansible, so these should be implemented via the ansible command module",
            "type": "string"
          },
          "stderr_file": {
            "description": "Path to receive error output",
            "type": "string"
          },
          "stdout_file": {
            "description": "Path to receive output",
            "type": "string"
          },
          "user": {
            "description": "User to be used for service startup",
            "type": "string"
          }
        },
        "required": [
          "name",
          "start_mode"
        ]
      }
    },
    {
      "win_owner": {
        "type": "object",
        "description": "Set owner",
        "properties": {
          "path": {
            "description": "Path to be used for changing owner",
            "type": "string"
          },
          "recurse": {
            "description": "Indicates if the owner should be changed recursively",
            "type": "string"
          },
          "user": {
            "description": "Name to be used for changing owner",
            "type": "string"
          }
        },
        "required": [
          "path",
          "user"
        ]
      }
    },
    {
      "win_package": {
        "type": "object",
        "description": "Installs/Uninstalls an installable package, either from local file system or url",
        "properties": {
          "arguments": {
            "description": "Any arguments the installer needs",
            "type": "string"
          },
          "name": {
            "description": "Name of the package, if name isn't specified the path will be used for log messages",
            "type": "string"
          },
          "path": {
            "description": "Location of the package to be installed (either on file system, network share or url)",
            "type": "string"
          },
          "product_id": {
            "description": "product id of the installed package (used for checking if already installed) You can find product ids for installed programs in the windows registry either in `HKLM:S oftware\\Microsoft \\Windows\\CurrentV ersion\\Uninstall' or for 32 bit programs `HKLM:So ftware\\Wow6432Nod e\\Microsoft\\Windo ws\\CurrentVersion \\Uninstall''",
            "type": "string"
          },
          "state": {
            "description": "Install or Uninstall",
            "type": "string"
          },
          "user_name": {
            "description": "Username of an account with access to the package if its located on a file share. Only needed if the winrm user doesn't have access to the package. Also specify user_password for this to function properly.",
            "type": "string"
          },
          "user_password": {
            "description": "Password of an account with access to the package if its located on a file share. Only needed if the winrm user doesn't have access to the package. Also specify user_name for this to function properly.",
            "type": "string"
          }
        },
        "required": [
          "path",
          "product_id"
        ]
      }
    },
    {
      "win_ping": {
        "type": "object",
        "description": "A windows version of the classic ping module.",
        "properties": {
          "data": {
            "description": "Alternate data to return instead of 'pong'",
            "type": "string"
          }
        }
      }
    },
    {
      "win_reboot": {
        "type": "object",
        "description": "Reboot a windows machine",
        "properties": {
          "connect_timeout_sec": {
            "description": "Maximum seconds to wait for a single successful TCP connection to the WinRM endpoint before trying again",
            "type": "string"
          },
          "pre_reboot_delay_sec": {
            "description": "Seconds for shutdown to wait before requesting reboot",
            "type": "string"
          },
          "reboot_timeout_sec": {
            "description": "Maximum seconds to wait for machine to re-appear on the network and respond to a test command This timeout is evaluated separately for both network appearance and test command success (so maximum clock time is actually twice this value)",
            "type": "string"
          },
          "shutdown_timeout_sec": {
            "description": "Maximum seconds to wait for shutdown to occur Increase this timeout for very slow hardware, large update applications, etc",
            "type": "string"
          },
          "test_command": {
            "description": "Command to expect success for to determine the machine is ready for management",
            "type": "string"
          }
        }
      }
    },
    {
      "win_regedit": {
        "type": "object",
        "description": "Add, Edit, or Remove Registry Keys and Values",
        "properties": {
          "data": {
            "description": "Registry Value Data.  Binary data should be expressed a yaml byte array or as comma separated hex values.  An easy way to generate this is to run `regedit.exe' and use the `Export' option to save the registry values to a file. In the exported file binary values will look like `hex:be,ef,b e,ef'.  The `hex:' prefix is optional.",
            "type": "string"
          },
          "datatype": {
            "description": "Registry Value Data Type",
            "type": "string"
          },
          "key": {
            "description": "Name of Registry Key",
            "type": "string"
          },
          "state": {
            "description": "State of Registry Value",
            "type": "string"
          },
          "value": {
            "description": "Name of Registry Value",
            "type": "string"
          }
        },
        "required": [
          "key",
          "value"
        ]
      }
    },
    {
      "win_regmerge": {
        "type": "object",
        "description": "Merges the contents of a registry file into the windows registry",
        "properties": {
          "compare_key": {
            "description": "The parent key to use when comparing the contents of the registry to the contents of the file.  Needs to be in HKLM or HKCU part of registry.  Use a PS-Drive style path for example HKLM:\\SOFTWARE not HKEY_LOCAL_MA CHINE\\SOFTWARE If not supplied, or the registry key is not found, no comparison will be made, and the module will report changed.",
            "type": "string"
          },
          "path": {
            "description": "The full path including file name to the registry file on the remote machine to be merged",
            "type": "string"
          }
        },
        "required": "path"
      }
    },
    {
      "win_robocopy": {
        "type": "object",
        "description": "Synchronizes the contents of two directories using Robocopy.",
        "properties": {
          "dest": {
            "description": "Destination file/directory to sync (Will receive contents of src).",
            "type": "string"
          },
          "flags": {
            "description": "Directly supply Robocopy flags. If set, purge and recurse will be ignored.",
            "type": "string"
          },
          "purge": {
            "description": "Deletes any files/directories found in the destination that do not exist in the source (Toggles the `/purge` flag to RoboCopy). If \"flags\" is set, this will be ignored.",
            "type": "string"
          },
          "recurse": {
            "description": "Includes all subdirectories (Toggles the `/e` flag to RoboCopy). If \"flags\" is set, this will be ignored.",
            "type": "string"
          },
          "src": {
            "description": "Source file/directory to sync.",
            "type": "string"
          }
        },
        "required": [
          "dest",
          "src"
        ]
      }
    },
    {
      "win_scheduled_task": {
        "type": "object",
        "description": "Manage scheduled tasks",
        "properties": {
          "argument": {
            "description": "Arguments to provide scheduled task action",
            "type": "string"
          },
          "days_of_week": {
            "description": "Days of the week to run a weekly task, not idempotent",
            "type": "string"
          },
          "description": {
            "description": "The description for the scheduled task",
            "type": "string"
          },
          "enabled": {
            "description": "Enable/disable the task",
            "type": "string"
          },
          "execute": {
            "description": "Command the scheduled task should execute",
            "type": "string"
          },
          "frequency": {
            "description": "The frequency of the command, not idempotent",
            "type": "string"
          },
          "name": {
            "description": "Name of the scheduled task",
            "type": "string"
          },
          "path": {
            "description": "Folder path of scheduled task",
            "type": "string"
          },
          "state": {
            "description": "State that the task should become",
            "type": "string"
          },
          "time": {
            "description": "Time to execute scheduled task, not idempotent",
            "type": "string"
          },
          "user": {
            "description": "User to run scheduled task as",
            "type": "string"
          }
        },
        "required": [
          "name",
          "state"
        ]
      }
    },
    {
      "win_service": {
        "type": "object",
        "description": "Manages Windows services",
        "properties": {
          "name": {
            "description": "Name of the service",
            "type": "string"
          },
          "start_mode": {
            "description": "Set the startup type for the service",
            "type": "string"
          },
          "state": {
            "description": "`started'/`stopped' are idempotent actions that will not run commands unless necessary. `restarted' will always bounce the service.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "win_share": {
        "type": "object",
        "description": "Manage Windows shares",
        "properties": {
          "change": {
            "description": "Specify user list that should get read and write access on share, separated by comma.",
            "type": "string"
          },
          "deny": {
            "description": "Specify user list that should get no access, regardless of implied access on share, separated by comma.",
            "type": "string"
          },
          "description": {
            "description": "Share description",
            "type": "string"
          },
          "full": {
            "description": "Specify user list that should get full access on share, separated by comma.",
            "type": "string"
          },
          "list": {
            "description": "Specify whether to allow or deny file listing, in case user got no permission on share",
            "type": "string"
          },
          "name": {
            "description": "Share name",
            "type": "string"
          },
          "path": {
            "description": "Share directory",
            "type": "string"
          },
          "read": {
            "description": "Specify user list that should get read access on share, separated by comma.",
            "type": "string"
          },
          "state": {
            "description": "Specify whether to add `present' or remove `absent' the specified share",
            "type": "string"
          }
        },
        "required": [
          "name",
          "path"
        ]
      }
    },
    {
      "win_shell": {
        "type": "object",
        "description": "Execute shell commands on target hosts.",
        "properties": {
          "chdir": {
            "description": "set the specified path as the current working directory before executing a command",
            "type": "string"
          },
          "creates": {
            "description": "a path or path filter pattern; when the referenced path exists on the target host, the task will be skipped.",
            "type": "string"
          },
          "executable": {
            "description": "change the shell used to execute the command (eg, `cmd'). The target shell must accept a `/c' parameter followed by the raw command line to be executed.",
            "type": "string"
          },
          "free_form": {
            "description": "the win_shell module takes a free form command to run.  There is no parameter actually named 'free form'. See the examples!",
            "type": "string"
          },
          "removes": {
            "description": "a path or path filter pattern; when the referenced path *does not* exist on the target host, the task will be skipped.",
            "type": "string"
          }
        },
        "required": "free_form"
      }
    },
    {
      "win_stat": {
        "type": "object",
        "description": "returns information about a Windows file",
        "properties": {
          "get_checksum": {
            "description": "Whether to return a checksum of the file (only sha1 currently supported)",
            "type": "string"
          },
          "get_md5": {
            "description": "Whether to return the checksum sum of the file. As of Ansible 1.9 this is no longer a MD5, but a SHA1 instead.",
            "type": "string"
          },
          "path": {
            "description": "The full path of the file/object to get the facts of; both forward and back slashes are accepted.",
            "type": "string"
          }
        },
        "required": "path"
      }
    },
    {
      "win_template": {
        "type": "object",
        "description": "Templates a file out to a remote server.",
        "properties": {
          "dest": {
            "description": "Location to render the template to on the remote machine.",
            "type": "string"
          },
          "src": {
            "description": "Path of a Jinja2 formatted template on the local server. This can be a relative or absolute path.",
            "type": "string"
          }
        },
        "required": [
          "dest",
          "src"
        ]
      }
    },
    {
      "win_timezone": {
        "type": "object",
        "description": "Sets Windows machine timezone",
        "properties": {
          "timezone": {
            "description": "Timezone to set to.  Example Central Standard Time",
            "type": "string"
          }
        },
        "required": "timezone"
      }
    },
    {
      "win_unzip": {
        "type": "object",
        "description": "Unzips compressed files and archives on the Windows node",
        "properties": {
          "creates": {
            "description": "If this file or directory exists the specified src will not be extracted.",
            "type": "string"
          },
          "dest": {
            "description": "Destination of zip file (provide absolute path of directory). If it does not exist, the directory will be created.",
            "type": "string"
          },
          "recurse": {
            "description": "Recursively expand zipped files within the src file.",
            "type": "string"
          },
          "rm": {
            "description": "Remove the zip file, after unzipping",
            "type": "string"
          },
          "src": {
            "description": "File to be unzipped (provide absolute path)",
            "type": "string"
          }
        },
        "required": [
          "dest",
          "src"
        ]
      }
    },
    {
      "win_updates": {
        "type": "object",
        "description": "Download and install Windows updates",
        "properties": {
          "category_names": {
            "description": "A scalar or list of categories to install updates from",
            "type": "string"
          },
          "log_path": {
            "description": "If set, win_updates will append update progress to the specified file. The directory must already exist.",
            "type": "string"
          },
          "state": {
            "description": "Controls whether found updates are returned as a list or actually installed. This module also supports Ansible check mode, which has the same effect as setting state=searched",
            "type": "string"
          }
        }
      }
    },
    {
      "win_uri": {
        "type": "object",
        "description": "Interacts with webservices.",
        "properties": {
          "body": {
            "description": "The body of the HTTP request/response to the web service.",
            "type": "string"
          },
          "content_type": {
            "description": "Sets the \"Content-Type\" header.",
            "type": "string"
          },
          "headers": {
            "description": "Key Value pairs for headers. Example \"Host: www.somesite.com\"",
            "type": "string"
          },
          "method": {
            "description": "The HTTP Method of the request or response.",
            "type": "string"
          },
          "url": {
            "description": "HTTP or HTTPS URL in the form of (http|https)://ho st.domain:port/pa th",
            "type": "string"
          },
          "use_basic_parsing": {
            "description": "This module relies upon 'Invoke-WebRequest', which by default uses the Internet Explorer Engine to parse a webpage. There's an edge-case where if a user hasn't run IE before, this will fail. The only advantage to using the Internet Explorer praser is that you can traverse the DOM in a powershell script. That isn't useful for Ansible, so by default we toggle 'UseBasicParsing' . However, you can toggle that off here.",
            "type": "string"
          }
        }
      }
    },
    {
      "win_user": {
        "type": "object",
        "description": "Manages local Windows user accounts",
        "properties": {
          "account_disabled": {
            "description": "`yes' will disable the user account.  `no' will clear the disabled flag.",
            "type": "string"
          },
          "account_locked": {
            "description": "`no' will unlock the user account if locked.",
            "type": "string"
          },
          "description": {
            "description": "Description of the user",
            "type": "string"
          },
          "fullname": {
            "description": "Full name of the user",
            "type": "string"
          },
          "groups": {
            "description": "Adds or removes the user from this comma- separated lis of groups, depending on the value of `groups_action'. When `groups_action' is `replace' and `groups' is set to the empty string ('groups='), the user is removed from all groups.",
            "type": "string"
          },
          "groups_action": {
            "description": "If `replace', the user is added as a member of each group in `groups' and removed from any other groups.  If `add', the user is added to each group in `groups' where not already a member.  If `remove', the user is removed from each group in `groups'.",
            "type": "string"
          },
          "name": {
            "description": "Name of the user to create, remove or modify.",
            "type": "string"
          },
          "password": {
            "description": "Optionally set the user's password to this (plain text) value.",
            "type": "string"
          },
          "password_expired": {
            "description": "`yes' will require the user to change their password at next login. `no' will clear the expired password flag.",
            "type": "string"
          },
          "password_never_expires": {
            "description": "`yes' will set the password to never expire. `no' will allow the password to expire.",
            "type": "string"
          },
          "state": {
            "description": "When `present', creates or updates the user account.  When `absent', removes the user account if it exists. When `query' (new in 1.9), retrieves the user account details without making any changes.",
            "type": "string"
          },
          "update_password": {
            "description": "`always' will update passwords if they differ. `on_create' will only set the password for newly created users.",
            "type": "string"
          },
          "user_cannot_change_password": {
            "description": "`yes' will prevent the user from changing their password.  `no' will allow the user to change their password.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "win_webpicmd": {
        "type": "object",
        "description": "Installs packages using Web Platform Installer command-line",
        "properties": {
          "name": {
            "description": "Name of the package to be installed",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "xattr": {
        "type": "object",
        "description": "set/retrieve extended attributes",
        "properties": {
          "follow": {
            "description": "if yes, dereferences symlinks and sets/gets attributes on symlink target, otherwise acts on symlink itself.",
            "type": "string"
          },
          "key": {
            "description": "The name of a specific Extended attribute key to set/retrieve",
            "type": "string"
          },
          "name": {
            "description": "The full path of the file/object to get the facts of",
            "type": "string"
          },
          "state": {
            "description": "defines which state you want to do. `read' retrieves the current value for a `key' (default) `present' sets `name' to `value', default if value is set `all' dumps all data `keys' retrieves all keys `absent' deletes the key",
            "type": "string"
          },
          "value": {
            "description": "The value to set the named name/key to, it automatically sets the `state' to 'set'",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "yum": {
        "type": "object",
        "description": "Manages packages with the `yum' package manager",
        "properties": {
          "conf_file": {
            "description": "The remote yum configuration file to use for the transaction.",
            "type": "string"
          },
          "disable_gpg_check": {
            "description": "Whether to disable the GPG checking of signatures of packages being installed. Has an effect only if state is `present' or `latest'.",
            "type": "string"
          },
          "disablerepo": {
            "description": "`Repoid' of repositories to disable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a \",\".",
            "type": "string"
          },
          "enablerepo": {
            "description": "`Repoid' of repositories to enable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a \",\".",
            "type": "string"
          },
          "exclude": {
            "description": "Package name(s) to exclude when state=present, or latest",
            "type": "string"
          },
          "list": {
            "description": "Various (non-idempotent) commands for usage with `/usr/bin/ansible ' and `not' playbooks. See examples.",
            "type": "string"
          },
          "name": {
            "description": "Package name, or package specifier with version, like `name-1.0'. When using state=latest, this can be '*' which means run: yum -y update. You can also pass a url or a local path to a rpm file (using state=present). To operate on several packages this can accept a comma separated list of packages or (as of 2.0) a list of packages.",
            "type": "string"
          },
          "state": {
            "description": "Whether to install (`present' or `installed', `latest'), or remove (`absent' or `removed') a package.",
            "type": "string"
          },
          "update_cache": {
            "description": "Force updating the cache. Has an effect only if state is `present' or `latest'.",
            "type": "string"
          },
          "validate_certs": {
            "description": "This only applies if using a https url as the source of the rpm. e.g. for localinstall. If set to `no', the SSL certificates will not be validated. This should only set to `no' used on personally controlled sites using self-signed certificates as it avoids verifying the source site. Prior to 2.1 the code worked as if this was set to `yes'.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "yum_repository": {
        "type": "object",
        "description": "Add and remove YUM repositories",
        "properties": {
          "async": {
            "description": "If set to `yes' Yum will download packages and metadata from this repo in parallel, if possible.",
            "type": "string"
          },
          "bandwidth": {
            "description": "Maximum available network bandwidth in bytes/second. Used with the `throttle' option. If `throttle' is a percentage and bandwidth is `0' then bandwidth throttling will be disabled. If `throttle' is expressed as a data rate (bytes/sec) then this option is ignored. Default is `0' (no bandwidth throttling).",
            "type": "string"
          },
          "baseurl": {
            "description": "URL to the directory where the yum repository's 'repodata' directory lives. This or the `mirrorlist' parameter is required if `state' is set to `present'.",
            "type": "string"
          },
          "cost": {
            "description": "Relative cost of accessing this repository. Useful for weighing one repo's packages as greater/less than any other.",
            "type": "string"
          },
          "deltarpm_metadata_percentage": {
            "description": "When the relative size of deltarpm metadata vs pkgs is larger than this, deltarpm metadata is not downloaded from the repo. Note that you can give values over `100', so `200' means that the metadata is required to be half the size of the packages. Use `0' to turn off this check, and always download metadata.",
            "type": "string"
          },
          "deltarpm_percentage": {
            "description": "When the relative size of delta vs pkg is larger than this, delta is not used. Use `0' to turn off delta rpm processing. Local repositories (with file:// `baseurl') have delta rpms turned off by default.",
            "type": "string"
          },
          "description": {
            "description": "A human readable string describing the repository. This parameter is only required if `state' is set to `present'.",
            "type": "string"
          },
          "enabled": {
            "description": "This tells yum whether or not use this repository.",
            "type": "string"
          },
          "enablegroups": {
            "description": "Determines whether yum will allow the use of package groups for this repository.",
            "type": "string"
          },
          "exclude": {
            "description": "List of packages to exclude from updates or installs. This should be a space separated list. Shell globs using wildcards (eg. `*' and `?') are allowed. The list can also be a regular YAML array.",
            "type": "string"
          },
          "failovermethod": {
            "description": "`roundrobin' randomly selects a URL out of the list of URLs to start with and proceeds through each of them as it encounters a failure contacting the host. `priority' starts from the first `baseurl' listed and reads through them sequentially.",
            "type": "string"
          },
          "file": {
            "description": "File to use to save the repo in. Defaults to the value of `name'.",
            "type": "string"
          },
          "gpgcakey": {
            "description": "A URL pointing to the ASCII-armored CA key file for the repository.",
            "type": "string"
          },
          "gpgcheck": {
            "description": "Tells yum whether or not it should perform a GPG signature check on packages.",
            "type": "string"
          },
          "gpgkey": {
            "description": "A URL pointing to the ASCII-armored GPG key file for the repository.",
            "type": "string"
          },
          "group": {
            "description": "name of the group that should own the file/directory, as would be fed to `chown'",
            "type": "string"
          },
          "http_caching": {
            "description": "Determines how upstream HTTP caches are instructed to handle any HTTP downloads that Yum does. `all' means that all HTTP downloads should be cached. `packages' means that only RPM package downloads should be cached (but not repository metadata downloads). `none' means that no HTTP downloads should be cached.",
            "type": "string"
          },
          "include": {
            "description": "Include external configuration file. Both, local path and URL is supported. Configuration file will be inserted at the position of the `include=' line. Included files may contain further include lines. Yum will abort with an error if an inclusion loop is detected.",
            "type": "string"
          },
          "includepkgs": {
            "description": "List of packages you want to only use from a repository. This should be a space separated list. Shell globs using wildcards (eg. `*' and `?') are allowed. Substitution variables (e.g. `$releasever') are honored here. The list can also be a regular YAML array.",
            "type": "string"
          },
          "ip_resolve": {
            "description": "Determines how yum resolves host names. `4' or `IPv4' - resolve to IPv4 addresses only. `6' or `IPv6' - resolve to IPv6 addresses only.",
            "type": "string"
          },
          "keepalive": {
            "description": "This tells yum whether or not HTTP/1.1 keepalive should be used with this repository. This can improve transfer speeds by using one connection when downloading multiple files from a repository.",
            "type": "string"
          },
          "keepcache": {
            "description": "Either `1' or `0'. Determines whether or not yum keeps the cache of headers and packages after successful installation.",
            "type": "string"
          },
          "metadata_expire": {
            "description": "Time (in seconds) after which the metadata will expire. Default value is 6 hours.",
            "type": "string"
          },
          "metadata_expire_filter": {
            "description": "Filter the `metadata_expire' time, allowing a trade of speed for accuracy if a command doesn't require it. Each yum command can specify that it requires a certain level of timeliness quality from the remote repos. from \"I'm about to install/upgrade, so this better be current\" to \"Anything that's available is good enough\". `never' - Nothing is filtered, always obey `metadata_ex pire'. `read- only:past' - Commands that only care about past information are filtered from metadata expiring. Eg. `yum history' info (if history needs to lookup anything about a previous transaction, then by definition the remote package was available in the past). `read- only:present' - Commands that are balanced between past and future. Eg. `yum list yum'. `read- only:future' - Commands that are likely to result in running other commands which will require the latest metadata. Eg. `yum check- update'. Note that this option does not override \"yum clean expire-cache\".",
            "type": "string"
          },
          "metalink": {
            "description": "Specifies a URL to a metalink file for the repomd.xml, a list of mirrors for the entire repository are generated by converting the mirrors for the repomd.xml file to a `baseurl'.",
            "type": "string"
          },
          "mirrorlist": {
            "description": "Specifies a URL to a file containing a list of baseurls. This or the `baseurl' parameter is required if `state' is set to `present'.",
            "type": "string"
          },
          "mirrorlist_expire": {
            "description": "Time (in seconds) after which the mirrorlist locally cached will expire. Default value is 6 hours.",
            "type": "string"
          },
          "mode": {
            "description": "mode the file or directory should be. For those used to `/usr/bin/chmod' remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, `u+rwx' or `u=rw,g=r,o=r').",
            "type": "string"
          },
          "name": {
            "description": "Unique repository ID. This parameter is only required if `state' is set to `present' or `absent'.",
            "type": "string"
          },
          "owner": {
            "description": "name of the user that should own the file/directory, as would be fed to `chown'",
            "type": "string"
          },
          "params": {
            "description": "Option used to allow the user to overwrite any of the other options. To remove an option, set the value of the option to `null'.",
            "type": "string"
          },
          "password": {
            "description": "Password to use with the username for basic authentication.",
            "type": "string"
          },
          "priority": {
            "description": "Enforce ordered protection of repositories. The value is an integer from 1 to 99. This option only works if the YUM Priorities plugin is installed.",
            "type": "string"
          },
          "protect": {
            "description": "Protect packages from updates from other repositories.",
            "type": "string"
          },
          "proxy": {
            "description": "URL to the proxy server that yum should use. Set to `_none_' to disable the global proxy setting.",
            "type": "string"
          },
          "proxy_password": {
            "description": "Username to use for proxy.",
            "type": "string"
          },
          "proxy_username": {
            "description": "Password for this proxy.",
            "type": "string"
          },
          "repo_gpgcheck": {
            "description": "This tells yum whether or not it should perform a GPG signature check on the repodata from this repository.",
            "type": "string"
          },
          "reposdir": {
            "description": "Directory where the `.repo' files will be stored.",
            "type": "string"
          },
          "retries": {
            "description": "Set the number of times any attempt to retrieve a file should retry before returning an error. Setting this to `0' makes yum try forever.",
            "type": "string"
          },
          "s3_enabled": {
            "description": "Enables support for S3 repositories. This option only works if the YUM S3 plugin is installed.",
            "type": "string"
          },
          "selevel": {
            "description": "level part of the SELinux file context. This is the MLS/MCS attribute, sometimes known as the `range'. `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "serole": {
            "description": "role part of SELinux file context, `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "setype": {
            "description": "type part of SELinux file context, `_default' feature works as for `seuser'.",
            "type": "string"
          },
          "seuser": {
            "description": "user part of SELinux file context. Will default to system policy, if applicable. If set to `_default', it will use the `user' portion of the policy if available",
            "type": "string"
          },
          "skip_if_unavailable": {
            "description": "If set to `yes' yum will continue running if this repository cannot be contacted for any reason. This should be set carefully as all repos are consulted for any given command.",
            "type": "string"
          },
          "ssl_check_cert_permissions": {
            "description": "Whether yum should check the permissions on the paths for the certificates on the repository (both remote and local). If we can't read any of the files then yum will force `s kip_if_unavailabl e' to be `yes'. This is most useful for non- root processes which use yum on repos that have client cert files which are readable only by root.",
            "type": "string"
          },
          "sslcacert": {
            "description": "Path to the directory containing the databases of the certificate authorities yum should use to verify SSL certificates.",
            "type": "string"
          },
          "sslclientcert": {
            "description": "Path to the SSL client certificate yum should use to connect to repos/remote sites.",
            "type": "string"
          },
          "sslclientkey": {
            "description": "Path to the SSL client key yum should use to connect to repos/remote sites.",
            "type": "string"
          },
          "sslverify": {
            "description": "Defines whether yum should verify SSL certificates/host s at all.",
            "type": "string"
          },
          "state": {
            "description": "State of the repo file.",
            "type": "string"
          },
          "throttle": {
            "description": "Enable bandwidth throttling for downloads. This option can be expressed as a absolute data rate in bytes/sec. An SI prefix (k, M or G) may be appended to the bandwidth value.",
            "type": "string"
          },
          "timeout": {
            "description": "Number of seconds to wait for a connection before timing out.",
            "type": "string"
          },
          "ui_repoid_vars": {
            "description": "When a repository id is displayed, append these yum variables to the string if they are used in the `baseurl'/etc. Variables are appended in the order listed (and found).",
            "type": "string"
          },
          "unsafe_writes": {
            "description": "Normally this module uses atomic operations to prevent data corruption or inconsistent reads from the target files, sometimes systems are configured or just broken in ways that prevent this. One example are docker mounted files, they cannot be updated atomically and can only be done in an unsafe manner. This boolean option allows ansible to fall back to unsafe methods of updating files for those cases in which you do not have any other choice. Be aware that this is subject to race conditions and can lead to data corruption.",
            "type": "string"
          },
          "username": {
            "description": "Username to use for basic authentication to a repo or really any url.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "zabbix_group": {
        "type": "object",
        "description": "Zabbix host groups creates/deletes",
        "properties": {
          "host_groups": {
            "description": "List of host groups to create or delete.",
            "type": "string"
          },
          "http_login_password": {
            "description": "Basic Auth password",
            "type": "string"
          },
          "http_login_user": {
            "description": "Basic Auth login",
            "type": "string"
          },
          "login_password": {
            "description": "Zabbix user password.",
            "type": "string"
          },
          "login_user": {
            "description": "Zabbix user name.",
            "type": "string"
          },
          "server_url": {
            "description": "Url of Zabbix server, with protocol (http or https). `url' is an alias for `server_url'.",
            "type": "string"
          },
          "state": {
            "description": "Create or delete host group.",
            "type": "string"
          },
          "timeout": {
            "description": "The timeout of API request(seconds).",
            "type": "string"
          }
        },
        "required": [
          "host_groups",
          "login_password",
          "login_user",
          "server_url"
        ]
      }
    },
    {
      "zabbix_host": {
        "type": "object",
        "description": "Zabbix host creates/updates/deletes",
        "properties": {
          "force": {
            "description": "Overwrite the host configuration, even if already present",
            "type": "string"
          },
          "host_groups": {
            "description": "List of host groups the host is part of.",
            "type": "string"
          },
          "host_name": {
            "description": "Name of the host in Zabbix. host_name is the unique identifier used and cannot be updated using this module.",
            "type": "string"
          },
          "http_login_password": {
            "description": "Basic Auth password",
            "type": "string"
          },
          "http_login_user": {
            "description": "Basic Auth login",
            "type": "string"
          },
          "interfaces": {
            "description": "List of interfaces to be created for the host (see example below). Available values are: dns, ip, main, port, type and useip. Please review the interface documentation for more information on the supported properties https: //www.zabbix.com/ documentation/2.0 /manual/appendix/ api/hostinterface /definitions#host _interface",
            "type": "string"
          },
          "inventory_mode": {
            "description": "Configure the inventory mode.",
            "type": "string"
          },
          "link_templates": {
            "description": "List of templates linked to the host.",
            "type": "string"
          },
          "login_password": {
            "description": "Zabbix user password.",
            "type": "string"
          },
          "login_user": {
            "description": "Zabbix user name, used to authenticate against the server.",
            "type": "string"
          },
          "proxy": {
            "description": "The name of the Zabbix Proxy to be used",
            "type": "string"
          },
          "server_url": {
            "description": "Url of Zabbix server, with protocol (http or https).",
            "type": "string"
          },
          "state": {
            "description": "State of the host. On `present', it will create if host does not exist or update the host if the associated data is different. On `absent' will remove a host if it exists.",
            "type": "string"
          },
          "status": {
            "description": "Monitoring status of the host.",
            "type": "string"
          },
          "timeout": {
            "description": "The timeout of API request (seconds).",
            "type": "string"
          }
        },
        "required": [
          "host_name",
          "login_password",
          "login_user",
          "server_url"
        ]
      }
    },
    {
      "zabbix_hostmacro": {
        "type": "object",
        "description": "Zabbix host macro creates/updates/deletes",
        "properties": {
          "host_name": {
            "description": "Name of the host.",
            "type": "string"
          },
          "http_login_password": {
            "description": "Basic Auth password",
            "type": "string"
          },
          "http_login_user": {
            "description": "Basic Auth login",
            "type": "string"
          },
          "login_password": {
            "description": "Zabbix user password.",
            "type": "string"
          },
          "login_user": {
            "description": "Zabbix user name.",
            "type": "string"
          },
          "macro_name": {
            "description": "Name of the host macro.",
            "type": "string"
          },
          "macro_value": {
            "description": "Value of the host macro.",
            "type": "string"
          },
          "server_url": {
            "description": "Url of Zabbix server, with protocol (http or https).",
            "type": "string"
          },
          "state": {
            "description": "State of the macro. On `present', it will create if macro does not exist or update the macro if the associated data is different. On `absent' will remove a macro if it exists.",
            "type": "string"
          },
          "timeout": {
            "description": "The timeout of API request (seconds).",
            "type": "string"
          }
        },
        "required": [
          "host_name",
          "login_password",
          "login_user",
          "macro_name",
          "macro_value",
          "server_url"
        ]
      }
    },
    {
      "zabbix_maintenance": {
        "type": "object",
        "description": "Create Zabbix maintenance windows",
        "properties": {
          "collect_data": {
            "description": "Type of maintenance. With data collection, or without.",
            "type": "string"
          },
          "desc": {
            "description": "Short description of maintenance window.",
            "type": "string"
          },
          "host_groups": {
            "description": "Host groups to manage maintenance window for. Separate multiple groups with commas. `host_group' is an alias for `host_groups'. *Required* option when `state' is `present' and no `host_names' specified.",
            "type": "string"
          },
          "host_names": {
            "description": "Hosts to manage maintenance window for. Separate multiple hosts with commas. `host_name' is an alias for `host_names'. *Required* option when `state' is `present' and no `host_groups' specified.",
            "type": "string"
          },
          "http_login_password": {
            "description": "Basic Auth password",
            "type": "string"
          },
          "http_login_user": {
            "description": "Basic Auth login",
            "type": "string"
          },
          "login_password": {
            "description": "Zabbix user password.",
            "type": "string"
          },
          "login_user": {
            "description": "Zabbix user name.",
            "type": "string"
          },
          "minutes": {
            "description": "Length of maintenance window in minutes.",
            "type": "string"
          },
          "name": {
            "description": "Unique name of maintenance window.",
            "type": "string"
          },
          "server_url": {
            "description": "Url of Zabbix server, with protocol (http or https). `url' is an alias for `server_url'.",
            "type": "string"
          },
          "state": {
            "description": "Create or remove a maintenance window.",
            "type": "string"
          },
          "timeout": {
            "description": "The timeout of API request (seconds).",
            "type": "string"
          }
        },
        "required": [
          "desc",
          "login_password",
          "login_user",
          "name",
          "server_url"
        ]
      }
    },
    {
      "zabbix_screen": {
        "type": "object",
        "description": "Zabbix screen creates/updates/deletes",
        "properties": {
          "http_login_password": {
            "description": "Basic Auth password",
            "type": "string"
          },
          "http_login_user": {
            "description": "Basic Auth login",
            "type": "string"
          },
          "login_password": {
            "description": "Zabbix user password.",
            "type": "string"
          },
          "login_user": {
            "description": "Zabbix user name.",
            "type": "string"
          },
          "screens": {
            "description": "List of screens to be created/updated/d eleted(see example). If the screen(s) already been added, the screen(s) name won't be updated. When creating or updating screen(s), `screen_name', `host_group' are required. When deleting screen(s), the `screen_name' is required. The available states are: `present' (default) and `absent'. If the screen(s) already exists, and the state is not `absent', the screen(s) will just be updated as needed.",
            "type": "string"
          },
          "server_url": {
            "description": "Url of Zabbix server, with protocol (http or https).",
            "type": "string"
          },
          "timeout": {
            "description": "The timeout of API request (seconds).",
            "type": "string"
          }
        },
        "required": [
          "login_password",
          "login_user",
          "screens",
          "server_url"
        ]
      }
    },
    {
      "zfs": {
        "type": "object",
        "description": "Manage zfs",
        "properties": {
          "key_value": {
            "description": "The `zfs' module takes key=value pairs for zfs properties to be set. See the zfs(8) man page for more information.",
            "type": "string"
          },
          "name": {
            "description": "File system, snapshot or volume name e.g. `rpool/myfs'",
            "type": "string"
          },
          "origin": {
            "description": "Snapshot from which to create a clone",
            "type": "string"
          },
          "state": {
            "description": "Whether to create (`present'), or remove (`absent') a file system, snapshot or volume. All parents/children will be created/destroyed as needed to reach the desired state.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "state"
        ]
      }
    },
    {
      "znode": {
        "type": "object",
        "description": "Create, delete, retrieve, and update znodes using ZooKeeper.",
        "properties": {
          "hosts": {
            "description": "A list of ZooKeeper servers (format '[server]:[port]' ).",
            "type": "string"
          },
          "name": {
            "description": "The path of the znode.",
            "type": "string"
          },
          "op": {
            "description": "An operation to perform. Mutually exclusive with state.",
            "type": "string"
          },
          "recursive": {
            "description": "Recursively delete node and all its children.",
            "type": "string"
          },
          "state": {
            "description": "The state to enforce. Mutually exclusive with op.",
            "type": "string"
          },
          "timeout": {
            "description": "The amount of time to wait for a node to appear.",
            "type": "string"
          },
          "value": {
            "description": "The value assigned to the znode.",
            "type": "string"
          }
        },
        "required": [
          "hosts",
          "name"
        ]
      }
    },
    {
      "zypper": {
        "type": "object",
        "description": "Manage packages on SUSE and openSUSE",
        "properties": {
          "disable_gpg_check": {
            "description": "Whether to disable to GPG signature checking of the package signature being installed. Has an effect only if state is `present' or `latest'.",
            "type": "string"
          },
          "disable_recommends": {
            "description": "Corresponds to the `--no-recommends' option for `zypper'. Default behavior (`yes') modifies zypper's default behavior; `no' does install recommended packages.",
            "type": "string"
          },
          "force": {
            "description": "Adds `--force' option to `zypper'. Allows to downgrade packages and change vendor or architecture.",
            "type": "string"
          },
          "name": {
            "description": "Package name `name' or package specifier. Can include a version like `name=1.0', `name>3.4' or `name<=2.7'. If a version is given, `oldpackage' is implied and zypper is allowed to update the package within the version range given. You can also pass a url or a local path to a rpm file. When using state=latest, this can be '*', which updates all installed packages.",
            "type": "string"
          },
          "oldpackage": {
            "description": "Adds `--oldpackage' option to `zypper'. Allows to downgrade packages with less side-effects than force. This is implied as soon as a version is specified as part of the package name.",
            "type": "string"
          },
          "state": {
            "description": "`present' will make sure the package is installed. `latest'  will make sure the latest version of the package is installed. `absent'  will make sure the specified package is not installed.",
            "type": "string"
          },
          "type": {
            "description": "The type of package to be operated on.",
            "type": "string"
          },
          "update_cache": {
            "description": "Run the equivalent of `zypper refresh' before the operation.",
            "type": "string"
          }
        },
        "required": "name"
      }
    },
    {
      "zypper_repository": {
        "type": "object",
        "description": "Add and remove Zypper repositories",
        "properties": {
          "auto_import_keys": {
            "description": "Automatically import the gpg signing key of the new or changed repository. Has an effect only if state is `present'. Has no effect on existing (unchanged) repositories or in combination with `absent'. Implies runrefresh.",
            "type": "string"
          },
          "autorefresh": {
            "description": "Enable autorefresh of the repository.",
            "type": "string"
          },
          "description": {
            "description": "A description of the repository",
            "type": "string"
          },
          "disable_gpg_check": {
            "description": "Whether to disable GPG signature checking of all packages. Has an effect only if state is `present'. Needs zypper version >= 1.6.2.",
            "type": "string"
          },
          "enabled": {
            "description": "Set repository to enabled (or disabled).",
            "type": "string"
          },
          "name": {
            "description": "A name for the repository. Not required when adding repofiles.",
            "type": "string"
          },
          "overwrite_multiple": {
            "description": "Overwrite multiple repository entries, if repositories with both name and URL already exist.",
            "type": "string"
          },
          "priority": {
            "description": "Set priority of repository. Packages will always be installed from the repository with the smallest priority number. Needs zypper version >= 1.12.25.",
            "type": "string"
          },
          "repo": {
            "description": "URI of the repository or .repo file. Required when state=present.",
            "type": "string"
          },
          "runrefresh": {
            "description": "Refresh the package list of the given repository. Can be used with repo=* to refresh all repositories.",
            "type": "string"
          },
          "state": {
            "description": "A source string state.",
            "type": "string"
          }
        }
      }
    }
  ]
}
